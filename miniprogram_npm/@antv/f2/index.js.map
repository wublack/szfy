{"version":3,"sources":["index.js","core.js","global.js","theme.js","util\\common.js","util\\dom.js","chart\\chart.js","base.js","chart\\plot.js","coord\\index.js","coord\\base.js","graphic\\util\\matrix.js","graphic\\util\\vector2.js","coord\\cartesian.js","geom\\base.js","attr\\index.js","attr\\color.js","attr\\color-util.js","geom\\shape\\shape.js","chart\\controller\\scale.js","scale\\index.js","chart\\controller\\axis.js","component\\axis\\index.js","component\\axis\\abstract.js","component\\axis\\line.js","graphic\\index.js","graphic\\canvas.js","graphic\\container.js","graphic\\shape.js","graphic\\element.js","graphic\\util\\style-parse.js","graphic\\group.js","graphic\\util\\requestAnimationFrame.js","graphic\\canvas-element.js","graphic\\shape\\rect.js","graphic\\shape\\circle.js","graphic\\shape\\line.js","graphic\\util\\bbox.js","graphic\\shape\\polygon.js","graphic\\shape\\polyline.js","graphic\\util\\smooth.js","graphic\\shape\\arc.js","graphic\\shape\\sector.js","graphic\\shape\\text.js","graphic\\util\\rect.js","graphic\\shape\\custom.js","util\\helper.js","geom\\index.js","geom\\point.js","geom\\shape\\point.js","geom\\shape\\util.js","geom\\path.js","geom\\shape\\line.js","geom\\line.js","geom\\area.js","geom\\shape\\area.js","geom\\interval.js","geom\\mixin\\size.js","geom\\shape\\interval.js","geom\\polygon.js","geom\\shape\\polygon.js","geom\\schema.js","geom\\shape\\schema.js","geom\\adjust\\index.js","geom\\adjust\\stack.js","geom\\adjust\\dodge.js","geom\\adjust\\symmetric.js","coord\\polar.js","component\\axis\\circle.js","scale\\time-cat.js","component\\guide\\arc.js","component\\guide\\base.js","component\\guide\\html.js","component\\guide\\line.js","component\\guide\\rect.js","component\\guide\\text.js","component\\guide\\tag.js","component\\guide\\point.js","plugin\\tooltip.js","component\\tooltip.js","component\\marker.js","component\\list.js","component\\text-box.js","plugin\\guide.js","plugin\\legend.js","animation\\detail.js","graphic\\animate\\timeline.js","graphic\\animate\\animator.js","graphic\\animate\\easing.js","animation\\animate.js","animation\\shape-action.js","animation\\util.js","animation\\group-action.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA,ACHA;AHUA,ACHA,AFMA,AGTA,ACHA;AHUA,ACHA,AFMA,AGTA,ACHA;AHUA,ACHA,AFMA,AGTA,ACHA,ACHA;AJaA,ACHA,AFMA,AGTA,ACHA,ACHA;AJaA,ACHA,AFMA,AGTA,ACHA,ACHA;ACFA,ALeA,ACHA,AFMA,AGTA,ACHA,ACHA;ACFA,ALeA,ACHA,AFMA,AGTA,ACHA,ACHA;ACFA,ALeA,ACHA,AFMA,AGTA,ACHA,ACHA;AELA,ADGA,ALeA,ACHA,AFMA,AGTA,ACHA,ACHA;AELA,ADGA,ALeA,ACHA,AFMA,AGTA,ACHA,ACHA;AELA,ADGA,ALeA,ACHA,AFMA,AGTA,ACHA,ACHA;AELA,ADGA,AENA,APqBA,ACHA,AFMA,AGTA,ACHA,ACHA;AELA,ADGA,AENA,ANkBA,AFMA,AGTA,ACHA,ACHA;AELA,ADGA,AENA,ANkBA,AFMA,AGTA,ACHA,ACHA;AELA,ADGA,AENA,ACHA,APqBA,AFMA,AGTA,ACHA,ACHA;AELA,ADGA,AENA,ACHA,APqBA,AFMA,AGTA,ACHA,ACHA;AELA,ADGA,AENA,ACHA,AT2BA,AGTA,ACHA,ACHA;AELA,ADGA,AENA,AENA,ADGA,AT2BA,AGTA,ACHA,ACHA;AELA,ADGA,AENA,AENA,ADGA,AT2BA,AGTA,ACHA,ACHA;AELA,ADGA,AENA,AENA,ADGA,AT2BA,AGTA,ACHA,ACHA;AELA,ADGA,AENA,AENA,ADGA,AENA,AXiCA,AGTA,ACHA,ACHA;AELA,ADGA,AENA,AENA,ACHA,AXiCA,AGTA,ACHA,ACHA;AELA,ADGA,AENA,AENA,ACHA,AXiCA,AGTA,ACHA,ACHA;AELA,ADGA,AENA,AENA,ACHA,ACHA,AZoCA,AGTA,ACHA,ACHA;AELA,ADGA,AENA,AENA,ACHA,ACHA,AZoCA,AGTA,ACHA,ACHA;AELA,ADGA,AENA,AENA,ACHA,ACHA,AZoCA,AGTA,ACHA,ACHA;AELA,ADGA,AENA,AENA,AGTA,AFMA,ACHA,AZoCA,AGTA,ACHA,ACHA;AELA,ADGA,AENA,AENA,AGTA,AFMA,ACHA,AZoCA,AGTA,ACHA,ACHA;AELA,ADGA,AENA,AENA,AGTA,AFMA,ACHA,AZoCA,AGTA,ACHA,ACHA;AELA,ADGA,AENA,AENA,AGTA,ACHA,AHSA,ACHA,AZoCA,AGTA,ACHA,ACHA;AELA,ADGA,AENA,AENA,AGTA,ACHA,AHSA,ACHA,AZoCA,AGTA,ACHA,ACHA;AELA,ADGA,AENA,AENA,AGTA,ACHA,AHSA,ACHA,AZoCA,AGTA,ACHA,ACHA;AU7BA,ARwBA,ADGA,AENA,AENA,AGTA,ACHA,AHSA,ACHA,AZoCA,AGTA,ACHA,ACHA;AU7BA,ARwBA,ADGA,AENA,AENA,AGTA,ACHA,AHSA,ACHA,AT2BA,ACHA,ACHA;AU7BA,ARwBA,ADGA,AENA,AENA,AGTA,ACHA,AHSA,ACHA,AT2BA,ACHA,ACHA;AWhCA,ADGA,ARwBA,ADGA,AENA,AENA,AGTA,ACHA,AHSA,ACHA,AT2BA,ACHA,ACHA;AWhCA,ADGA,ARwBA,ADGA,AENA,AENA,AGTA,ACHA,AHSA,ACHA,AT2BA,ACHA,ACHA;AWhCA,ADGA,ARwBA,ADGA,AENA,AENA,AGTA,ACHA,AHSA,ACHA,AT2BA,ACHA,ACHA;AYnCA,ADGA,ADGA,ARwBA,ADGA,AENA,AENA,AGTA,ACHA,AHSA,ACHA,AT2BA,ACHA,ACHA;AYnCA,ADGA,ADGA,ARwBA,ADGA,AENA,AENA,AGTA,ACHA,AHSA,ACHA,AT2BA,ACHA,ACHA;AYnCA,ADGA,AT2BA,ADGA,AENA,AENA,AGTA,ACHA,AHSA,ACHA,AT2BA,ACHA,ACHA;AYnCA,ADGA,AT2BA,ADGA,AENA,AENA,AGTA,ACHA,AIZA,APqBA,ACHA,AT2BA,ACHA,ACHA;AYnCA,ADGA,AT2BA,ADGA,AENA,AENA,AGTA,ACHA,AIZA,APqBA,ACHA,AT2BA,ACHA,ACHA;AYnCA,ADGA,AT2BA,ADGA,AENA,AENA,AGTA,ACHA,AIZA,APqBA,ACHA,AT2BA,ACHA,ACHA;AYnCA,ADGA,AT2BA,ADGA,AavCA,AXiCA,AENA,AGTA,ACHA,AIZA,APqBA,ACHA,AT2BA,ACHA,ACHA;AYnCA,ADGA,AT2BA,ADGA,AavCA,AXiCA,AENA,AGTA,ACHA,AIZA,APqBA,ACHA,AT2BA,ACHA,ACHA;AYnCA,ADGA,AT2BA,ADGA,AavCA,AXiCA,AENA,AGTA,ACHA,AIZA,APqBA,ACHA,AT2BA,ACHA,ACHA;AYnCA,ADGA,AT2BA,ADGA,AavCA,AXiCA,AENA,AGTA,ACHA,AIZA,APqBA,ACHA,AQxBA,AjBmDA,ACHA,ACHA;AYnCA,ADGA,AT2BA,ADGA,AavCA,AXiCA,AENA,AGTA,ACHA,AIZA,APqBA,ACHA,AQxBA,AjBmDA,ACHA,ACHA;AYnCA,ADGA,AV8BA,AavCA,AXiCA,AENA,AGTA,ACHA,AIZA,APqBA,ACHA,AQxBA,AjBmDA,ACHA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,AENA,AGTA,ACHA,AIZA,APqBA,ACHA,AQxBA,AjBmDA,ACHA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,AENA,AGTA,ACHA,AIZA,APqBA,ACHA,AQxBA,AjBmDA,ACHA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,AENA,AGTA,ACHA,AIZA,APqBA,ACHA,AQxBA,AjBmDA,ACHA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ac1CA,AZoCA,AGTA,ACHA,AIZA,APqBA,ACHA,AQxBA,AjBmDA,ACHA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ac1CA,AZoCA,AGTA,ACHA,AIZA,APqBA,ACHA,AQxBA,AjBmDA,ACHA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ac1CA,AZoCA,AGTA,ACHA,AIZA,APqBA,ACHA,AQxBA,AjBmDA,ACHA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ae7CA,ADGA,AZoCA,AGTA,ACHA,AIZA,APqBA,ACHA,AQxBA,AjBmDA,ACHA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ae7CA,ADGA,AZoCA,AGTA,ACHA,AIZA,APqBA,ACHA,AQxBA,AjBmDA,ACHA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ae7CA,ADGA,AZoCA,AGTA,ACHA,AIZA,APqBA,ACHA,AT2BA,ACHA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ae7CA,ADGA,AENA,Ad0CA,AGTA,ACHA,AIZA,APqBA,ACHA,AT2BA,ACHA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ae7CA,ACHA,Ad0CA,AGTA,ACHA,AIZA,APqBA,ACHA,AT2BA,ACHA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ae7CA,ACHA,Ad0CA,AGTA,ACHA,AIZA,APqBA,ACHA,AT2BA,ACHA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ae7CA,ACHA,Ad0CA,AGTA,ACHA,AIZA,AOrBA,Ad0CA,ACHA,AT2BA,ACHA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ae7CA,ACHA,Ad0CA,AGTA,ACHA,AIZA,AOrBA,Ad0CA,ACHA,AT2BA,ACHA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ae7CA,ACHA,Ad0CA,AGTA,ACHA,AIZA,AOrBA,Ad0CA,ACHA,AT2BA,ACHA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ae7CA,ACHA,Ad0CA,AGTA,ACHA,AIZA,AQxBA,ADGA,Ad0CA,ACHA,AT2BA,ACHA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ae7CA,ACHA,Ad0CA,AGTA,ACHA,AIZA,AQxBA,ADGA,Ad0CA,ACHA,AT2BA,ACHA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ae7CA,ACHA,Ad0CA,AGTA,ACHA,AIZA,AQxBA,ADGA,Ad0CA,ACHA,AT2BA,ACHA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ae7CA,ACHA,Ad0CA,AGTA,ACHA,AIZA,AQxBA,ACHA,AFMA,Ad0CA,ACHA,AT2BA,ACHA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ae7CA,ACHA,Ad0CA,AGTA,ACHA,AIZA,AQxBA,ACHA,AFMA,Ad0CA,ACHA,AT2BA,ACHA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ae7CA,ACHA,Ad0CA,AGTA,ACHA,AIZA,AQxBA,ACHA,AFMA,Ad0CA,ACHA,AT2BA,ACHA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ae7CA,ACHA,Ad0CA,AGTA,ACHA,AIZA,AQxBA,ACHA,AFMA,AGTA,AjBmDA,ACHA,AT2BA,ACHA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ae7CA,ACHA,Ad0CA,AGTA,ACHA,AIZA,AQxBA,ACHA,AFMA,AGTA,AjBmDA,ACHA,AT2BA,ACHA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ae7CA,ACHA,Ad0CA,AGTA,ACHA,AIZA,AQxBA,ACHA,AFMA,AGTA,AjBmDA,ACHA,AT2BA,ACHA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ae7CA,ACHA,Ad0CA,AGTA,ACHA,AIZA,AQxBA,ACHA,AENA,AJYA,AGTA,AjBmDA,ACHA,ARwBA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ae7CA,ACHA,Ad0CA,AGTA,ACHA,AIZA,AQxBA,ACHA,AENA,AJYA,AGTA,AjBmDA,ACHA,ARwBA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ae7CA,ACHA,Ad0CA,AGTA,ACHA,AIZA,AQxBA,ACHA,AENA,AJYA,AGTA,AjBmDA,ACHA,ARwBA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ae7CA,ACHA,Ad0CA,AGTA,ACHA,AIZA,AQxBA,ACHA,AENA,AJYA,AGTA,AjBmDA,AmBzDA,AlBsDA,ARwBA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ae7CA,ACHA,Ad0CA,AGTA,ACHA,AIZA,AQxBA,ACHA,AENA,AJYA,AGTA,AjBmDA,AmBzDA,AlBsDA,ARwBA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ae7CA,ACHA,Ad0CA,AGTA,ACHA,AIZA,AQxBA,ACHA,AENA,AJYA,AGTA,AjBmDA,AmBzDA,AlBsDA,ARwBA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ae7CA,ACHA,Ad0CA,AGTA,ACHA,AIZA,AQxBA,ACHA,AENA,AENA,ANkBA,AGTA,AjBmDA,AmBzDA,AlBsDA,ARwBA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ae7CA,ACHA,Ad0CA,AGTA,ACHA,AIZA,AQxBA,ACHA,AENA,AENA,ANkBA,AGTA,AjBmDA,AmBzDA,AlBsDA,ARwBA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ae7CA,ACHA,Ad0CA,AGTA,ACHA,AIZA,AQxBA,ACHA,AENA,AENA,ANkBA,AGTA,AjBmDA,AmBzDA,AlBsDA,ARwBA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ae7CA,ACHA,Ad0CA,AGTA,ACHA,AIZA,AQxBA,ACHA,AENA,AENA,ANkBA,AGTA,AjBmDA,AqB/DA,AFMA,AlBsDA,ARwBA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ae7CA,ACHA,Ad0CA,AGTA,ACHA,AIZA,AQxBA,ACHA,AENA,AENA,ANkBA,AGTA,AjBmDA,AqB/DA,AFMA,AlBsDA,ARwBA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ae7CA,ACHA,Ad0CA,AGTA,ACHA,AIZA,AQxBA,ACHA,AENA,AENA,ANkBA,AGTA,AjBmDA,AqB/DA,AFMA,AlBsDA,ARwBA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ae7CA,ACHA,Ad0CA,AGTA,ACHA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,ANkBA,AGTA,AjBmDA,AqB/DA,AFMA,AlBsDA,ARwBA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ae7CA,ACHA,Ad0CA,AGTA,ACHA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,ANkBA,AGTA,AjBmDA,AqB/DA,AFMA,AlBsDA,ARwBA,ACHA;AYnCA,ADGA,AV8BA,Ae7CA,AFMA,AXiCA,Ae7CA,ACHA,Ad0CA,AGTA,ACHA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,ANkBA,AGTA,AjBmDA,AqB/DA,AFMA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,ACHA,Ad0CA,AGTA,ACHA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,ANkBA,AGTA,AMlBA,AvBqEA,AqB/DA,AFMA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,ACHA,Ad0CA,AGTA,ACHA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,ANkBA,AGTA,AMlBA,AvBqEA,AmBzDA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,ACHA,Ad0CA,AGTA,ACHA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AMlBA,AvBqEA,AmBzDA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,ACHA,Ad0CA,AGTA,ACHA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AOrBA,ADGA,AvBqEA,AmBzDA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,ACHA,Ad0CA,AGTA,ACHA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AOrBA,ADGA,AJYA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,ACHA,Ad0CA,AGTA,ACHA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AOrBA,ADGA,AJYA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,ACHA,Ad0CA,AGTA,ACHA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AOrBA,ACHA,AFMA,AJYA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,ACHA,Ad0CA,AIZA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AOrBA,ACHA,AFMA,AJYA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,ACHA,Ad0CA,AIZA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AOrBA,ACHA,AFMA,AJYA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,ACHA,Ad0CA,AIZA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AOrBA,ACHA,AFMA,AGTA,APqBA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,ACHA,Ad0CA,AIZA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AOrBA,ACHA,AFMA,AGTA,APqBA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,ACHA,Ad0CA,AIZA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AOrBA,ACHA,AFMA,AGTA,APqBA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,ACHA,Ad0CA,AIZA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AOrBA,ACHA,AENA,AJYA,AGTA,APqBA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,ACHA,Ad0CA,AIZA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AOrBA,ACHA,AENA,AJYA,AGTA,APqBA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,ACHA,Ad0CA,AIZA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AOrBA,ACHA,AENA,AJYA,AGTA,APqBA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,ACHA,Ad0CA,AIZA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AOrBA,ACHA,AENA,ACHA,ALeA,AGTA,APqBA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,ACHA,Ad0CA,AIZA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AOrBA,ACHA,AENA,ACHA,ALeA,AGTA,APqBA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,ACHA,Ad0CA,AIZA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AOrBA,ACHA,AENA,ACHA,ALeA,AGTA,APqBA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,ACHA,Ad0CA,AIZA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AOrBA,ACHA,AENA,ACHA,ALeA,AGTA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,ACHA,Ad0CA,AIZA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AOrBA,ACHA,AENA,ACHA,ALeA,AGTA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,ACHA,Ad0CA,AIZA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AOrBA,ACHA,AENA,ACHA,ALeA,AGTA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,ACHA,Ad0CA,AIZA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,ACHA,AENA,ACHA,ALeA,AGTA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,ACHA,Ad0CA,AIZA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,ACHA,AENA,ACHA,ALeA,AGTA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,ACHA,Ad0CA,AIZA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,ACHA,AENA,ACHA,ALeA,AGTA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,ACHA,AV8BA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,ACHA,AENA,ACHA,ALeA,AQxBA,ALeA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,ACHA,AV8BA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,ACHA,AENA,ACHA,ALeA,AQxBA,ALeA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,ACHA,AV8BA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,ACHA,AENA,ACHA,ALeA,AQxBA,ALeA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,ACHA,AV8BA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,ACHA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,ACHA,AV8BA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,ACHA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,ACHA,AV8BA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,ACHA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,ACHA,AV8BA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,ACHA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AOrBA,AJYA,AV8BA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,ACHA,AV8BA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,ACHA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AOrBA,AJYA,AV8BA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,ACHA,AV8BA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,ACHA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AOrBA,AJYA,AV8BA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,AT2BA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,AU9BA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AOrBA,AJYA,AV8BA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,AT2BA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,AU9BA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AOrBA,AJYA,AV8BA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,AT2BA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,AU9BA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AOrBA,AJYA,AV8BA,AlBsDA,ARwBA,ACHA;AYnCA,AXiCA,Ae7CA,AFMA,AIZA,AT2BA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,AU9BA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AOrBA,AJYA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;A7BwFA,AXiCA,Ae7CA,AFMA,AIZA,AT2BA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,AU9BA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AOrBA,AJYA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;A7BwFA,AXiCA,Ae7CA,AFMA,AIZA,AT2BA,AIZA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,AU9BA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AOrBA,AJYA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;A7BwFA,AXiCA,Ae7CA,AFMA,AIZA,AT2BA,AiCnGA,A7BuFA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,AU9BA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AOrBA,AJYA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;A7BwFA,AXiCA,Ae7CA,AFMA,AIZA,AT2BA,AiCnGA,A7BuFA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,AU9BA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AOrBA,AJYA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;A7BwFA,AXiCA,Ae7CA,AFMA,AIZA,AT2BA,AiCnGA,A7BuFA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,AU9BA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AOrBA,AJYA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;A7BwFA,AXiCA,Ae7CA,AFMA,AIZA,AT2BA,AiCnGA,ACHA,A9B0FA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,AU9BA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AOrBA,AJYA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;A7BwFA,AXiCA,Ae7CA,AFMA,AIZA,AT2BA,AiCnGA,ACHA,A9B0FA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,AU9BA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AOrBA,AJYA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;A7BwFA,AXiCA,Ae7CA,AFMA,AIZA,AT2BA,AiCnGA,ACHA,A9B0FA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,AU9BA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AOrBA,AJYA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;A7BwFA,AXiCA,Ae7CA,AFMA,AIZA,AT2BA,AiCnGA,ACHA,ACHA,A/B6FA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,AU9BA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;A7BwFA,AXiCA,Ae7CA,AFMA,AIZA,AT2BA,AiCnGA,ACHA,ACHA,A/B6FA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,AU9BA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;A7BwFA,AXiCA,Ae7CA,AFMA,AIZA,AT2BA,AiCnGA,ACHA,ACHA,A/B6FA,Ae7CA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,AU9BA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;A7BwFA,AXiCA,Ae7CA,AFMA,AIZA,AT2BA,AiCnGA,ACHA,ACHA,A/B6FA,AgChGA,AjBmDA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,AU9BA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;A7BwFA,AXiCA,Ae7CA,AFMA,AIZA,AT2BA,AiCnGA,ACHA,ACHA,A/B6FA,AgChGA,AjBmDA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,AU9BA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;A7BwFA,AXiCA,Ae7CA,AFMA,AIZA,AT2BA,AiCnGA,ACHA,ACHA,A/B6FA,AgChGA,AjBmDA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,AU9BA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;A7BwFA,AXiCA,Ae7CA,AFMA,AIZA,AT2BA,AiCnGA,AIZA,AHSA,ACHA,A/B6FA,AgChGA,AjBmDA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,AU9BA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;A7BwFA,AXiCA,Ae7CA,AFMA,AIZA,AT2BA,AiCnGA,AIZA,AHSA,ACHA,A/B6FA,AgChGA,AjBmDA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,AU9BA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;A7BwFA,AXiCA,Ae7CA,AFMA,AIZA,AT2BA,AiCnGA,AIZA,AHSA,ACHA,A/B6FA,AgChGA,AjBmDA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,AU9BA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;A7BwFA,AXiCA,Ae7CA,AFMA,AIZA,AT2BA,AiCnGA,AIZA,AHSA,AIZA,AHSA,A/B6FA,AgChGA,AjBmDA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,AU9BA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;A7BwFA,AXiCA,Ae7CA,AFMA,AIZA,AT2BA,AiCnGA,AIZA,AHSA,AIZA,AHSA,A/B6FA,AgChGA,AjBmDA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,AU9BA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;A7BwFA,AXiCA,Ae7CA,AFMA,AIZA,AT2BA,AiCnGA,AIZA,AHSA,AIZA,AHSA,A/B6FA,AgChGA,AjBmDA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,AU9BA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;A7BwFA,AXiCA,Ae7CA,AFMA,AIZA,AT2BA,AiCnGA,AMlBA,AFMA,AHSA,AIZA,AHSA,A/B6FA,AgChGA,AjBmDA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,AU9BA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;A7BwFA,AXiCA,Ae7CA,AFMA,AIZA,AT2BA,AuCrHA,AFMA,AHSA,AIZA,AHSA,A/B6FA,AgChGA,AjBmDA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,AU9BA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;A7BwFA,AXiCA,Ae7CA,AFMA,AIZA,AT2BA,AuCrHA,AFMA,AHSA,AIZA,AHSA,A/B6FA,AgChGA,AjBmDA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,AU9BA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;A7BwFA,AXiCA,Ae7CA,AFMA,AIZA,A+B7FA,AxCwHA,AuCrHA,AFMA,AHSA,AIZA,AHSA,A/B6FA,AgChGA,AjBmDA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,AU9BA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;A7BwFA,AXiCA,Ae7CA,AFMA,AIZA,A+B7FA,AxCwHA,AuCrHA,AFMA,AHSA,AIZA,AHSA,A/B6FA,AgChGA,AjBmDA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,AU9BA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;A7BwFA,AXiCA,Ae7CA,AFMA,AIZA,A+B7FA,AxCwHA,AuCrHA,AFMA,AHSA,AIZA,AHSA,A/B6FA,AgChGA,AjBmDA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,AU9BA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;AxCyHA,Ae7CA,AFMA,AIZA,A+B7FA,AxCwHA,AuCrHA,AFMA,AHSA,AOrBA,AHSA,AHSA,A/B6FA,AgChGA,AjBmDA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,AU9BA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;AxCyHA,Ae7CA,AFMA,AIZA,A+B7FA,AxCwHA,AuCrHA,AFMA,AHSA,AOrBA,AHSA,AHSA,A/B6FA,AgChGA,AjBmDA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,AU9BA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;AxCyHA,Ae7CA,AFMA,AIZA,A+B7FA,AxCwHA,AuCrHA,AFMA,AHSA,AOrBA,AHSA,AHSA,A/B6FA,AgChGA,AjBmDA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,AU9BA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;AxCyHA,Ae7CA,AFMA,AIZA,A+B7FA,AxCwHA,A0C9HA,AHSA,AFMA,AHSA,AOrBA,AHSA,AHSA,A/B6FA,AgChGA,AjBmDA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,ANkBA,AU9BA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;AxCyHA,Ae7CA,AFMA,AIZA,A+B7FA,AxCwHA,A0C9HA,AHSA,AFMA,AHSA,AOrBA,AHSA,AHSA,A/B6FA,AgChGA,AjBmDA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,AIZA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;AxCyHA,Ae7CA,AFMA,AIZA,A+B7FA,AxCwHA,A0C9HA,AHSA,AFMA,AHSA,AOrBA,AHSA,AHSA,A/B6FA,AgChGA,AjBmDA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,AIZA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;AxCyHA,Ae7CA,AFMA,AIZA,A+B7FA,AxCwHA,A0C9HA,AHSA,AIZA,ANkBA,AHSA,AOrBA,AHSA,AHSA,A/B6FA,AgChGA,AjBmDA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,AIZA,AT2BA,AENA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;AxCyHA,Ae7CA,AFMA,AIZA,A+B7FA,AxCwHA,A0C9HA,AHSA,AIZA,ANkBA,AHSA,AOrBA,AHSA,AHSA,A/B6FA,AgChGA,AjBmDA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,AIZA,APqBA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;AxCyHA,Ae7CA,AFMA,AIZA,A+B7FA,AxCwHA,A0C9HA,AHSA,AIZA,ANkBA,AHSA,AOrBA,AHSA,AHSA,A/B6FA,AgChGA,AjBmDA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,AIZA,APqBA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;AxCyHA,Ae7CA,AFMA,AIZA,A+B7FA,AxCwHA,A0C9HA,AHSA,AIZA,ANkBA,AHSA,AOrBA,AGTA,ANkBA,AHSA,A/B6FA,AgChGA,AjBmDA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,AIZA,APqBA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;AxCyHA,Ae7CA,AFMA,AIZA,A+B7FA,AxCwHA,A0C9HA,AHSA,AIZA,ANkBA,AHSA,AOrBA,AGTA,ANkBA,AHSA,A/B6FA,AgChGA,AjBmDA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,AIZA,APqBA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;AxCyHA,Ae7CA,AFMA,AIZA,A+B7FA,AxCwHA,A0C9HA,AHSA,AIZA,ANkBA,AHSA,AOrBA,AGTA,ANkBA,AHSA,A/B6FA,AgChGA,AjBmDA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,AIZA,APqBA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;AxCyHA,Ae7CA,AFMA,AIZA,A+B7FA,AxCwHA,A0C9HA,AHSA,AIZA,ANkBA,AHSA,AWjCA,AJYA,AGTA,ANkBA,AHSA,A/B6FA,AgChGA,AjBmDA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,AIZA,APqBA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;AxCyHA,Ae7CA,AFMA,AIZA,A+B7FA,AxCwHA,A0C9HA,AHSA,AIZA,ANkBA,AHSA,AWjCA,AJYA,AGTA,ANkBA,AHSA,ACHA,AjBmDA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,AHSA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;AxCyHA,Ae7CA,AFMA,AIZA,A+B7FA,AxCwHA,A0C9HA,AHSA,AIZA,ANkBA,AHSA,AWjCA,AJYA,AGTA,ANkBA,AHSA,ACHA,AjBmDA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,AHSA,ACHA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;AxCyHA,Ae7CA,AFMA,AIZA,A+B7FA,AxCwHA,A0C9HA,AHSA,AIZA,ANkBA,AHSA,AWjCA,AJYA,AGTA,ANkBA,AHSA,AWjCA,AV8BA,AjBmDA,APqBA,ACHA,AENA,AENA,AHSA,AavCA,AFMA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;AxCyHA,Ae7CA,AFMA,AIZA,A+B7FA,AxCwHA,A0C9HA,AHSA,AIZA,ANkBA,AHSA,AWjCA,AJYA,AGTA,ANkBA,AHSA,AWjCA,AV8BA,AjBmDA,APqBA,ACHA,AENA,AENA,AU9BA,AFMA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;AxCyHA,Ae7CA,AFMA,AIZA,A+B7FA,AxCwHA,A0C9HA,AHSA,AIZA,ANkBA,AHSA,AWjCA,AJYA,AGTA,ANkBA,AHSA,AWjCA,AV8BA,AjBmDA,APqBA,ACHA,AENA,AENA,AU9BA,AFMA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;AxCyHA,Ae7CA,AFMA,AIZA,A+B7FA,AxCwHA,A0C9HA,AHSA,AIZA,ANkBA,AHSA,AWjCA,AENA,ANkBA,AGTA,ANkBA,AHSA,AWjCA,AV8BA,AjBmDA,APqBA,ACHA,AENA,AENA,AU9BA,AFMA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;AxCyHA,Ae7CA,AFMA,AIZA,A+B7FA,AxCwHA,A0C9HA,AHSA,AIZA,ANkBA,AHSA,AWjCA,AENA,ANkBA,AGTA,ANkBA,AHSA,AWjCA,AV8BA,AjBmDA,APqBA,ACHA,AENA,AENA,AU9BA,AFMA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;AxCyHA,Ae7CA,AFMA,AIZA,A+B7FA,AxCwHA,A0C9HA,AHSA,AIZA,ANkBA,AHSA,AWjCA,AENA,ANkBA,AGTA,ANkBA,AHSA,AWjCA,AV8BA,AjBmDA,APqBA,ACHA,AENA,AENA,AU9BA,AFMA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;AxCyHA,Ae7CA,AFMA,AIZA,A+B7FA,AxCwHA,A0C9HA,AHSA,AIZA,ANkBA,AHSA,AWjCA,AENA,ANkBA,AGTA,ANkBA,AHSA,AWjCA,AENA,AZoCA,AjBmDA,APqBA,ACHA,AENA,AENA,AU9BA,AFMA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;AxCyHA,Ae7CA,AFMA,AIZA,A+B7FA,AxCwHA,A0C9HA,AHSA,AIZA,ANkBA,AHSA,AWjCA,AENA,ANkBA,AGTA,ANkBA,AHSA,AWjCA,AENA,AZoCA,AjBmDA,APqBA,ACHA,AENA,AENA,AU9BA,AFMA,ALeA,AQxBA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,ACHA,AyC3HA;AxCyHA,Ae7CA,AFMA,AIZA,A+B7FA,AxCwHA,A0C9HA,AHSA,AIZA,ANkBA,AHSA,AWjCA,AENA,ANkBA,AGTA,ANkBA,AHSA,AWjCA,AENA,AZoCA,AjBmDA,APqBA,ACHA,AENA,AENA,AU9BA,AFMA,AGTA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,A0C9HA;AxCyHA,Ae7CA,AFMA,AIZA,AwCxHA,AT2BA,AxCwHA,A0C9HA,AHSA,AIZA,ANkBA,AHSA,AWjCA,AENA,ANkBA,AGTA,ANkBA,AHSA,AWjCA,AENA,AZoCA,AjBmDA,APqBA,ACHA,AENA,AENA,AU9BA,AFMA,AGTA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA,A0C9HA;AxCyHA,Ae7CA,AFMA,AIZA,AwCxHA,AT2BA,AxCwHA,A0C9HA,AHSA,AIZA,ANkBA,AHSA,AWjCA,AENA,ANkBA,AGTA,ANkBA,AHSA,AWjCA,AENA,AZoCA,AjBmDA,APqBA,ACHA,AENA,AENA,AU9BA,AFMA,AGTA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA;AELA,Ae7CA,AFMA,AIZA,AwCxHA,AT2BA,AxCwHA,A0C9HA,AHSA,AIZA,ANkBA,AHSA,AWjCA,AENA,ANkBA,AGTA,ANkBA,AHSA,AWjCA,AENA,AZoCA,AjBmDA,APqBA,ACHA,AENA,AENA,AU9BA,AFMA,AGTA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA;AELA,Ae7CA,AFMA,AIZA,AwCxHA,ACHA,AV8BA,AxCwHA,A0C9HA,AHSA,AIZA,ANkBA,AHSA,AWjCA,AENA,ANkBA,AGTA,ANkBA,AHSA,AWjCA,AENA,AZoCA,AjBmDA,APqBA,ACHA,AENA,AENA,AU9BA,AFMA,AGTA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA;AELA,Ae7CA,AFMA,AIZA,AwCxHA,ACHA,AV8BA,AxCwHA,A0C9HA,AHSA,AIZA,ANkBA,AHSA,AWjCA,AENA,ANkBA,AGTA,ANkBA,AHSA,AWjCA,AENA,AZoCA,AjBmDA,APqBA,ACHA,AENA,AENA,AU9BA,AFMA,AGTA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA;AELA,Ae7CA,AFMA,AIZA,AwCxHA,ACHA,AV8BA,AxCwHA,A0C9HA,AHSA,AIZA,ANkBA,AHSA,AWjCA,AENA,ANkBA,AGTA,ANkBA,AHSA,AWjCA,AENA,AZoCA,AjBmDA,APqBA,ACHA,AENA,AENA,AU9BA,AFMA,AGTA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA;AELA,Ae7CA,AFMA,AIZA,A0C9HA,AFMA,ACHA,AV8BA,AxCwHA,A0C9HA,ACHA,ANkBA,AHSA,AWjCA,AENA,ANkBA,AGTA,ANkBA,AHSA,AWjCA,AENA,AZoCA,AjBmDA,APqBA,ACHA,AENA,AENA,AQxBA,AGTA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA;AELA,Ae7CA,AFMA,AIZA,A0C9HA,ADGA,AV8BA,AxCwHA,A0C9HA,ACHA,ANkBA,AHSA,AWjCA,AENA,ANkBA,AGTA,ANkBA,AHSA,AWjCA,AENA,AZoCA,AjBmDA,APqBA,ACHA,AENA,AENA,AQxBA,AGTA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA;AELA,Ae7CA,AFMA,AIZA,A0C9HA,AXiCA,AxCwHA,A0C9HA,ACHA,ANkBA,AHSA,AWjCA,AENA,ANkBA,AGTA,ANkBA,AHSA,AWjCA,AENA,AZoCA,AjBmDA,APqBA,ACHA,AENA,AENA,AQxBA,AGTA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA;AELA,Ae7CA,AFMA,AIZA,A0C9HA,ACHA,AZoCA,AxCwHA,A0C9HA,ACHA,ANkBA,AHSA,AWjCA,AENA,ANkBA,AGTA,ANkBA,AHSA,AWjCA,AENA,AZoCA,AjBmDA,APqBA,ACHA,AENA,AENA,AQxBA,AGTA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA;AELA,Ae7CA,AFMA,AIZA,A0C9HA,ACHA,AZoCA,AxCwHA,A0C9HA,ACHA,ANkBA,AHSA,AWjCA,AENA,ANkBA,AGTA,ANkBA,AHSA,AWjCA,AENA,AZoCA,AjBmDA,APqBA,ACHA,AENA,AENA,AQxBA,AGTA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA;AELA,Ae7CA,AFMA,AIZA,A2CjIA,AZoCA,AxCwHA,A0C9HA,ACHA,ANkBA,AHSA,AWjCA,AENA,ANkBA,AGTA,ANkBA,AHSA,AWjCA,AENA,AZoCA,AjBmDA,APqBA,ACHA,AENA,AENA,AQxBA,AGTA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA;AELA,Ae7CA,AFMA,AIZA,A4CpIA,ADGA,AZoCA,AxCwHA,A0C9HA,ACHA,ANkBA,AHSA,AWjCA,AENA,ANkBA,AGTA,ANkBA,AHSA,AWjCA,AENA,AZoCA,AjBmDA,APqBA,ACHA,AENA,AENA,AQxBA,AGTA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA;AELA,Ae7CA,AENA,A4CpIA,ADGA,AZoCA,AxCwHA,A0C9HA,ACHA,ANkBA,AHSA,AWjCA,AENA,ANkBA,AGTA,ANkBA,AHSA,AWjCA,AENA,AZoCA,AjBmDA,APqBA,ACHA,AENA,AENA,AQxBA,AGTA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA;AELA,Ae7CA,AENA,A4CpIA,AbuCA,AxCwHA,A0C9HA,ACHA,ANkBA,AQxBA,AENA,ANkBA,AGTA,ANkBA,AHSA,AWjCA,AENA,AZoCA,AjBmDA,APqBA,ACHA,AENA,AENA,AQxBA,AGTA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA;AELA,Ae7CA,AENA,A6CvIA,ADGA,AbuCA,AxCwHA,A0C9HA,ACHA,ANkBA,AQxBA,AENA,ANkBA,AGTA,ANkBA,AHSA,AWjCA,AENA,AZoCA,AjBmDA,APqBA,ACHA,AENA,AU9BA,AGTA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA;AELA,Ae7CA,AENA,A6CvIA,ADGA,AbuCA,AxCwHA,A0C9HA,ACHA,ANkBA,AQxBA,AENA,ANkBA,AGTA,ANkBA,AHSA,AWjCA,AENA,A7BuFA,APqBA,ACHA,AENA,AU9BA,AGTA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA;AELA,Ae7CA,AENA,A6CvIA,ADGA,AbuCA,AxCwHA,A0C9HA,ACHA,ANkBA,AQxBA,AENA,ANkBA,AGTA,ANkBA,AHSA,AWjCA,AENA,A7BuFA,APqBA,AGTA,AU9BA,AGTA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA;AELA,Ae7CA,AENA,A6CvIA,ADGA,AbuCA,AxCwHA,A0C9HA,ACHA,ANkBA,AQxBA,AENA,ANkBA,AGTA,ANkBA,AHSA,AWjCA,AENA,A7BuFA,APqBA,AGTA,AU9BA,AGTA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,AyD3KA,AjEmMA;AELA,Ae7CA,AENA,A6CvIA,ADGA,AbuCA,AxCwHA,A0C9HA,ACHA,ANkBA,AQxBA,AENA,ANkBA,AGTA,ANkBA,AHSA,AWjCA,AENA,A7BuFA,APqBA,AGTA,AU9BA,AGTA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,AyD3KA,AjEmMA;AELA,Ae7CA,AENA,A6CvIA,ADGA,AbuCA,AxCwHA,A0C9HA,ACHA,ANkBA,AQxBA,AENA,ANkBA,AGTA,ANkBA,AHSA,AWjCA,AENA,A7BuFA,APqBA,AGTA,AU9BA,AGTA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,AyD3KA,AjEmMA;AELA,Ae7CA,AENA,A6CvIA,AENA,AHSA,AbuCA,AxCwHA,A0C9HA,ACHA,ANkBA,AQxBA,AENA,ANkBA,AGTA,ANkBA,AHSA,AWjCA,AENA,A7BuFA,APqBA,AGTA,AU9BA,AGTA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,AyD3KA,AjEmMA;AELA,Ae7CA,AENA,A6CvIA,AENA,AHSA,AbuCA,AxCwHA,A0C9HA,ACHA,ANkBA,AQxBA,AENA,ANkBA,AGTA,ANkBA,AHSA,AWjCA,AENA,A7BuFA,APqBA,AGTA,AU9BA,AGTA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,AyD3KA,AjEmMA;AELA,Ae7CA,AENA,A6CvIA,AENA,AHSA,AbuCA,AxCwHA,A0C9HA,ACHA,ANkBA,AQxBA,AENA,ANkBA,AGTA,ANkBA,AHSA,AWjCA,AENA,A7BuFA,APqBA,AGTA,AU9BA,AGTA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA;AELA,Ae7CA,AENA,A6CvIA,AENA,ACHA,AJYA,AbuCA,AxCwHA,A0C9HA,ACHA,AENA,AENA,ANkBA,AGTA,ANkBA,AHSA,AWjCA,AENA,A7BuFA,APqBA,AGTA,AU9BA,AGTA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA;AELA,Ae7CA,AENA,A6CvIA,AENA,ACHA,AJYA,AbuCA,AxCwHA,A0C9HA,ACHA,AENA,AENA,ANkBA,AGTA,ANkBA,AHSA,AWjCA,AENA,ApC4GA,AGTA,AU9BA,AGTA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA;AELA,Ae7CA,AENA,A6CvIA,AENA,ACHA,AJYA,AbuCA,AxCwHA,A0C9HA,ACHA,AENA,AENA,ANkBA,AGTA,ANkBA,AHSA,AWjCA,AENA,ApC4GA,AGTA,AU9BA,AGTA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA;AELA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ALeA,AbuCA,AxCwHA,A0C9HA,ACHA,AENA,AENA,ANkBA,AGTA,ANkBA,AHSA,AWjCA,AENA,ApC4GA,AGTA,AU9BA,AGTA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA;AELA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ALeA,AbuCA,AxCwHA,A0C9HA,ACHA,AENA,AENA,ANkBA,AGTA,ANkBA,AHSA,AavCA,ApC4GA,AGTA,AU9BA,AGTA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA;AELA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ALeA,AbuCA,AxCwHA,A0C9HA,ACHA,AENA,AENA,ANkBA,AGTA,ANkBA,AHSA,AavCA,ApC4GA,AGTA,AU9BA,AGTA,ACHA,ANkBA,AGTA,AV8BA,AlBsDA,ARwBA;AELA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,ANkBA,AbuCA,AxCwHA,A0C9HA,ACHA,AENA,AENA,ANkBA,AGTA,ANkBA,AHSA,AavCA,ApC4GA,AGTA,AU9BA,AIZA,ANkBA,AGTA,A5BoFA,ARwBA;AELA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,ANkBA,AbuCA,AxCwHA,A0C9HA,ACHA,AENA,AENA,ANkBA,AGTA,ANkBA,AHSA,AavCA,ApC4GA,AGTA,AU9BA,AIZA,ANkBA,AGTA,A5BoFA,ARwBA;AELA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,ANkBA,AbuCA,AxCwHA,A0C9HA,ACHA,AENA,AENA,ANkBA,AGTA,ANkBA,AHSA,AavCA,ApC4GA,AGTA,AU9BA,AIZA,ANkBA,AGTA,A5BoFA,ARwBA;AELA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,ACHA,APqBA,AbuCA,AxCwHA,A0C9HA,ACHA,AENA,AENA,ANkBA,AGTA,ANkBA,AHSA,AavCA,ApC4GA,AGTA,AU9BA,AIZA,ANkBA,AGTA,A5BoFA,ARwBA;AELA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,ACHA,APqBA,AbuCA,AxCwHA,A0C9HA,ACHA,AENA,AENA,ANkBA,AGTA,ANkBA,AHSA,AavCA,ApC4GA,AGTA,AU9BA,AIZA,ANkBA,AGTA,A5BoFA,ARwBA;AELA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,ACHA,APqBA,AbuCA,AxCwHA,A0C9HA,ACHA,AENA,AENA,ANkBA,AGTA,ANkBA,AU9BA,ApC4GA,AGTA,AU9BA,AIZA,ANkBA,AGTA,A5BoFA,ARwBA;AELA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ARwBA,AbuCA,AxCwHA,A2CjIA,AENA,AENA,ANkBA,AGTA,ANkBA,AU9BA,ApC4GA,AGTA,AU9BA,AIZA,ANkBA,AGTA,A5BoFA,ARwBA;AELA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ARwBA,AbuCA,AxCwHA,A2CjIA,AENA,AENA,ANkBA,AGTA,ANkBA,AU9BA,ApC4GA,AGTA,AU9BA,AIZA,ANkBA,AGTA,A5BoFA,ARwBA;AELA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ARwBA,AbuCA,AxCwHA,A2CjIA,AENA,AENA,ANkBA,AGTA,ANkBA,AU9BA,ApC4GA,AGTA,AU9BA,AIZA,ANkBA,AGTA,A5BoFA,ARwBA;AELA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,ARwBA,AbuCA,AxCwHA,A2CjIA,AENA,AENA,ANkBA,AGTA,ANkBA,AU9BA,ApC4GA,AGTA,AU9BA,AIZA,ANkBA,AGTA,A5BoFA,ARwBA;AELA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,ARwBA,AbuCA,AxCwHA,A2CjIA,AENA,AENA,ANkBA,AGTA,ANkBA,AU9BA,ApC4GA,AGTA,AU9BA,AIZA,ANkBA,AGTA,A5BoFA,ARwBA;AELA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,ARwBA,ArD+JA,A2CjIA,AENA,AENA,ANkBA,AGTA,ANkBA,AU9BA,ApC4GA,AGTA,AU9BA,AIZA,ANkBA,AGTA,A5BoFA,ARwBA;AELA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,ARwBA,ArD+JA,A2CjIA,AENA,AENA,ANkBA,AGTA,ANkBA,AU9BA,ApC4GA,AGTA,AU9BA,AIZA,ANkBA,AGTA,A5BoFA,ARwBA;AELA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,ARwBA,ArD+JA,A2CjIA,AENA,AENA,ANkBA,AGTA,ANkBA,AU9BA,ApC4GA,AGTA,AU9BA,AIZA,ANkBA,AGTA,A5BoFA,ARwBA;AELA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,ARwBA,ArD+JA,A2CjIA,AENA,AENA,ANkBA,AGTA,ANkBA,AU9BA,ApC4GA,AGTA,AU9BA,AIZA,ANkBA,AGTA,A5BoFA,ARwBA;AELA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,ARwBA,ArD+JA,A2CjIA,AENA,AENA,ANkBA,AGTA,ANkBA,AU9BA,ApC4GA,AGTA,AU9BA,AIZA,ANkBA,AGTA,A5BoFA,AkEtMA,A1E8NA;AELA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,ARwBA,ArD+JA,A2CjIA,AENA,AENA,ANkBA,AGTA,ANkBA,AU9BA,ApC4GA,AGTA,AU9BA,AIZA,ANkBA,AGTA,A5BoFA,AkEtMA,A1E8NA;AELA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,ARwBA,ArD+JA,A2CjIA,AENA,AENA,ANkBA,AGTA,ANkBA,AU9BA,ApC4GA,AGTA,AU9BA,AIZA,ANkBA,AGTA,A5BoFA,AkEtMA,A1E8NA;AELA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AIZA,AZoCA,ArD+JA,A2CjIA,AENA,AENA,ANkBA,AGTA,ANkBA,AU9BA,ApC4GA,AGTA,AU9BA,AIZA,ANkBA,AzB2EA,AkEtMA,A1E8NA;AELA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AIZA,AZoCA,ArD+JA,A2CjIA,AENA,AENA,ANkBA,AGTA,ANkBA,AU9BA,ApC4GA,AGTA,AU9BA,AIZA,ANkBA,AzB2EA,AkEtMA,A1E8NA;AELA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AIZA,AZoCA,ArD+JA,A2CjIA,AENA,AENA,ANkBA,AGTA,ANkBA,AU9BA,ApC4GA,AGTA,AU9BA,AIZA,ANkBA,AzB2EA,AkEtMA,A1E8NA;AELA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AKfA,ADGA,AZoCA,ArD+JA,A2CjIA,AENA,AJYA,AGTA,ANkBA,AU9BA,ApC4GA,AGTA,AU9BA,AIZA,ANkBA,AzB2EA,AkEtMA,A1E8NA;AELA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AKfA,ADGA,AZoCA,ArD+JA,A2CjIA,AENA,AJYA,AGTA,ANkBA,AU9BA,ApC4GA,AGTA,Ac1CA,ANkBA,AzB2EA,AkEtMA,A1E8NA;AELA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AKfA,ADGA,AZoCA,ArD+JA,A2CjIA,AENA,AJYA,AGTA,ANkBA,AU9BA,ApC4GA,AGTA,Ac1CA,ANkBA,AzB2EA,AkEtMA,A1E8NA;AELA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AMlBA,ADGA,ADGA,AZoCA,ArD+JA,A2CjIA,AENA,AJYA,AGTA,ANkBA,AU9BA,ApC4GA,AGTA,Ac1CA,ANkBA,AzB2EA,AkEtMA,A1E8NA;AELA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AMlBA,ADGA,ADGA,AZoCA,ArD+JA,A2CjIA,AENA,AJYA,AGTA,ANkBA,AU9BA,ApC4GA,AGTA,Ac1CA,ANkBA,AzB2EA,AkEtMA;AxEyNA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AMlBA,ADGA,ADGA,AZoCA,ArD+JA,A2CjIA,AENA,AJYA,AGTA,ANkBA,AU9BA,ApC4GA,AGTA,Ac1CA,ANkBA,AzB2EA,AkEtMA;AxEyNA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AENA,AJYA,AGTA,ANkBA,AU9BA,ApC4GA,AGTA,Ac1CA,ANkBA,AzB2EA,AkEtMA;AxEyNA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AENA,AJYA,AGTA,ANkBA,AU9BA,ApC4GA,AGTA,Ac1CA,ANkBA,AzB2EA,AkEtMA;AxEyNA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AENA,AJYA,AGTA,ANkBA,AU9BA,ApC4GA,AGTA,Ac1CA,ANkBA,AzB2EA,AkEtMA;AxEyNA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AENA,AJYA,AGTA,ANkBA,AU9BA,ApC4GA,AGTA,Ac1CA,ANkBA,AzB2EA,AuErNA,ALeA;AxEyNA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,ANkBA,AU9BA,ApC4GA,AGTA,Ac1CA,ANkBA,AzB2EA,AuErNA,ALeA;AxEyNA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,ANkBA,AU9BA,ApC4GA,AGTA,Ac1CA,ANkBA,AzB2EA,AuErNA,ALeA;AxEyNA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,ANkBA,AU9BA,ApC4GA,AGTA,Ac1CA,ANkBA,AzB2EA,AuErNA,ACHA,ANkBA;AxEyNA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,ANkBA,AU9BA,ApC4GA,AGTA,Ac1CA,ANkBA,AzB2EA,AuErNA,ACHA,ANkBA;AxEyNA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,ANkBA,AU9BA,ApC4GA,AGTA,Ac1CA,ANkBA,AzB2EA,AuErNA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,ANkBA,AU9BA,ApC4GA,AGTA,Ac1CA,ANkBA,AzB2EA,AuErNA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,ANkBA,AU9BA,ApC4GA,AGTA,Ac1CA,ANkBA,AzB2EA,AuErNA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,ANkBA,AU9BA,ApC4GA,AGTA,Ac1CA,ANkBA,AzB2EA,AuErNA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,ANkBA,AU9BA,AwBxEA,A5DoLA,AGTA,Ac1CA,ANkBA,AzB2EA,AuErNA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,AIZA,AwBxEA,A5DoLA,AGTA,Ac1CA,ANkBA,AzB2EA,AuErNA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,AIZA,AwBxEA,A5DoLA,AGTA,Ac1CA,ANkBA,AzB2EA,AuErNA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,AIZA,AyB3EA,ADGA,A5DoLA,AGTA,Ac1CA,ANkBA,AzB2EA,AuErNA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,AIZA,AyB3EA,ADGA,A5DoLA,AGTA,Ac1CA,ANkBA,AzB2EA,AuErNA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,AIZA,AyB3EA,ADGA,A5DoLA,AGTA,Ac1CA,ANkBA,AzB2EA,AuErNA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,AIZA,AyB3EA,ACHA,AFMA,A5DoLA,AGTA,Ac1CA,ANkBA,AzB2EA,AuErNA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,AIZA,AyB3EA,ACHA,AFMA,A5DoLA,AGTA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,AIZA,AyB3EA,ACHA,AFMA,A5DoLA,AGTA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,A/E6OA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,AIZA,AyB3EA,ACHA,AFMA,A5DoLA,AGTA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,A/E6OA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,AIZA,AyB3EA,ACHA,AFMA,A5DoLA,AGTA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,A/E6OA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,AIZA,AyB3EA,ACHA,AFMA,A5DoLA,AGTA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AKfA,ApF4PA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,AIZA,AyB3EA,ACHA,AFMA,A5DoLA,AGTA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AKfA,ApF4PA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,AIZA,AyB3EA,ACHA,AFMA,A5DoLA,AGTA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AKfA,ApF4PA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,AIZA,AyB3EA,ACHA,AFMA,A5DoLA,AGTA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AKfA,ACHA,ArF+PA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,AIZA,AyB3EA,ACHA,AFMA,A5DoLA,AGTA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AKfA,ACHA,ArF+PA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,A6BvFA,ACHA,AFMA,A5DoLA,AGTA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AKfA,ACHA,ArF+PA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,A6BvFA,ACHA,AFMA,A5DoLA,AGTA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,ACHA,AIZA,AHSA,AENA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,A6BvFA,ACHA,AFMA,A5DoLA,AGTA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,AKfA,AHSA,AENA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,A6BvFA,ACHA,AFMA,A5DoLA,AGTA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,AKfA,AHSA,AENA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,A6BvFA,ACHA,AFMA,A5DoLA,AGTA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,AKfA,ADGA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,A6BvFA,ACHA,AFMA,A5DoLA,AGTA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,AKfA,ADGA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,A6BvFA,ACHA,AFMA,A5DoLA,AGTA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,AKfA,ADGA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,A6BvFA,ACHA,AFMA,A5DoLA,AGTA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,AKfA,ADGA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,A6BvFA,ACHA,AFMA,A5DoLA,AGTA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,AKfA,ADGA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,A6BvFA,ACHA,AFMA,A5DoLA,AGTA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,A6BvFA,ACHA,AFMA,A5DoLA,AGTA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,A6BvFA,ACHA,AFMA,A5DoLA,AGTA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,A6BvFA,ACHA,AFMA,A5DoLA,AGTA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AENA,A6CvIA,AENA,ACHA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,A6BvFA,ACHA,AFMA,A5DoLA,AGTA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AENA,A6CvIA,AGTA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,A6BvFA,ACHA,AFMA,A5DoLA,AGTA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AENA,A6CvIA,AGTA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A2CjIA,AFMA,AGTA,A6BvFA,ACHA,AFMA,A5DoLA,AGTA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AENA,A6CvIA,AGTA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,AyC3HA,AGTA,A6BvFA,ACHA,AFMA,A5DoLA,AGTA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AENA,A6CvIA,AGTA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,AyC3HA,AGTA,A6BvFA,ACHA,AFMA,A5DoLA,AGTA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AENA,A6CvIA,AGTA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,AyC3HA,AGTA,A6BvFA,ACHA,AFMA,A5DoLA,AGTA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AENA,A6CvIA,AGTA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,AyC3HA,AGTA,A6BvFA,ACHA,AFMA,A5DoLA,AGTA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,A+C7IA,AGTA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,AyC3HA,AGTA,A6BvFA,ACHA,AFMA,A5DoLA,AGTA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,A+C7IA,AGTA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,AyC3HA,AGTA,A6BvFA,ACHA,AFMA,A5DoLA,AGTA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,A+C7IA,AGTA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,AyC3HA,AGTA,A6BvFA,ACHA,AFMA,A5DoLA,AGTA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,A+C7IA,AGTA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,AyC3HA,AGTA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,A+C7IA,AGTA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,AyC3HA,AGTA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,A+C7IA,AGTA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,AyC3HA,AGTA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,A+C7IA,AGTA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,AyC3HA,AGTA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,A+C7IA,AGTA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,AyC3HA,AGTA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,A+C7IA,AGTA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,AyC3HA,AGTA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,A+C7IA,AGTA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,AyC3HA,AGTA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,A+C7IA,AGTA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,AyC3HA,AGTA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,A+C7IA,AGTA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,AyC3HA,AGTA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,A+C7IA,AGTA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,AyC3HA,AGTA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,A+C7IA,AGTA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,AyC3HA,AGTA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,A+C7IA,AGTA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,AyC3HA,AGTA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AkDtJA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,AyC3HA,AGTA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AkDtJA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,AyC3HA,AGTA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AkDtJA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,AyC3HA,AGTA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AkDtJA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,AyC3HA,AGTA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AkDtJA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,AyC3HA,AGTA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AkDtJA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,AyC3HA,AGTA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AkDtJA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,AyC3HA,AGTA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AkDtJA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,AyC3HA,AGTA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AkDtJA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,AyC3HA,AGTA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AkDtJA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,AyC3HA,AGTA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AkDtJA,ACHA,AIZA,ADGA,AMlBA,ADGA,AENA,AHSA,AZoCA,ArD+JA,AyC3HA,AGTA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,ANkBA,A8C1IA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AkDtJA,ACHA,AIZA,AKfA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A4CpIA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AkDtJA,ACHA,AIZA,AKfA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A4CpIA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AkDtJA,ACHA,AIZA,AKfA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A4CpIA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AkDtJA,ACHA,AIZA,AKfA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A4CpIA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AkDtJA,ACHA,AIZA,AKfA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A4CpIA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AkDtJA,ACHA,AIZA,AKfA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A4CpIA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AkDtJA,ACHA,AIZA,AKfA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A4CpIA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AkDtJA,ACHA,AIZA,AKfA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A4CpIA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AkDtJA,ACHA,AIZA,AKfA,ADGA,AENA,AHSA,AZoCA,ArD+JA,A4CpIA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AkDtJA,ACHA,AIZA,AKfA,ACHA,AHSA,AZoCA,ArD+JA,A4CpIA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AkDtJA,ACHA,AIZA,AKfA,ACHA,AHSA,AZoCA,ArD+JA,A4CpIA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AWhCA,AJYA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AkDtJA,ACHA,AIZA,AKfA,ACHA,AHSA,AZoCA,ArD+JA,A4CpIA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AkDtJA,ACHA,AIZA,AKfA,ACHA,AHSA,AZoCA,ArD+JA,A4CpIA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AkDtJA,ACHA,AIZA,AKfA,ACHA,AHSA,AZoCA,ArD+JA,A4CpIA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AkDtJA,ACHA,AIZA,AKfA,ACHA,AHSA,AZoCA,ArD+JA,A4CpIA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AkDtJA,ACHA,AIZA,AKfA,ACHA,AHSA,AZoCA,ArD+JA,A4CpIA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AkDtJA,ACHA,AIZA,AKfA,ACHA,AHSA,AZoCA,ArD+JA,A4CpIA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AkDtJA,ACHA,AIZA,AKfA,ACHA,AHSA,AZoCA,ArD+JA,A4CpIA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AkDtJA,ACHA,AIZA,AKfA,ACHA,AHSA,AjEmMA,A4CpIA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AkDtJA,ACHA,AIZA,AKfA,ACHA,AHSA,AjEmMA,A4CpIA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AFMA,ACHA,ArF+PA,Ae7CA,AkDtJA,ACHA,AIZA,AKfA,ACHA,AHSA,AjEmMA,A4CpIA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,ADGA,ArF+PA,Ae7CA,AkDtJA,ACHA,AIZA,AKfA,ACHA,AHSA,AjEmMA,A4CpIA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,ADGA,ArF+PA,Ae7CA,AkDtJA,ACHA,AIZA,AKfA,ACHA,AHSA,AjEmMA,A4CpIA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,ADGA,ArF+PA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,A4CpIA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,ADGA,ArF+PA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,A4CpIA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,ADGA,ArF+PA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,A4CpIA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,ADGA,ArF+PA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,A4CpIA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,ADGA,ArF+PA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,A4CpIA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,ADGA,ArF+PA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,A4CpIA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,ADGA,ArF+PA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,A4CpIA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,ADGA,ArF+PA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,A4CpIA,A6BvFA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,ADGA,ArF+PA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,ADGA,ArF+PA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,ADGA,ArF+PA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,ADGA,ArF+PA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,ADGA,ArF+PA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,ADGA,ArF+PA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AmDzJA,AIZA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AuDrKA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AuDrKA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AuDrKA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AuDrKA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AuDrKA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AuDrKA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,AFMA,AzD2KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AuDrKA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,A3DiLA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AuDrKA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,A3DiLA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AuDrKA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,ACHA,A3DiLA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AuDrKA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,A1D8KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AuDrKA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,A1D8KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AuDrKA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,A1D8KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AuDrKA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,A1D8KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AuDrKA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,A1D8KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AuDrKA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,A1D8KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AuDrKA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,A1D8KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AuDrKA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,A1D8KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AuDrKA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,A1D8KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AuDrKA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,A1D8KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AuDrKA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,A1D8KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AuDrKA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,A1D8KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AuDrKA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,A1D8KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AuDrKA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,A1D8KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AuDrKA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,A1D8KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AuDrKA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,A1D8KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AuDrKA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,A1D8KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AuDrKA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,A1D8KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AuDrKA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,A1D8KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AuDrKA,AKfA,ACHA,AHSA,AjEmMA,AyE3NA,A1D8KA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AuDrKA,AKfA,ACHA,AHSA,AjEmMA,Ae7CA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AuDrKA,AKfA,ACHA,AHSA,AjEmMA,Ae7CA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AuDrKA,AKfA,ACHA,AHSA,AjEmMA,Ae7CA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,Ae7CA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,AOrBA,AtFkQA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,Ae7CA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,Ae7CA,Ac1CA,AwCxHA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,Ae7CA,AsDlKA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,Ae7CA,AsDlKA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,Ae7CA,AsDlKA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,Ae7CA,AsDlKA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,Ae7CA,AsDlKA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,Ae7CA,AsDlKA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,Ae7CA,AuDrKA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,AsElNA,AKfA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AqE/MA,ACHA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AOpBA,A/E6OA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AxEyNA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AxEyNA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AxEyNA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AxEyNA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AxEyNA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AxEyNA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AxEyNA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AxEyNA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AxEyNA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AxEyNA,A2EjOA,AFMA,AjEmMA,AsElNA,ANkBA;AxEyNA,AyE3NA,AjEmMA,AsElNA,ANkBA;AxEyNA,AyE3NA,AjEmMA,AsElNA,ANkBA;AxEyNA,AyE3NA,AjEmMA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AsElNA,ANkBA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA,AgEhMA;AxEyNA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\r\n\r\n/**\r\n * Default, without interactins\r\n */\r\nvar F2 = require('./core');\r\n\r\nrequire('./geom/');\r\n\r\nrequire('./geom/adjust/');\r\n\r\nrequire('./coord/polar'); // polar coordinate\r\n\r\n\r\nrequire('./component/axis/circle'); // the axis for polar coordinate\r\n\r\n\r\nrequire('./scale/time-cat'); // timeCat scale\r\n\r\n\r\nrequire('./component/guide/arc');\r\n\r\nrequire('./component/guide/html');\r\n\r\nrequire('./component/guide/line');\r\n\r\nrequire('./component/guide/rect');\r\n\r\nrequire('./component/guide/text');\r\n\r\nrequire('./component/guide/tag');\r\n\r\nrequire('./component/guide/point');\r\n\r\nvar Tooltip = require('./plugin/tooltip');\r\n\r\nvar Guide = require('./plugin/guide');\r\n\r\nvar Legend = require('./plugin/legend');\r\n\r\nvar Animation = require('./animation/detail');\r\n\r\nF2.Animate = require('./animation/animate'); // register plugins\r\n\r\nF2.Chart.plugins.register([Tooltip, Legend, Guide, Animation]);\r\nmodule.exports = F2;","\r\n\r\nvar Core = {};\r\n\r\nvar Global = require('./global');\r\n\r\nCore.Global = Global;\r\nCore.version = Global.version;\r\nCore.Chart = require('./chart/chart');\r\nCore.Shape = require('./geom/shape/shape');\r\nCore.G = require('./graphic/index');\r\nCore.Util = require('./util/common'); // Core.track = function(enable) {\r\n//   Global.trackable = enable;\r\n// };\r\n// require('./track');\r\n// 2018-12-27 关闭打点\r\n\r\nCore.track = function () {\r\n  return null;\r\n};\r\n\r\nmodule.exports = Core;","\r\n\r\nvar Theme = require('./theme');\r\n\r\nvar Util = require('./util/common');\r\n\r\nvar Global = {\r\n  version: '3.5.0',\r\n  scales: {},\r\n  widthRatio: {\r\n    column: 1 / 2,\r\n    rose: 0.999999,\r\n    multiplePie: 3 / 4\r\n  },\r\n  lineDash: [4, 4]\r\n};\r\n\r\nGlobal.setTheme = function (theme) {\r\n  Util.deepMix(this, theme);\r\n};\r\n\r\nGlobal.setTheme(Theme);\r\nmodule.exports = Global;","\r\n\r\n/**\r\n * @fileOverview default theme\r\n * @author dxq613@gail.com\r\n */\r\nvar Util = require('./util/common');\r\n\r\nvar color1 = '#E8E8E8'; // color of axis-line and axis-grid\r\n\r\nvar color2 = '#808080'; // color of axis label\r\n\r\nvar defaultAxis = {\r\n  label: {\r\n    fill: color2,\r\n    fontSize: 10\r\n  },\r\n  line: {\r\n    stroke: color1,\r\n    lineWidth: 1\r\n  },\r\n  grid: {\r\n    type: 'line',\r\n    stroke: color1,\r\n    lineWidth: 1,\r\n    lineDash: [2]\r\n  },\r\n  tickLine: null,\r\n  labelOffset: 7.5\r\n};\r\nvar Theme = {\r\n  fontFamily: '\"Helvetica Neue\", \"San Francisco\", Helvetica, Tahoma, Arial, \"PingFang SC\", \"Hiragino Sans GB\", \"Heiti SC\", \"Microsoft YaHei\", sans-serif',\r\n  defaultColor: '#1890FF',\r\n  pixelRatio: 1,\r\n  padding: 'auto',\r\n  appendPadding: 15,\r\n  colors: ['#1890FF', '#2FC25B', '#FACC14', '#223273', '#8543E0', '#13C2C2', '#3436C7', '#F04864'],\r\n  shapes: {\r\n    line: ['line', 'dash'],\r\n    point: ['circle', 'hollowCircle']\r\n  },\r\n  sizes: [4, 10],\r\n  axis: {\r\n    common: defaultAxis,\r\n    // common axis configuration\r\n    bottom: Util.mix({}, defaultAxis, {\r\n      grid: null\r\n    }),\r\n    left: Util.mix({}, defaultAxis, {\r\n      line: null\r\n    }),\r\n    right: Util.mix({}, defaultAxis, {\r\n      line: null\r\n    }),\r\n    circle: Util.mix({}, defaultAxis, {\r\n      line: null\r\n    }),\r\n    radius: Util.mix({}, defaultAxis, {\r\n      labelOffset: 4\r\n    })\r\n  },\r\n  shape: {\r\n    line: {\r\n      lineWidth: 2,\r\n      lineJoin: 'round',\r\n      lineCap: 'round'\r\n    },\r\n    point: {\r\n      lineWidth: 0,\r\n      size: 3\r\n    },\r\n    area: {\r\n      fillOpacity: 0.1\r\n    }\r\n  },\r\n  _defaultAxis: defaultAxis\r\n};\r\nmodule.exports = Theme;","\r\n\r\n/**\r\n * @fileOverview Utility for F2\r\n * @author dxq613 @gmail.com\r\n * @author sima.zhang1990@gmail.com\r\n */\r\nvar DomUtil = require('./dom');\r\n\r\nvar Util = {\r\n  upperFirst: require('@antv/util/lib/string/upper-first'),\r\n  lowerFirst: require('@antv/util/lib/string/lower-first'),\r\n  isString: require('@antv/util/lib/type/is-string'),\r\n  isNumber: require('@antv/util/lib/type/is-number'),\r\n  isBoolean: require('@antv/util/lib/type/is-boolean'),\r\n  isFunction: require('@antv/util/lib/type/is-function'),\r\n  isDate: require('@antv/util/lib/type/is-date'),\r\n  isArray: require('@antv/util/lib/type/is-array'),\r\n  isNil: require('@antv/util/lib/type/is-nil'),\r\n  isObject: require('@antv/util/lib/type/is-object'),\r\n  isPlainObject: require('@antv/util/lib/type/is-plain-object'),\r\n  deepMix: require('@antv/util/lib/deep-mix'),\r\n  mix: require('@antv/util/lib/mix'),\r\n  each: require('@antv/util/lib/each'),\r\n  uniq: require('@antv/util/lib/array/uniq'),\r\n  isObjectValueEqual: function isObjectValueEqual(a, b) {\r\n    // for vue.js\r\n    a = Object.assign({}, a);\r\n    b = Object.assign({}, b);\r\n    var aProps = Object.getOwnPropertyNames(a);\r\n    var bProps = Object.getOwnPropertyNames(b);\r\n\r\n    if (aProps.length !== bProps.length) {\r\n      return false;\r\n    }\r\n\r\n    for (var i = 0, len = aProps.length; i < len; i++) {\r\n      var propName = aProps[i];\r\n\r\n      if (a[propName] !== b[propName]) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  },\r\n  wrapBehavior: function wrapBehavior(obj, action) {\r\n    if (obj['_wrap_' + action]) {\r\n      return obj['_wrap_' + action];\r\n    }\r\n\r\n    var method = function method(e) {\r\n      obj[action](e);\r\n    };\r\n\r\n    obj['_wrap_' + action] = method;\r\n    return method;\r\n  },\r\n  getWrapBehavior: function getWrapBehavior(obj, action) {\r\n    return obj['_wrap_' + action];\r\n  },\r\n  parsePadding: function parsePadding(padding) {\r\n    var top;\r\n    var right;\r\n    var bottom;\r\n    var left;\r\n\r\n    if (Util.isNumber(padding) || Util.isString(padding)) {\r\n      top = bottom = left = right = padding;\r\n    } else if (Util.isArray(padding)) {\r\n      top = padding[0];\r\n      right = !Util.isNil(padding[1]) ? padding[1] : padding[0];\r\n      bottom = !Util.isNil(padding[2]) ? padding[2] : padding[0];\r\n      left = !Util.isNil(padding[3]) ? padding[3] : right;\r\n    }\r\n\r\n    return [top, right, bottom, left];\r\n  },\r\n  directionEnabled: function directionEnabled(mode, dir) {\r\n    if (mode === undefined) {\r\n      return true;\r\n    } else if (typeof mode === 'string') {\r\n      return mode.indexOf(dir) !== -1;\r\n    }\r\n\r\n    return false;\r\n  }\r\n};\r\nUtil.Array = {\r\n  merge: function merge(dataArray) {\r\n    var rst = [];\r\n\r\n    for (var i = 0, len = dataArray.length; i < len; i++) {\r\n      rst = rst.concat(dataArray[i]);\r\n    }\r\n\r\n    return rst;\r\n  },\r\n  values: function values(data, name) {\r\n    var rst = [];\r\n    var tmpMap = {};\r\n\r\n    for (var i = 0, len = data.length; i < len; i++) {\r\n      var obj = data[i];\r\n      var value = obj[name];\r\n\r\n      if (!Util.isNil(value)) {\r\n        if (!Util.isArray(value)) {\r\n          if (!tmpMap[value]) {\r\n            rst.push(value);\r\n            tmpMap[value] = true;\r\n          }\r\n        } else {\r\n          Util.each(value, function (val) {\r\n            if (!tmpMap[val]) {\r\n              rst.push(val);\r\n              tmpMap[val] = true;\r\n            }\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    return rst;\r\n  },\r\n  firstValue: function firstValue(data, name) {\r\n    var rst = null;\r\n\r\n    for (var i = 0, len = data.length; i < len; i++) {\r\n      var obj = data[i];\r\n      var value = obj[name];\r\n\r\n      if (!Util.isNil(value)) {\r\n        if (Util.isArray(value)) {\r\n          rst = value[0];\r\n        } else {\r\n          rst = value;\r\n        }\r\n\r\n        break;\r\n      }\r\n    }\r\n\r\n    return rst;\r\n  },\r\n  group: function group(data, fields, appendConditions) {\r\n    if (appendConditions === void 0) {\r\n      appendConditions = {};\r\n    }\r\n\r\n    if (!fields) {\r\n      return [data];\r\n    }\r\n\r\n    var groups = Util.Array.groupToMap(data, fields);\r\n    var array = [];\r\n\r\n    if (fields.length === 1 && appendConditions[fields[0]]) {\r\n      var values = appendConditions[fields[0]];\r\n      Util.each(values, function (value) {\r\n        value = '_' + value;\r\n        array.push(groups[value]);\r\n      });\r\n    } else {\r\n      for (var i in groups) {\r\n        array.push(groups[i]);\r\n      }\r\n    }\r\n\r\n    return array;\r\n  },\r\n  groupToMap: function groupToMap(data, fields) {\r\n    if (!fields) {\r\n      return {\r\n        0: data\r\n      };\r\n    }\r\n\r\n    var callback = function callback(row) {\r\n      var unique = '_';\r\n\r\n      for (var i = 0, l = fields.length; i < l; i++) {\r\n        unique += row[fields[i]] && row[fields[i]].toString();\r\n      }\r\n\r\n      return unique;\r\n    };\r\n\r\n    var groups = {};\r\n\r\n    for (var i = 0, len = data.length; i < len; i++) {\r\n      var row = data[i];\r\n      var key = callback(row);\r\n\r\n      if (groups[key]) {\r\n        groups[key].push(row);\r\n      } else {\r\n        groups[key] = [row];\r\n      }\r\n    }\r\n\r\n    return groups;\r\n  },\r\n  remove: function remove(arr, obj) {\r\n    if (!arr) {\r\n      return;\r\n    }\r\n\r\n    var index = arr.indexOf(obj);\r\n\r\n    if (index !== -1) {\r\n      arr.splice(index, 1);\r\n    }\r\n  },\r\n  getRange: function getRange(values) {\r\n    if (!values.length) {\r\n      return {\r\n        min: 0,\r\n        max: 0\r\n      };\r\n    }\r\n\r\n    var max = Math.max.apply(null, values);\r\n    var min = Math.min.apply(null, values);\r\n    return {\r\n      min: min,\r\n      max: max\r\n    };\r\n  }\r\n};\r\nUtil.mix(Util, DomUtil);\r\nmodule.exports = Util;","\r\n\r\nvar DomUtil;\r\n/**\r\n * Detects support for options object argument in addEventListener.\r\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\r\n * @private\r\n */\r\n\r\nvar supportsEventListenerOptions = function () {\r\n  var supports = false;\r\n\r\n  try {\r\n    var options = Object.defineProperty({}, 'passive', {\r\n      get: function get() {\r\n        supports = true;\r\n      }\r\n    });\r\n    window.addEventListener('e', null, options);\r\n  } catch (e) {// continue regardless of error\r\n  }\r\n\r\n  return supports;\r\n}(); // Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.\r\n// https://github.com/chartjs/Chart.js/issues/4287\r\n\r\n\r\nvar eventListenerOptions = supportsEventListenerOptions ? {\r\n  passive: true\r\n} : false;\r\n\r\nfunction createEvent(type, chart, x, y, nativeEvent) {\r\n  return {\r\n    type: type,\r\n    chart: chart,\r\n    \"native\": nativeEvent || null,\r\n    x: x !== undefined ? x : null,\r\n    y: y !== undefined ? y : null\r\n  };\r\n}\r\n\r\nfunction fromNativeEvent(event, chart) {\r\n  var type = event.type;\r\n  var clientPoint; // 说明是touch相关事件\r\n\r\n  if (event.touches) {\r\n    // https://developer.mozilla.org/zh-CN/docs/Web/API/TouchEvent/changedTouches\r\n    // 这里直接拿changedTouches就可以了，不管是touchstart, touchmove, touchend changedTouches 都是有的\r\n    // 为了以防万一，做个空判断\r\n    var touch = event.changedTouches[0] || {}; // x, y: 相对canvas原点的位置，clientX, clientY 相对于可视窗口的位置\r\n\r\n    var x = touch.x,\r\n        y = touch.y,\r\n        clientX = touch.clientX,\r\n        clientY = touch.clientY; // 小程序环境会有x,y，这里就直接返回\r\n\r\n    if (x && y) {\r\n      return createEvent(type, chart, x, y, event);\r\n    }\r\n\r\n    clientPoint = {\r\n      x: clientX,\r\n      y: clientY\r\n    };\r\n  } else {\r\n    // mouse相关事件\r\n    clientPoint = {\r\n      x: event.clientX,\r\n      y: event.clientY\r\n    };\r\n  } // 理论上应该是只有有在浏览器环境才会走到这里\r\n\r\n\r\n  var canvas = chart.get('canvas'); // 通过clientX, clientY 计算x, y\r\n\r\n  var point = DomUtil.getRelativePosition(clientPoint, canvas);\r\n  return createEvent(type, chart, point.x, point.y, event);\r\n}\r\n\r\nDomUtil = {\r\n  /* global wx, my */\r\n  isWx: typeof wx === 'object' && typeof wx.getSystemInfoSync === 'function',\r\n  // weixin miniprogram\r\n  isMy: typeof my === 'object' && typeof my.getSystemInfoSync === 'function',\r\n  // ant miniprogram\r\n  isNode: typeof module !== 'undefined' && typeof module.exports !== 'undefined',\r\n  // in node\r\n  isBrowser: typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.sessionStorage !== 'undefined',\r\n  // in browser\r\n  isCanvasElement: function isCanvasElement(el) {\r\n    if (!el || typeof el !== 'object') return false;\r\n\r\n    if (el.nodeType === 1 && el.nodeName) {\r\n      // HTMLCanvasElement\r\n      return true;\r\n    } // CanvasElement\r\n\r\n\r\n    return !!el.isCanvasElement;\r\n  },\r\n  getPixelRatio: function getPixelRatio() {\r\n    return window && window.devicePixelRatio || 1;\r\n  },\r\n  getStyle: function getStyle(el, property) {\r\n    return el.currentStyle ? el.currentStyle[property] : document.defaultView.getComputedStyle(el, null).getPropertyValue(property);\r\n  },\r\n  getWidth: function getWidth(el) {\r\n    var width = this.getStyle(el, 'width');\r\n\r\n    if (width === 'auto') {\r\n      width = el.offsetWidth;\r\n    }\r\n\r\n    return parseFloat(width);\r\n  },\r\n  getHeight: function getHeight(el) {\r\n    var height = this.getStyle(el, 'height');\r\n\r\n    if (height === 'auto') {\r\n      height = el.offsetHeight;\r\n    }\r\n\r\n    return parseFloat(height);\r\n  },\r\n  getDomById: function getDomById(id) {\r\n    if (!id) {\r\n      return null;\r\n    }\r\n\r\n    return document.getElementById(id);\r\n  },\r\n  getRelativePosition: function getRelativePosition(point, canvas) {\r\n    var canvasDom = canvas.get('el');\r\n\r\n    var _canvasDom$getBoundin = canvasDom.getBoundingClientRect(),\r\n        top = _canvasDom$getBoundin.top,\r\n        right = _canvasDom$getBoundin.right,\r\n        bottom = _canvasDom$getBoundin.bottom,\r\n        left = _canvasDom$getBoundin.left;\r\n\r\n    var paddingLeft = parseFloat(this.getStyle(canvasDom, 'padding-left'));\r\n    var paddingTop = parseFloat(this.getStyle(canvasDom, 'padding-top'));\r\n    var paddingRight = parseFloat(this.getStyle(canvasDom, 'padding-right'));\r\n    var paddingBottom = parseFloat(this.getStyle(canvasDom, 'padding-bottom'));\r\n    var width = right - left - paddingLeft - paddingRight;\r\n    var height = bottom - top - paddingTop - paddingBottom;\r\n    var pixelRatio = canvas.get('pixelRatio');\r\n    var mouseX = (point.x - left - paddingLeft) / width * canvasDom.width / pixelRatio;\r\n    var mouseY = (point.y - top - paddingTop) / height * canvasDom.height / pixelRatio;\r\n    return {\r\n      x: mouseX,\r\n      y: mouseY\r\n    };\r\n  },\r\n  addEventListener: function addEventListener(source, type, listener) {\r\n    source.addEventListener(type, listener, eventListenerOptions);\r\n  },\r\n  removeEventListener: function removeEventListener(source, type, listener) {\r\n    source.removeEventListener(type, listener, eventListenerOptions);\r\n  },\r\n  createEvent: function createEvent(event, chart) {\r\n    return fromNativeEvent(event, chart);\r\n  },\r\n  measureText: function measureText(text, font, ctx) {\r\n    if (!ctx) {\r\n      ctx = document.createElement('canvas').getContext('2d');\r\n    }\r\n\r\n    ctx.font = font || '12px sans-serif';\r\n    return ctx.measureText(text);\r\n  }\r\n};\r\nmodule.exports = DomUtil;","\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\r\n\r\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\r\n\r\nvar Base = require('../base');\r\n\r\nvar Plot = require('./plot');\r\n\r\nvar Util = require('../util/common');\r\n\r\nvar Coord = require('../coord/index');\r\n\r\nvar Geom = require('../geom/base');\r\n\r\nvar ScaleController = require('./controller/scale');\r\n\r\nvar AxisController = require('./controller/axis');\r\n\r\nvar Global = require('../global');\r\n\r\nvar _require = require('../graphic/index'),\r\n    Canvas = _require.Canvas;\r\n\r\nvar Helper = require('../util/helper');\r\n\r\nfunction isFullCircle(coord) {\r\n  var startAngle = coord.startAngle;\r\n  var endAngle = coord.endAngle;\r\n\r\n  if (!Util.isNil(startAngle) && !Util.isNil(endAngle) && endAngle - startAngle < Math.PI * 2) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction compare(a, b) {\r\n  return a - b;\r\n}\r\n\r\nfunction _isScaleExist(scales, compareScale) {\r\n  var flag = false;\r\n  Util.each(scales, function (scale) {\r\n    var scaleValues = [].concat(scale.values);\r\n    var compareScaleValues = [].concat(compareScale.values);\r\n\r\n    if (scale.type === compareScale.type && scale.field === compareScale.field && scaleValues.sort(compare).toString() === compareScaleValues.sort(compare).toString()) {\r\n      flag = true;\r\n      return;\r\n    }\r\n  });\r\n  return flag;\r\n}\r\n\r\nvar Chart =\r\n/*#__PURE__*/\r\nfunction (_Base) {\r\n  (0, _inheritsLoose2[\"default\"])(Chart, _Base);\r\n\r\n  Chart.initPlugins = function initPlugins() {\r\n    return {\r\n      _plugins: [],\r\n      _cacheId: 0,\r\n      register: function register(plugins) {\r\n        var p = this._plugins;\r\n        [].concat(plugins).forEach(function (plugin) {\r\n          if (p.indexOf(plugin) === -1) {\r\n            p.push(plugin);\r\n          }\r\n        });\r\n        this._cacheId++;\r\n      },\r\n      unregister: function unregister(plugins) {\r\n        var p = this._plugins;\r\n        [].concat(plugins).forEach(function (plugin) {\r\n          var idx = p.indexOf(plugin);\r\n\r\n          if (idx !== -1) {\r\n            p.splice(idx, 1);\r\n          }\r\n        });\r\n        this._cacheId++;\r\n      },\r\n      clear: function clear() {\r\n        this._plugins = [];\r\n        this._cacheId++;\r\n      },\r\n      count: function count() {\r\n        return this._plugins.length;\r\n      },\r\n      getAll: function getAll() {\r\n        return this._plugins;\r\n      },\r\n      notify: function notify(chart, hook, args) {\r\n        var descriptors = this.descriptors(chart);\r\n        var ilen = descriptors.length;\r\n        var i;\r\n        var descriptor;\r\n        var plugin;\r\n        var params;\r\n        var method;\r\n\r\n        for (i = 0; i < ilen; ++i) {\r\n          descriptor = descriptors[i];\r\n          plugin = descriptor.plugin;\r\n          method = plugin[hook];\r\n\r\n          if (typeof method === 'function') {\r\n            params = [chart].concat(args || []);\r\n\r\n            if (method.apply(plugin, params) === false) {\r\n              return false;\r\n            }\r\n          }\r\n        }\r\n\r\n        return true;\r\n      },\r\n      descriptors: function descriptors(chart) {\r\n        var cache = chart._plugins || (chart._plugins = {});\r\n\r\n        if (cache.id === this._cacheId) {\r\n          return cache.descriptors;\r\n        }\r\n\r\n        var plugins = [];\r\n        var descriptors = [];\r\n\r\n        this._plugins.concat(chart && chart.get('plugins') || []).forEach(function (plugin) {\r\n          var idx = plugins.indexOf(plugin);\r\n\r\n          if (idx !== -1) {\r\n            return;\r\n          }\r\n\r\n          plugins.push(plugin);\r\n          descriptors.push({\r\n            plugin: plugin\r\n          });\r\n        });\r\n\r\n        cache.descriptors = descriptors;\r\n        cache.id = this._cacheId;\r\n        return descriptors;\r\n      }\r\n    };\r\n  };\r\n\r\n  var _proto = Chart.prototype;\r\n\r\n  _proto.getDefaultCfg = function getDefaultCfg() {\r\n    return {\r\n      /**\r\n       * the id of canvas\r\n       * @type {String}\r\n       */\r\n      id: null,\r\n\r\n      /**\r\n       * padding\r\n       * @type {Array|Number}\r\n       */\r\n      padding: Global.padding,\r\n\r\n      /**\r\n       * data\r\n       * @type {Array}\r\n       */\r\n      data: null,\r\n\r\n      /**\r\n       * scales of chart\r\n       * @type {Object}\r\n       */\r\n      scales: {},\r\n\r\n      /**\r\n       * @private\r\n       * geometry instances\r\n       * @type {Array}\r\n       */\r\n      geoms: null,\r\n\r\n      /**\r\n       * scale configuration\r\n       * @type {Object}\r\n       */\r\n      colDefs: null,\r\n      pixelRatio: Global.pixelRatio,\r\n\r\n      /**\r\n       * filter options\r\n       * @type {Object}\r\n       */\r\n      filters: null,\r\n      appendPadding: Global.appendPadding\r\n    };\r\n  };\r\n\r\n  _proto._syncYScales = function _syncYScales() {\r\n    var geoms = this.get('geoms');\r\n    var syncScales = [];\r\n    var min = [];\r\n    var max = [];\r\n    Util.each(geoms, function (geom) {\r\n      var yScale = geom.getYScale();\r\n\r\n      if (yScale.isLinear) {\r\n        syncScales.push(yScale);\r\n        min.push(yScale.min);\r\n        max.push(yScale.max);\r\n      }\r\n    });\r\n    min = Math.min.apply(null, min);\r\n    max = Math.max.apply(null, max);\r\n    Util.each(syncScales, function (scale) {\r\n      scale.change({\r\n        min: min\r\n      });\r\n      scale.change({\r\n        max: max\r\n      });\r\n    });\r\n  };\r\n\r\n  _proto._getFieldsForLegend = function _getFieldsForLegend() {\r\n    var fields = [];\r\n    var geoms = this.get('geoms');\r\n    Util.each(geoms, function (geom) {\r\n      var attrOptions = geom.get('attrOptions');\r\n      var attrCfg = attrOptions.color;\r\n\r\n      if (attrCfg && attrCfg.field && Util.isString(attrCfg.field)) {\r\n        var arr = attrCfg.field.split('*');\r\n        Util.each(arr, function (item) {\r\n          if (fields.indexOf(item) === -1) {\r\n            fields.push(item);\r\n          }\r\n        });\r\n      }\r\n    });\r\n    return fields;\r\n  };\r\n\r\n  _proto._createScale = function _createScale(field, data) {\r\n    var scaleController = this.get('scaleController');\r\n    return scaleController.createScale(field, data);\r\n  };\r\n\r\n  _proto._adjustScale = function _adjustScale() {\r\n    var self = this;\r\n    var coord = self.get('coord');\r\n    var xScale = self.getXScale();\r\n    var yScales = self.getYScales();\r\n    var scales = [];\r\n    xScale && scales.push(xScale);\r\n    scales = scales.concat(yScales);\r\n    var inFullCircle = coord.isPolar && isFullCircle(coord);\r\n    var scaleController = self.get('scaleController');\r\n    var colDefs = scaleController.defs;\r\n    Util.each(scales, function (scale) {\r\n      if ((scale.isCategory || scale.isIdentity) && scale.values && !(colDefs[scale.field] && colDefs[scale.field].range)) {\r\n        var count = scale.values.length;\r\n        var range;\r\n\r\n        if (count === 1) {\r\n          range = [0.5, 1];\r\n        } else {\r\n          var widthRatio = 1;\r\n          var offset = 0;\r\n\r\n          if (inFullCircle) {\r\n            if (!coord.transposed) {\r\n              range = [0, 1 - 1 / count];\r\n            } else {\r\n              widthRatio = Global.widthRatio.multiplePie;\r\n              offset = 1 / count * widthRatio;\r\n              range = [offset / 2, 1 - offset / 2];\r\n            }\r\n          } else {\r\n            offset = 1 / count * 1 / 2;\r\n            range = [offset, 1 - offset];\r\n          }\r\n        }\r\n\r\n        scale.range = range;\r\n      }\r\n    });\r\n    var geoms = this.get('geoms');\r\n\r\n    for (var i = 0; i < geoms.length; i++) {\r\n      var geom = geoms[i];\r\n\r\n      if (geom.get('type') === 'interval') {\r\n        var yScale = geom.getYScale();\r\n        var field = yScale.field,\r\n            min = yScale.min,\r\n            max = yScale.max,\r\n            type = yScale.type;\r\n\r\n        if (!(colDefs[field] && colDefs[field].min) && type !== 'time') {\r\n          if (min > 0) {\r\n            yScale.change({\r\n              min: 0\r\n            });\r\n          } else if (max <= 0) {\r\n            yScale.change({\r\n              max: 0\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  _proto._removeGeoms = function _removeGeoms() {\r\n    var geoms = this.get('geoms');\r\n\r\n    while (geoms.length > 0) {\r\n      var geom = geoms.shift();\r\n      geom.destroy();\r\n    }\r\n  };\r\n\r\n  _proto._clearGeoms = function _clearGeoms() {\r\n    var geoms = this.get('geoms');\r\n\r\n    for (var i = 0, length = geoms.length; i < length; i++) {\r\n      var geom = geoms[i];\r\n      geom.clear();\r\n    }\r\n  };\r\n\r\n  _proto._clearInner = function _clearInner() {\r\n    this.set('scales', {});\r\n    this.set('legendItems', null);\r\n\r\n    this._clearGeoms();\r\n\r\n    Chart.plugins.notify(this, 'clearInner');\r\n    this.get('axisController') && this.get('axisController').clear();\r\n  };\r\n\r\n  _proto._execFilter = function _execFilter(data) {\r\n    var filters = this.get('filters');\r\n\r\n    if (filters) {\r\n      data = data.filter(function (obj) {\r\n        var rst = true;\r\n        Util.each(filters, function (fn, k) {\r\n          if (fn) {\r\n            rst = fn(obj[k], obj);\r\n\r\n            if (!rst) {\r\n              return false;\r\n            }\r\n          }\r\n        });\r\n        return rst;\r\n      });\r\n    }\r\n\r\n    return data;\r\n  };\r\n\r\n  _proto._initGeoms = function _initGeoms(geoms) {\r\n    var coord = this.get('coord');\r\n    var data = this.get('filteredData');\r\n    var colDefs = this.get('colDefs');\r\n\r\n    for (var i = 0, length = geoms.length; i < length; i++) {\r\n      var geom = geoms[i];\r\n      geom.set('data', data);\r\n      geom.set('coord', coord);\r\n      geom.set('colDefs', colDefs);\r\n      geom.init();\r\n    }\r\n  };\r\n\r\n  _proto._initCoord = function _initCoord() {\r\n    var plot = this.get('plotRange');\r\n    var coordCfg = Util.mix({\r\n      type: 'cartesian'\r\n    }, this.get('coordCfg'), {\r\n      plot: plot\r\n    });\r\n    var type = coordCfg.type;\r\n    var C = Coord[Util.upperFirst(type)];\r\n    var coord = new C(coordCfg);\r\n    this.set('coord', coord);\r\n  };\r\n\r\n  _proto._initLayout = function _initLayout() {\r\n    var padding = this.get('_padding');\r\n\r\n    if (!padding) {\r\n      padding = this.get('margin') || this.get('padding');\r\n      padding = Util.parsePadding(padding);\r\n    }\r\n\r\n    var top = padding[0] === 'auto' ? 0 : padding[0];\r\n    var right = padding[1] === 'auto' ? 0 : padding[1];\r\n    var bottom = padding[2] === 'auto' ? 0 : padding[2];\r\n    var left = padding[3] === 'auto' ? 0 : padding[3];\r\n    var width = this.get('width');\r\n    var height = this.get('height');\r\n    var plot = new Plot({\r\n      start: {\r\n        x: left,\r\n        y: top\r\n      },\r\n      end: {\r\n        x: width - right,\r\n        y: height - bottom\r\n      }\r\n    });\r\n    this.set('plotRange', plot);\r\n    this.set('plot', plot);\r\n  };\r\n\r\n  _proto._initCanvas = function _initCanvas() {\r\n    var self = this;\r\n\r\n    try {\r\n      var canvas = new Canvas({\r\n        el: self.get('el') || self.get('id'),\r\n        context: self.get('context'),\r\n        pixelRatio: self.get('pixelRatio'),\r\n        width: self.get('width'),\r\n        height: self.get('height'),\r\n        fontFamily: Global.fontFamily\r\n      });\r\n      self.set('canvas', canvas);\r\n      self.set('el', canvas.get('el'));\r\n      self.set('width', canvas.get('width'));\r\n      self.set('height', canvas.get('height'));\r\n    } catch (error) {\r\n      throw error;\r\n    }\r\n\r\n    Chart.plugins.notify(self, 'afterCanvasInit');\r\n\r\n    self._initLayout();\r\n  };\r\n\r\n  _proto._initLayers = function _initLayers() {\r\n    var canvas = this.get('canvas');\r\n    this.set('backPlot', canvas.addGroup());\r\n    this.set('middlePlot', canvas.addGroup({\r\n      zIndex: 10\r\n    }));\r\n    this.set('frontPlot', canvas.addGroup({\r\n      zIndex: 20\r\n    }));\r\n  };\r\n\r\n  _proto._init = function _init() {\r\n    var self = this;\r\n\r\n    self._initCanvas();\r\n\r\n    self._initLayers();\r\n\r\n    self.set('geoms', []);\r\n    self.set('scaleController', new ScaleController());\r\n    self.set('axisController', new AxisController({\r\n      frontPlot: self.get('frontPlot').addGroup({\r\n        className: 'axisContainer'\r\n      }),\r\n      backPlot: self.get('backPlot').addGroup({\r\n        className: 'axisContainer'\r\n      }),\r\n      chart: self\r\n    }));\r\n    Chart.plugins.notify(self, 'init');\r\n  };\r\n\r\n  function Chart(cfg) {\r\n    var _this;\r\n\r\n    _this = _Base.call(this, cfg) || this;\r\n    var self = (0, _assertThisInitialized2[\"default\"])(_this);\r\n    Util.each(Geom, function (geomConstructor, className) {\r\n      var methodName = Util.lowerFirst(className);\r\n\r\n      self[methodName] = function (cfg) {\r\n        var geom = new geomConstructor(cfg);\r\n        self.addGeom(geom);\r\n        return geom;\r\n      };\r\n    });\r\n\r\n    self._init();\r\n\r\n    return _this;\r\n  }\r\n  /**\r\n   * set data and some scale configuration\r\n   * @chainable\r\n   * @param  {Array} data the dataset to visualize\r\n   * @param  {Object} colDefs the configuration for scales\r\n   * @return {Chart} return the chart instance\r\n   */\r\n\r\n\r\n  _proto.source = function source(data, colDefs) {\r\n    this.set('data', data);\r\n\r\n    if (colDefs) {\r\n      this.scale(colDefs);\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  _proto.scale = function scale(field, cfg) {\r\n    var colDefs = this.get('colDefs') || {};\r\n\r\n    if (Util.isObject(field)) {\r\n      Util.mix(colDefs, field);\r\n    } else {\r\n      colDefs[field] = cfg;\r\n    }\r\n\r\n    this.set('colDefs', colDefs);\r\n    var scaleController = this.get('scaleController');\r\n    scaleController.defs = colDefs;\r\n    return this;\r\n  }\r\n  /**\r\n   * configure the axis\r\n   * @chainable\r\n   * @param  {String|Boolean} field the field name of data\r\n   * @param  {Object} cfg configuration for axis\r\n   * @return {Chart} return the chart instance\r\n   */\r\n  ;\r\n\r\n  _proto.axis = function axis(field, cfg) {\r\n    var axisController = this.get('axisController');\r\n\r\n    if (!field) {\r\n      axisController.axisCfg = null;\r\n    } else {\r\n      axisController.axisCfg = axisController.axisCfg || {};\r\n      axisController.axisCfg[field] = cfg;\r\n    }\r\n\r\n    return this;\r\n  }\r\n  /**\r\n   * configure the coordinate\r\n   * @chainable\r\n   * @param  {String} type set the type of coodinate\r\n   * @param  {Object} cfg configuration for coordinate\r\n   * @return {Chart} return the chart instance\r\n   */\r\n  ;\r\n\r\n  _proto.coord = function coord(type, cfg) {\r\n    var coordCfg;\r\n\r\n    if (Util.isObject(type)) {\r\n      coordCfg = type;\r\n    } else {\r\n      coordCfg = cfg || {};\r\n      coordCfg.type = type || 'cartesian';\r\n    }\r\n\r\n    this.set('coordCfg', coordCfg);\r\n    return this;\r\n  };\r\n\r\n  _proto.filter = function filter(field, condition) {\r\n    var filters = this.get('filters') || {};\r\n    filters[field] = condition;\r\n    this.set('filters', filters);\r\n  }\r\n  /**\r\n   * render the chart\r\n   * @chainable\r\n   * @return {Chart} return the chart instance\r\n   */\r\n  ;\r\n\r\n  _proto.render = function render() {\r\n    var canvas = this.get('canvas');\r\n    var geoms = this.get('geoms');\r\n    var data = this.get('data') || [];\r\n\r\n    var filteredData = this._execFilter(data); // filter data\r\n\r\n\r\n    this.set('filteredData', filteredData);\r\n\r\n    this._initCoord(); // initialization coordinate instance\r\n\r\n\r\n    Chart.plugins.notify(this, 'beforeGeomInit');\r\n\r\n    this._initGeoms(geoms); // init all geometry instances\r\n\r\n\r\n    this.get('syncY') && this._syncYScales();\r\n\r\n    this._adjustScale(); // do some adjust for data\r\n\r\n\r\n    Chart.plugins.notify(this, 'beforeGeomDraw');\r\n\r\n    this._renderAxis();\r\n\r\n    var middlePlot = this.get('middlePlot');\r\n\r\n    if (this.get('limitInPlot') && !middlePlot.attr('clip')) {\r\n      var coord = this.get('coord');\r\n      var clip = Helper.getClip(coord);\r\n      clip.set('canvas', middlePlot.get('canvas'));\r\n      middlePlot.attr('clip', clip);\r\n    }\r\n\r\n    for (var i = 0, length = geoms.length; i < length; i++) {\r\n      var geom = geoms[i];\r\n      geom.paint();\r\n    }\r\n\r\n    Chart.plugins.notify(this, 'afterGeomDraw');\r\n    canvas.sort();\r\n    this.get('frontPlot').sort();\r\n    Chart.plugins.notify(this, 'beforeCanvasDraw');\r\n    canvas.draw();\r\n    return this;\r\n  }\r\n  /**\r\n   * clear the chart, include geometris and all the shapes\r\n   * @chainable\r\n   * @return {Chart} return the chart\r\n   */\r\n  ;\r\n\r\n  _proto.clear = function clear() {\r\n    Chart.plugins.notify(this, 'clear');\r\n\r\n    this._removeGeoms();\r\n\r\n    this._clearInner();\r\n\r\n    this.set('filters', null);\r\n    this.set('isUpdate', false);\r\n    this.set('_padding', null);\r\n    var canvas = this.get('canvas');\r\n    canvas.draw();\r\n    return this;\r\n  };\r\n\r\n  _proto.repaint = function repaint() {\r\n    this.set('isUpdate', true);\r\n    Chart.plugins.notify(this, 'repaint');\r\n\r\n    this._clearInner();\r\n\r\n    this.render();\r\n  };\r\n\r\n  _proto.changeData = function changeData(data) {\r\n    this.set('data', data);\r\n    Chart.plugins.notify(this, 'changeData');\r\n    this.set('_padding', null);\r\n    this.repaint();\r\n  };\r\n\r\n  _proto.changeSize = function changeSize(width, height) {\r\n    if (width) {\r\n      this.set('width', width);\r\n    } else {\r\n      width = this.get('width');\r\n    }\r\n\r\n    if (height) {\r\n      this.set('height', height);\r\n    } else {\r\n      height = this.get('height');\r\n    }\r\n\r\n    var canvas = this.get('canvas');\r\n    canvas.changeSize(width, height);\r\n\r\n    this._initLayout();\r\n\r\n    this.repaint();\r\n    return this;\r\n  };\r\n\r\n  _proto.destroy = function destroy() {\r\n    this.clear();\r\n    var canvas = this.get('canvas');\r\n    canvas.destroy();\r\n    Chart.plugins.notify(this, 'afterCanvasDestroyed');\r\n\r\n    if (this._interactions) {\r\n      Util.each(this._interactions, function (interaction) {\r\n        interaction.destroy();\r\n      });\r\n    }\r\n\r\n    _Base.prototype.destroy.call(this);\r\n  }\r\n  /**\r\n   * calculate dataset's position on canvas\r\n   * @param  {Object} record the dataset\r\n   * @return {Object} return the position\r\n   */\r\n  ;\r\n\r\n  _proto.getPosition = function getPosition(record) {\r\n    var self = this;\r\n    var coord = self.get('coord');\r\n    var xScale = self.getXScale();\r\n    var yScale = self.getYScales()[0];\r\n    var xField = xScale.field;\r\n    var x = xScale.scale(record[xField]);\r\n    var yField = yScale.field;\r\n    var y = yScale.scale(record[yField]);\r\n    return coord.convertPoint({\r\n      x: x,\r\n      y: y\r\n    });\r\n  }\r\n  /**\r\n   * get the data item of the point\r\n   * @param  {Object} point canvas position\r\n   * @return {Object} return the data item\r\n   */\r\n  ;\r\n\r\n  _proto.getRecord = function getRecord(point) {\r\n    var self = this;\r\n    var coord = self.get('coord');\r\n    var xScale = self.getXScale();\r\n    var yScale = self.getYScales()[0];\r\n    var invertPoint = coord.invertPoint(point);\r\n    var record = {};\r\n    record[xScale.field] = xScale.invert(invertPoint.x);\r\n    record[yScale.field] = yScale.invert(invertPoint.y);\r\n    return record;\r\n  }\r\n  /**\r\n   * get the dataset of the point\r\n   * @param  {Object} point canvas position\r\n   * @return {Array} return the dataset\r\n  **/\r\n  ;\r\n\r\n  _proto.getSnapRecords = function getSnapRecords(point) {\r\n    var geom = this.get('geoms')[0];\r\n    var data = [];\r\n\r\n    if (geom) {\r\n      // need to judge\r\n      data = geom.getSnapRecords(point);\r\n    }\r\n\r\n    return data;\r\n  }\r\n  /**\r\n   * creat scale instances\r\n   * @param  {String} field field name of data\r\n   * @return {Scale} return the scale\r\n   */\r\n  ;\r\n\r\n  _proto.createScale = function createScale(field) {\r\n    var data = this.get('data');\r\n    var filteredData = this.get('filteredData');\r\n\r\n    if (filteredData.length) {\r\n      var legendFields = this._getFieldsForLegend();\r\n\r\n      if (legendFields.indexOf(field) === -1) {\r\n        data = filteredData;\r\n      }\r\n    }\r\n\r\n    var scales = this.get('scales');\r\n\r\n    if (!scales[field]) {\r\n      scales[field] = this._createScale(field, data);\r\n    }\r\n\r\n    return scales[field];\r\n  }\r\n  /**\r\n   * @protected\r\n   * add geometry instance to geoms\r\n   * @param {Geom} geom geometry instance\r\n   */\r\n  ;\r\n\r\n  _proto.addGeom = function addGeom(geom) {\r\n    var geoms = this.get('geoms');\r\n    var middlePlot = this.get('middlePlot');\r\n    geoms.push(geom);\r\n    geom.set('chart', this);\r\n    geom.set('container', middlePlot.addGroup());\r\n  }\r\n  /**\r\n   * get the scale of x axis\r\n   * @return {Scale} return the scale\r\n   */\r\n  ;\r\n\r\n  _proto.getXScale = function getXScale() {\r\n    var self = this;\r\n    var geoms = self.get('geoms');\r\n    var xScale = geoms[0].getXScale();\r\n    return xScale;\r\n  }\r\n  /**\r\n   * get the scale of y axis\r\n   * @return {Array} return the scale\r\n   */\r\n  ;\r\n\r\n  _proto.getYScales = function getYScales() {\r\n    var geoms = this.get('geoms');\r\n    var rst = [];\r\n    Util.each(geoms, function (geom) {\r\n      var yScale = geom.getYScale();\r\n\r\n      if (rst.indexOf(yScale) === -1) {\r\n        rst.push(yScale);\r\n      }\r\n    });\r\n    return rst;\r\n  };\r\n\r\n  _proto.getLegendItems = function getLegendItems() {\r\n    if (this.get('legendItems')) {\r\n      return this.get('legendItems');\r\n    }\r\n\r\n    var legendItems = {};\r\n    var scales = [];\r\n    var geoms = this.get('geoms');\r\n    Util.each(geoms, function (geom) {\r\n      var colorAttr = geom.getAttr('color');\r\n\r\n      if (colorAttr) {\r\n        var scale = colorAttr.getScale('color'); // 只支持分类图例\r\n\r\n        if (scale.isCategory && !_isScaleExist(scales, scale)) {\r\n          scales.push(scale);\r\n          var field = scale.field;\r\n          var ticks = scale.getTicks();\r\n          var items = [];\r\n          Util.each(ticks, function (tick) {\r\n            var text = tick.text;\r\n            var name = text;\r\n            var scaleValue = tick.value;\r\n            var value = scale.invert(scaleValue);\r\n            var color = colorAttr.mapping(value).join('') || Global.defaultColor;\r\n            var marker = {\r\n              fill: color,\r\n              radius: 3,\r\n              symbol: 'circle',\r\n              stroke: '#fff'\r\n            };\r\n            items.push({\r\n              name: name,\r\n              // for display\r\n              dataValue: value,\r\n              // the origin value\r\n              checked: true,\r\n              marker: marker\r\n            });\r\n          });\r\n          legendItems[field] = items;\r\n        }\r\n      }\r\n    });\r\n    this.set('legendItems', legendItems);\r\n    return legendItems;\r\n  } // register the plugins\r\n  ;\r\n\r\n  _proto.registerPlugins = function registerPlugins(plugins) {\r\n    var self = this;\r\n    var chartPlugins = self.get('plugins') || [];\r\n\r\n    if (!Util.isArray(chartPlugins)) {\r\n      chartPlugins = [chartPlugins];\r\n    }\r\n\r\n    [].concat(plugins).forEach(function (plugin) {\r\n      if (chartPlugins.indexOf(plugin) === -1) {\r\n        plugin.init && plugin.init(self); // init\r\n\r\n        chartPlugins.push(plugin);\r\n      }\r\n    });\r\n    Chart.plugins._cacheId++;\r\n    self.set('plugins', chartPlugins);\r\n  };\r\n\r\n  _proto._renderAxis = function _renderAxis() {\r\n    var axisController = this.get('axisController');\r\n    var xScale = this.getXScale();\r\n    var yScales = this.getYScales();\r\n    var coord = this.get('coord');\r\n    Chart.plugins.notify(this, 'beforeRenderAxis');\r\n    axisController.createAxis(coord, xScale, yScales);\r\n  };\r\n\r\n  _proto._isAutoPadding = function _isAutoPadding() {\r\n    if (this.get('_padding')) {\r\n      return false;\r\n    }\r\n\r\n    var padding = this.get('padding');\r\n\r\n    if (Util.isArray(padding)) {\r\n      return padding.indexOf('auto') !== -1;\r\n    }\r\n\r\n    return padding === 'auto';\r\n  };\r\n\r\n  _proto._updateLayout = function _updateLayout(padding) {\r\n    var width = this.get('width');\r\n    var height = this.get('height');\r\n    var start = {\r\n      x: padding[3],\r\n      y: padding[0]\r\n    };\r\n    var end = {\r\n      x: width - padding[1],\r\n      y: height - padding[2]\r\n    };\r\n    var plot = this.get('plot');\r\n    var coord = this.get('coord');\r\n    plot.reset(start, end);\r\n    coord.reset(plot);\r\n  };\r\n\r\n  return Chart;\r\n}(Base);\r\n\r\nChart.plugins = Chart.initPlugins();\r\nmodule.exports = Chart;","\r\n\r\n/**\r\n * @fileOverview Base class of chart and geometry\r\n * @author dxq613@gmail.com\r\n */\r\nvar Util = require('./util/common');\r\n\r\nvar Base =\r\n/*#__PURE__*/\r\nfunction () {\r\n  var _proto = Base.prototype;\r\n\r\n  _proto.getDefaultCfg = function getDefaultCfg() {\r\n    return {};\r\n  };\r\n\r\n  function Base(cfg) {\r\n    var attrs = {};\r\n    var defaultCfg = this.getDefaultCfg();\r\n    this._attrs = attrs;\r\n    Util.mix(attrs, defaultCfg, cfg);\r\n  }\r\n\r\n  _proto.get = function get(name) {\r\n    return this._attrs[name];\r\n  };\r\n\r\n  _proto.set = function set(name, value) {\r\n    this._attrs[name] = value;\r\n  };\r\n\r\n  _proto.destroy = function destroy() {\r\n    this._attrs = {};\r\n    this.destroyed = true;\r\n  };\r\n\r\n  return Base;\r\n}();\r\n\r\nmodule.exports = Base;","\r\n\r\nvar Util = require('../util/common');\r\n\r\nvar Plot =\r\n/*#__PURE__*/\r\nfunction () {\r\n  function Plot(cfg) {\r\n    Util.mix(this, cfg);\r\n\r\n    this._init();\r\n  }\r\n\r\n  var _proto = Plot.prototype;\r\n\r\n  _proto._init = function _init() {\r\n    var self = this;\r\n    var start = self.start;\r\n    var end = self.end;\r\n    var xMin = Math.min(start.x, end.x);\r\n    var xMax = Math.max(start.x, end.x);\r\n    var yMin = Math.min(start.y, end.y);\r\n    var yMax = Math.max(start.y, end.y);\r\n    this.tl = {\r\n      x: xMin,\r\n      y: yMin\r\n    };\r\n    this.tr = {\r\n      x: xMax,\r\n      y: yMin\r\n    };\r\n    this.bl = {\r\n      x: xMin,\r\n      y: yMax\r\n    };\r\n    this.br = {\r\n      x: xMax,\r\n      y: yMax\r\n    };\r\n    this.width = xMax - xMin;\r\n    this.height = yMax - yMin;\r\n  }\r\n  /**\r\n   * reset\r\n   * @param  {Object} start start point\r\n   * @param  {Object} end end point\r\n   */\r\n  ;\r\n\r\n  _proto.reset = function reset(start, end) {\r\n    this.start = start;\r\n    this.end = end;\r\n\r\n    this._init();\r\n  }\r\n  /**\r\n   * check the point is in the range of plot\r\n   * @param  {Nubmer}  x x value\r\n   * @param  {[type]}  y y value\r\n   * @return {Boolean} return the result\r\n   */\r\n  ;\r\n\r\n  _proto.isInRange = function isInRange(x, y) {\r\n    if (Util.isObject(x)) {\r\n      y = x.y;\r\n      x = x.x;\r\n    }\r\n\r\n    var tl = this.tl;\r\n    var br = this.br;\r\n    return tl.x <= x && x <= br.x && tl.y <= y && y <= br.y;\r\n  };\r\n\r\n  return Plot;\r\n}();\r\n\r\nmodule.exports = Plot;","\r\n\r\nvar Coord = require('./base');\r\n\r\nrequire('./cartesian');\r\n\r\nmodule.exports = Coord;","\r\n\r\nvar Util = require('../util/common');\r\n\r\nvar MatrixUtil = require('../graphic/util/matrix');\r\n\r\nvar Vector2 = require('../graphic/util/vector2');\r\n\r\nvar defaultMatrix = [1, 0, 0, 1, 0, 0];\r\n\r\nvar Base =\r\n/*#__PURE__*/\r\nfunction () {\r\n  var _proto = Base.prototype;\r\n\r\n  _proto._initDefaultCfg = function _initDefaultCfg() {};\r\n\r\n  function Base(cfg) {\r\n    this._initDefaultCfg();\r\n\r\n    Util.mix(this, cfg);\r\n    var start;\r\n    var end;\r\n\r\n    if (this.plot) {\r\n      start = this.plot.bl;\r\n      end = this.plot.tr;\r\n      this.start = start;\r\n      this.end = end;\r\n    } else {\r\n      start = this.start;\r\n      end = this.end;\r\n    }\r\n\r\n    this.init(start, end);\r\n  }\r\n\r\n  _proto._scale = function _scale(s1, s2) {\r\n    var matrix = this.matrix;\r\n    var center = this.center;\r\n    MatrixUtil.translate(matrix, matrix, [center.x, center.y]);\r\n    MatrixUtil.scale(matrix, matrix, [s1, s2]);\r\n    MatrixUtil.translate(matrix, matrix, [-center.x, -center.y]);\r\n  };\r\n\r\n  _proto.init = function init(start, end) {\r\n    this.matrix = [].concat(defaultMatrix); // 设置中心点\r\n\r\n    this.center = {\r\n      x: (end.x - start.x) / 2 + start.x,\r\n      y: (end.y - start.y) / 2 + start.y\r\n    };\r\n\r\n    if (this.scale) {\r\n      this._scale(this.scale[0], this.scale[1]);\r\n    }\r\n  };\r\n\r\n  _proto.convertPoint = function convertPoint(point) {\r\n    var _this$_convertPoint = this._convertPoint(point),\r\n        x = _this$_convertPoint.x,\r\n        y = _this$_convertPoint.y;\r\n\r\n    var vector = [x, y];\r\n    Vector2.transformMat2d(vector, vector, this.matrix);\r\n    return {\r\n      x: vector[0],\r\n      y: vector[1]\r\n    };\r\n  };\r\n\r\n  _proto.invertPoint = function invertPoint(point) {\r\n    return this._invertPoint(point);\r\n  };\r\n\r\n  _proto._convertPoint = function _convertPoint(point) {\r\n    return point;\r\n  };\r\n\r\n  _proto._invertPoint = function _invertPoint(point) {\r\n    return point;\r\n  };\r\n\r\n  _proto.reset = function reset(plot) {\r\n    this.plot = plot;\r\n    var bl = plot.bl,\r\n        tr = plot.tr;\r\n    this.start = bl;\r\n    this.end = tr;\r\n    this.init(bl, tr);\r\n  };\r\n\r\n  return Base;\r\n}();\r\n\r\nmodule.exports = Base;","\r\n\r\nvar Matrix = {\r\n  multiply: function multiply(m1, m2) {\r\n    var m11 = m1[0] * m2[0] + m1[2] * m2[1];\r\n    var m12 = m1[1] * m2[0] + m1[3] * m2[1];\r\n    var m21 = m1[0] * m2[2] + m1[2] * m2[3];\r\n    var m22 = m1[1] * m2[2] + m1[3] * m2[3];\r\n    var dx = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\r\n    var dy = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\r\n    return [m11, m12, m21, m22, dx, dy];\r\n  },\r\n  scale: function scale(out, m, v) {\r\n    out[0] = m[0] * v[0];\r\n    out[1] = m[1] * v[0];\r\n    out[2] = m[2] * v[1];\r\n    out[3] = m[3] * v[1];\r\n    out[4] = m[4];\r\n    out[5] = m[5];\r\n    return out;\r\n  },\r\n  rotate: function rotate(out, m, radian) {\r\n    var c = Math.cos(radian);\r\n    var s = Math.sin(radian);\r\n    var m11 = m[0] * c + m[2] * s;\r\n    var m12 = m[1] * c + m[3] * s;\r\n    var m21 = m[0] * -s + m[2] * c;\r\n    var m22 = m[1] * -s + m[3] * c;\r\n    out[0] = m11;\r\n    out[1] = m12;\r\n    out[2] = m21;\r\n    out[3] = m22;\r\n    out[4] = m[4];\r\n    out[5] = m[5];\r\n    return out;\r\n  },\r\n  translate: function translate(out, m, v) {\r\n    out[0] = m[0];\r\n    out[1] = m[1];\r\n    out[2] = m[2];\r\n    out[3] = m[3];\r\n    out[4] = m[4] + m[0] * v[0] + m[2] * v[1];\r\n    out[5] = m[5] + m[1] * v[0] + m[3] * v[1];\r\n    return out;\r\n  },\r\n  transform: function transform(m, actions) {\r\n    var out = [].concat(m);\r\n\r\n    for (var i = 0, len = actions.length; i < len; i++) {\r\n      var action = actions[i];\r\n\r\n      switch (action[0]) {\r\n        case 't':\r\n          Matrix.translate(out, out, [action[1], action[2]]);\r\n          break;\r\n\r\n        case 's':\r\n          Matrix.scale(out, out, [action[1], action[2]]);\r\n          break;\r\n\r\n        case 'r':\r\n          Matrix.rotate(out, out, action[1]);\r\n          break;\r\n\r\n        default:\r\n          break;\r\n      }\r\n    }\r\n\r\n    return out;\r\n  }\r\n};\r\nmodule.exports = Matrix;","\r\n\r\n/**\r\n * 2 Dimensional Vector\r\n * @module vector2\r\n */\r\nmodule.exports = {\r\n  /**\r\n   * Creates a new, empty vector2\r\n   *\r\n   * @return {vector2} a new 2D vector\r\n   */\r\n  create: function create() {\r\n    return [0, 0];\r\n  },\r\n\r\n  /**\r\n   * Calculates the length of a vector2\r\n   *\r\n   * @param {vector2} v vector to calculate length of\r\n   * @return {Number} length of v\r\n   */\r\n  length: function length(v) {\r\n    var x = v[0];\r\n    var y = v[1];\r\n    return Math.sqrt(x * x + y * y);\r\n  },\r\n\r\n  /**\r\n   * Normalize a vector2\r\n   *\r\n   * @param {vector2} out the receiving vector\r\n   * @param {vector2} v vector to normalize\r\n   * @return {vector2} out\r\n   */\r\n  normalize: function normalize(out, v) {\r\n    var len = this.length(v);\r\n\r\n    if (len === 0) {\r\n      out[0] = 0;\r\n      out[1] = 0;\r\n    } else {\r\n      out[0] = v[0] / len;\r\n      out[1] = v[1] / len;\r\n    }\r\n\r\n    return out;\r\n  },\r\n\r\n  /**\r\n   * Adds two vector2's\r\n   *\r\n   * @param {vector2} out the receiving vector\r\n   * @param {vector2} v1 the first operand\r\n   * @param {vector2} v2 the second operand\r\n   * @return {vector2} out\r\n   */\r\n  add: function add(out, v1, v2) {\r\n    out[0] = v1[0] + v2[0];\r\n    out[1] = v1[1] + v2[1];\r\n    return out;\r\n  },\r\n\r\n  /**\r\n   * Subtracts vector v2 from vector v1\r\n   *\r\n   * @param {vector2} out the receiving vector\r\n   * @param {vector2} v1 the first operand\r\n   * @param {vector2} v2 the second operand\r\n   * @return {vector2} out\r\n   */\r\n  sub: function sub(out, v1, v2) {\r\n    out[0] = v1[0] - v2[0];\r\n    out[1] = v1[1] - v2[1];\r\n    return out;\r\n  },\r\n\r\n  /**\r\n   * Scales a vector2 by a scalar number\r\n   *\r\n   * @param {vector2} out the receiving vector\r\n   * @param {vector2} v the vector to scale\r\n   * @param {Number} s amount to scale the vector by\r\n   * @return {vector2} out\r\n   */\r\n  scale: function scale(out, v, s) {\r\n    out[0] = v[0] * s;\r\n    out[1] = v[1] * s;\r\n    return out;\r\n  },\r\n\r\n  /**\r\n   * Calculates the dot product of two vector2's\r\n   *\r\n   * @param {vector2} v1 the first operand\r\n   * @param {vector2} v2 the second operand\r\n   * @return {Number} dot product of v1 and v2\r\n   */\r\n  dot: function dot(v1, v2) {\r\n    return v1[0] * v2[0] + v1[1] * v2[1];\r\n  },\r\n\r\n  /**\r\n   * Calculates the direction of two vector2's\r\n   *\r\n   * @param {vector2} v1 the first operand\r\n   * @param {vector2} v2 the second operand\r\n   * @return {Boolean} the direction of v1 and v2\r\n   */\r\n  direction: function direction(v1, v2) {\r\n    return v1[0] * v2[1] - v2[0] * v1[1];\r\n  },\r\n\r\n  /**\r\n   * Calculates the angle of two vector2's\r\n   *\r\n   * @param {vector2} v1 the first operand\r\n   * @param {vector2} v2 the second operand\r\n   * @return {Number} angle of v1 and v2\r\n   */\r\n  angle: function angle(v1, v2) {\r\n    var theta = this.dot(v1, v2) / (this.length(v1) * this.length(v2));\r\n    return Math.acos(theta);\r\n  },\r\n\r\n  /**\r\n   * Calculates the angle of two vector2's with direction\r\n   *\r\n   * @param {vector2} v1 the first operand\r\n   * @param {vector2} v2 the second operand\r\n   * @param {Boolean} direction the direction of two vector2's\r\n   * @return {Number} angle of v1 and v2\r\n   */\r\n  angleTo: function angleTo(v1, v2, direction) {\r\n    var angle = this.angle(v1, v2);\r\n    var angleLargeThanPI = this.direction(v1, v2) >= 0;\r\n\r\n    if (direction) {\r\n      if (angleLargeThanPI) {\r\n        return Math.PI * 2 - angle;\r\n      }\r\n\r\n      return angle;\r\n    }\r\n\r\n    if (angleLargeThanPI) {\r\n      return angle;\r\n    }\r\n\r\n    return Math.PI * 2 - angle;\r\n  },\r\n\r\n  /**\r\n   * whether a vector2 is zero vector\r\n   *\r\n   * @param  {vector2} v vector to calculate\r\n   * @return {Boolean}   is or not a zero vector\r\n   */\r\n  zero: function zero(v) {\r\n    return v[0] === 0 && v[1] === 0;\r\n  },\r\n\r\n  /**\r\n   * Calculates the euclidian distance between two vector2's\r\n   *\r\n   * @param {vector2} v1 the first operand\r\n   * @param {vector2} v2 the second operand\r\n   * @return {Number} distance between a and b\r\n   */\r\n  distance: function distance(v1, v2) {\r\n    var x = v2[0] - v1[0];\r\n    var y = v2[1] - v1[1];\r\n    return Math.sqrt(x * x + y * y);\r\n  },\r\n\r\n  /**\r\n   * Creates a new vector2 initialized with values from an existing vector\r\n   *\r\n   * @param {vector2} v vector to clone\r\n   * @return {Array} a new 2D vector\r\n   */\r\n  clone: function clone(v) {\r\n    return [v[0], v[1]];\r\n  },\r\n\r\n  /**\r\n   * Return the minimum of two vector2's\r\n   *\r\n   * @param {vector2} out the receiving vector\r\n   * @param {vector2} v1 the first operand\r\n   * @param {vector2} v2 the second operand\r\n   * @return {vector2} out\r\n   */\r\n  min: function min(out, v1, v2) {\r\n    out[0] = Math.min(v1[0], v2[0]);\r\n    out[1] = Math.min(v1[1], v2[1]);\r\n    return out;\r\n  },\r\n\r\n  /**\r\n   * Return the maximum of two vector2's\r\n   *\r\n   * @param {vector2} out the receiving vector\r\n   * @param {vector2} v1 the first operand\r\n   * @param {vector2} v2 the second operand\r\n   * @return {vector2} out\r\n   */\r\n  max: function max(out, v1, v2) {\r\n    out[0] = Math.max(v1[0], v2[0]);\r\n    out[1] = Math.max(v1[1], v2[1]);\r\n    return out;\r\n  },\r\n\r\n  /**\r\n   * Transforms the vector2 with a mat2d\r\n   *\r\n   * @param {vector2} out the receiving vector\r\n   * @param {vector2} v the vector to transform\r\n   * @param {mat2d} m matrix to transform with\r\n   * @return {vector2} out\r\n   */\r\n  transformMat2d: function transformMat2d(out, v, m) {\r\n    var x = v[0];\r\n    var y = v[1];\r\n    out[0] = m[0] * x + m[2] * y + m[4];\r\n    out[1] = m[1] * x + m[3] * y + m[5];\r\n    return out;\r\n  }\r\n};","\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\r\n\r\nvar Base = require('./base');\r\n\r\nvar Cartesian =\r\n/*#__PURE__*/\r\nfunction (_Base) {\r\n  (0, _inheritsLoose2[\"default\"])(Cartesian, _Base);\r\n\r\n  function Cartesian() {\r\n    return _Base.apply(this, arguments) || this;\r\n  }\r\n\r\n  var _proto = Cartesian.prototype;\r\n\r\n  _proto._initDefaultCfg = function _initDefaultCfg() {\r\n    this.type = 'cartesian';\r\n    this.transposed = false;\r\n    this.isRect = true;\r\n  };\r\n\r\n  _proto.init = function init(start, end) {\r\n    _Base.prototype.init.call(this, start, end);\r\n\r\n    this.x = {\r\n      start: start.x,\r\n      end: end.x\r\n    };\r\n    this.y = {\r\n      start: start.y,\r\n      end: end.y\r\n    };\r\n  };\r\n\r\n  _proto._convertPoint = function _convertPoint(point) {\r\n    var self = this;\r\n    var transposed = self.transposed;\r\n    var xDim = transposed ? 'y' : 'x';\r\n    var yDim = transposed ? 'x' : 'y';\r\n    var x = self.x;\r\n    var y = self.y;\r\n    return {\r\n      x: x.start + (x.end - x.start) * point[xDim],\r\n      y: y.start + (y.end - y.start) * point[yDim]\r\n    };\r\n  };\r\n\r\n  _proto._invertPoint = function _invertPoint(point) {\r\n    var self = this;\r\n    var transposed = self.transposed;\r\n    var xDim = transposed ? 'y' : 'x';\r\n    var yDim = transposed ? 'x' : 'y';\r\n    var x = self.x;\r\n    var y = self.y;\r\n    var rst = {};\r\n    rst[xDim] = (point.x - x.start) / (x.end - x.start);\r\n    rst[yDim] = (point.y - y.start) / (y.end - y.start);\r\n    return rst;\r\n  };\r\n\r\n  return Cartesian;\r\n}(Base);\r\n\r\nBase.Cartesian = Cartesian;\r\nBase.Rect = Cartesian;\r\nmodule.exports = Cartesian;","\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\r\n\r\nvar Util = require('../util/common');\r\n\r\nvar Base = require('../base');\r\n\r\nvar GROUP_ATTRS = ['color', 'size', 'shape'];\r\nvar FIELD_ORIGIN = '_origin';\r\nvar FIELD_ORIGIN_Y = '_originY';\r\n\r\nvar Global = require('../global');\r\n\r\nvar Attr = require('../attr/index');\r\n\r\nvar GeometryShape = require('./shape/shape');\r\n\r\nvar Adjust = require('@antv/adjust/lib/base');\r\n\r\nfunction parseFields(field) {\r\n  if (Util.isArray(field)) {\r\n    return field;\r\n  }\r\n\r\n  if (Util.isString(field)) {\r\n    return field.split('*');\r\n  }\r\n\r\n  return [field];\r\n}\r\n/**\r\n * The parent class for Geometry\r\n * @class Geom\r\n */\r\n\r\n\r\nvar Geom =\r\n/*#__PURE__*/\r\nfunction (_Base) {\r\n  (0, _inheritsLoose2[\"default\"])(Geom, _Base);\r\n\r\n  function Geom() {\r\n    return _Base.apply(this, arguments) || this;\r\n  }\r\n\r\n  var _proto = Geom.prototype;\r\n\r\n  _proto.getDefaultCfg = function getDefaultCfg() {\r\n    return {\r\n      /**\r\n       * geometry type\r\n       * @type {String}\r\n       */\r\n      type: null,\r\n\r\n      /**\r\n       * the data of geometry\r\n       * @type {Array}\r\n       */\r\n      data: null,\r\n\r\n      /**\r\n       * the attrs of geo,etry\r\n       * @type {Object}\r\n       */\r\n      attrs: {},\r\n      scales: {},\r\n\r\n      /**\r\n       * group for storing the shapes\r\n       * @type {Canvas}\r\n       */\r\n      container: null,\r\n\r\n      /**\r\n       * style options\r\n       * @type {Object}\r\n       */\r\n      styleOptions: null,\r\n      chart: null,\r\n      shapeType: '',\r\n\r\n      /**\r\n       * wether to generate key points for each shape\r\n       * @protected\r\n       * @type {Boolean}\r\n       */\r\n      generatePoints: false,\r\n      attrOptions: {},\r\n      sortable: false,\r\n      startOnZero: true,\r\n      visible: true,\r\n      connectNulls: false,\r\n      // 是否丢弃没有值的分组。\r\n      ignoreEmptyGroup: false\r\n    };\r\n  };\r\n\r\n  _proto.init = function init() {\r\n    var self = this;\r\n\r\n    self._initAttrs();\r\n\r\n    var dataArray = self._processData();\r\n\r\n    if (self.get('adjust')) {\r\n      self._adjustData(dataArray);\r\n    }\r\n\r\n    self.set('dataArray', dataArray);\r\n  };\r\n\r\n  _proto._getGroupScales = function _getGroupScales() {\r\n    var self = this;\r\n    var scales = [];\r\n    Util.each(GROUP_ATTRS, function (attrName) {\r\n      var attr = self.getAttr(attrName);\r\n\r\n      if (attr) {\r\n        var attrScales = attr.scales;\r\n        Util.each(attrScales, function (scale) {\r\n          if (scale && scale.isCategory && scales.indexOf(scale) === -1) {\r\n            scales.push(scale);\r\n          }\r\n        });\r\n      }\r\n    });\r\n    return scales;\r\n  };\r\n\r\n  _proto._groupData = function _groupData(data) {\r\n    var self = this;\r\n    var colDefs = self.get('colDefs');\r\n\r\n    var groupScales = self._getGroupScales();\r\n\r\n    if (groupScales.length) {\r\n      var appendConditions = {};\r\n      var names = [];\r\n      Util.each(groupScales, function (scale) {\r\n        var field = scale.field;\r\n        names.push(field);\r\n\r\n        if (colDefs && colDefs[field] && colDefs[field].values) {\r\n          // users have defined\r\n          appendConditions[scale.field] = colDefs[field].values;\r\n        }\r\n      });\r\n      return Util.Array.group(data, names, appendConditions);\r\n    }\r\n\r\n    return [data];\r\n  };\r\n\r\n  _proto._setAttrOptions = function _setAttrOptions(attrName, attrCfg) {\r\n    var options = this.get('attrOptions');\r\n    options[attrName] = attrCfg;\r\n  };\r\n\r\n  _proto._createAttrOption = function _createAttrOption(attrName, field, cfg, defaultValues) {\r\n    var attrCfg = {};\r\n    attrCfg.field = field;\r\n\r\n    if (cfg) {\r\n      if (Util.isFunction(cfg)) {\r\n        attrCfg.callback = cfg;\r\n      } else {\r\n        attrCfg.values = cfg;\r\n      }\r\n    } else {\r\n      attrCfg.values = defaultValues;\r\n    }\r\n\r\n    this._setAttrOptions(attrName, attrCfg);\r\n  };\r\n\r\n  _proto._initAttrs = function _initAttrs() {\r\n    var self = this;\r\n    var attrs = self.get('attrs');\r\n    var attrOptions = self.get('attrOptions');\r\n    var coord = self.get('coord');\r\n\r\n    for (var type in attrOptions) {\r\n      if (attrOptions.hasOwnProperty(type)) {\r\n        var option = attrOptions[type];\r\n        var className = Util.upperFirst(type);\r\n        var fields = parseFields(option.field);\r\n\r\n        if (type === 'position') {\r\n          option.coord = coord;\r\n        }\r\n\r\n        var scales = [];\r\n\r\n        for (var i = 0, len = fields.length; i < len; i++) {\r\n          var field = fields[i];\r\n\r\n          var scale = self._createScale(field);\r\n\r\n          scales.push(scale);\r\n        }\r\n\r\n        if (type === 'position') {\r\n          var yScale = scales[1];\r\n\r\n          if (coord.type === 'polar' && coord.transposed && self.hasAdjust('stack')) {\r\n            if (yScale.values.length) {\r\n              yScale.change({\r\n                nice: false,\r\n                min: 0,\r\n                max: Math.max.apply(null, yScale.values)\r\n              });\r\n            }\r\n          }\r\n        }\r\n\r\n        option.scales = scales;\r\n        var attr = new Attr[className](option);\r\n        attrs[type] = attr;\r\n      }\r\n    }\r\n  };\r\n\r\n  _proto._createScale = function _createScale(field) {\r\n    var scales = this.get('scales');\r\n    var scale = scales[field];\r\n\r\n    if (!scale) {\r\n      scale = this.get('chart').createScale(field);\r\n      scales[field] = scale;\r\n    }\r\n\r\n    return scale;\r\n  };\r\n\r\n  _proto._processData = function _processData() {\r\n    var self = this;\r\n    var data = this.get('data');\r\n    var dataArray = [];\r\n\r\n    var groupedArray = this._groupData(data);\r\n\r\n    if (this.get('ignoreEmptyGroup')) {\r\n      var yScale = this.getYScale();\r\n      groupedArray = groupedArray.filter(function (group) {\r\n        return group.some(function (item) {\r\n          return typeof item[yScale.field] !== 'undefined';\r\n        });\r\n      });\r\n    }\r\n\r\n    for (var i = 0, len = groupedArray.length; i < len; i++) {\r\n      var subData = groupedArray[i];\r\n\r\n      var tempData = self._saveOrigin(subData);\r\n\r\n      if (this.hasAdjust('dodge')) {\r\n        self._numberic(tempData);\r\n      }\r\n\r\n      dataArray.push(tempData);\r\n    }\r\n\r\n    return dataArray;\r\n  };\r\n\r\n  _proto._saveOrigin = function _saveOrigin(data) {\r\n    var rst = [];\r\n\r\n    for (var i = 0, len = data.length; i < len; i++) {\r\n      var origin = data[i];\r\n      var obj = {};\r\n\r\n      for (var k in origin) {\r\n        obj[k] = origin[k];\r\n      }\r\n\r\n      obj[FIELD_ORIGIN] = origin;\r\n      rst.push(obj);\r\n    }\r\n\r\n    return rst;\r\n  };\r\n\r\n  _proto._numberic = function _numberic(data) {\r\n    var positionAttr = this.getAttr('position');\r\n    var scales = positionAttr.scales;\r\n\r\n    for (var j = 0, len = data.length; j < len; j++) {\r\n      var obj = data[j];\r\n      var count = Math.min(2, scales.length);\r\n\r\n      for (var i = 0; i < count; i++) {\r\n        var scale = scales[i];\r\n\r\n        if (scale.isCategory) {\r\n          var field = scale.field;\r\n          obj[field] = scale.translate(obj[field]);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  _proto._adjustData = function _adjustData(dataArray) {\r\n    var self = this;\r\n    var adjust = self.get('adjust');\r\n\r\n    if (adjust) {\r\n      var adjustType = Util.upperFirst(adjust.type);\r\n\r\n      if (!Adjust[adjustType]) {\r\n        throw new Error('not support such adjust : ' + adjust);\r\n      }\r\n\r\n      var xScale = self.getXScale();\r\n      var yScale = self.getYScale();\r\n      var cfg = Util.mix({\r\n        xField: xScale.field,\r\n        yField: yScale.field\r\n      }, adjust);\r\n      var adjustObject = new Adjust[adjustType](cfg);\r\n      adjustObject.processAdjust(dataArray);\r\n\r\n      if (adjustType === 'Stack') {\r\n        self._updateStackRange(yScale.field, yScale, dataArray);\r\n      }\r\n    }\r\n  };\r\n\r\n  _proto._updateStackRange = function _updateStackRange(field, scale, dataArray) {\r\n    var mergeArray = Util.Array.merge(dataArray);\r\n    var min = scale.min;\r\n    var max = scale.max;\r\n\r\n    for (var i = 0, len = mergeArray.length; i < len; i++) {\r\n      var obj = mergeArray[i];\r\n      var tmpMin = Math.min.apply(null, obj[field]);\r\n      var tmpMax = Math.max.apply(null, obj[field]);\r\n\r\n      if (tmpMin < min) {\r\n        min = tmpMin;\r\n      }\r\n\r\n      if (tmpMax > max) {\r\n        max = tmpMax;\r\n      }\r\n    }\r\n\r\n    if (min < scale.min || max > scale.max) {\r\n      scale.change({\r\n        min: min,\r\n        max: max\r\n      });\r\n    }\r\n  };\r\n\r\n  _proto._sort = function _sort(mappedArray) {\r\n    var self = this;\r\n    var xScale = self.getXScale();\r\n    var field = xScale.field,\r\n        type = xScale.type;\r\n\r\n    if (type !== 'identity' && xScale.values.length > 1) {\r\n      Util.each(mappedArray, function (itemArr) {\r\n        itemArr.sort(function (obj1, obj2) {\r\n          if (type === 'timeCat') {\r\n            return xScale._toTimeStamp(obj1[FIELD_ORIGIN][field]) - xScale._toTimeStamp(obj2[FIELD_ORIGIN][field]);\r\n          }\r\n\r\n          return xScale.translate(obj1[FIELD_ORIGIN][field]) - xScale.translate(obj2[FIELD_ORIGIN][field]);\r\n        });\r\n      });\r\n    }\r\n\r\n    self.set('hasSorted', true);\r\n    self.set('dataArray', mappedArray);\r\n  };\r\n\r\n  _proto.paint = function paint() {\r\n    var self = this;\r\n    var dataArray = self.get('dataArray');\r\n    var mappedArray = [];\r\n    var shapeFactory = self.getShapeFactory();\r\n    shapeFactory.setCoord(self.get('coord'));\r\n\r\n    self._beforeMapping(dataArray);\r\n\r\n    for (var i = 0, len = dataArray.length; i < len; i++) {\r\n      var data = dataArray[i];\r\n\r\n      if (data.length) {\r\n        data = self._mapping(data);\r\n        mappedArray.push(data);\r\n        self.draw(data, shapeFactory);\r\n      }\r\n    }\r\n\r\n    self.set('dataArray', mappedArray);\r\n  };\r\n\r\n  _proto.getShapeFactory = function getShapeFactory() {\r\n    var shapeFactory = this.get('shapeFactory');\r\n\r\n    if (!shapeFactory) {\r\n      var shapeType = this.get('shapeType');\r\n      shapeFactory = GeometryShape.getShapeFactory(shapeType);\r\n      this.set('shapeFactory', shapeFactory);\r\n    }\r\n\r\n    return shapeFactory;\r\n  };\r\n\r\n  _proto._mapping = function _mapping(data) {\r\n    var self = this;\r\n    var attrs = self.get('attrs');\r\n    var yField = self.getYScale().field;\r\n    var mappedData = [];\r\n\r\n    for (var i = 0, len = data.length; i < len; i++) {\r\n      var record = data[i];\r\n      var newRecord = {};\r\n      newRecord[FIELD_ORIGIN] = record[FIELD_ORIGIN];\r\n      newRecord.points = record.points;\r\n      newRecord.nextPoints = record.nextPoints; // 避免\r\n\r\n      newRecord[FIELD_ORIGIN_Y] = record[yField];\r\n\r\n      for (var k in attrs) {\r\n        if (attrs.hasOwnProperty(k)) {\r\n          var attr = attrs[k];\r\n          var names = attr.names;\r\n\r\n          var values = self._getAttrValues(attr, record);\r\n\r\n          if (names.length > 1) {\r\n            for (var j = 0, _len = values.length; j < _len; j++) {\r\n              var val = values[j];\r\n              var name = names[j];\r\n              newRecord[name] = Util.isArray(val) && val.length === 1 ? val[0] : val;\r\n            }\r\n          } else {\r\n            newRecord[names[0]] = values.length === 1 ? values[0] : values;\r\n          }\r\n        }\r\n      }\r\n\r\n      mappedData.push(newRecord);\r\n    }\r\n\r\n    return mappedData;\r\n  };\r\n\r\n  _proto._getAttrValues = function _getAttrValues(attr, record) {\r\n    var scales = attr.scales;\r\n    var params = [];\r\n\r\n    for (var i = 0, len = scales.length; i < len; i++) {\r\n      var scale = scales[i];\r\n      var field = scale.field;\r\n\r\n      if (scale.type === 'identity') {\r\n        params.push(scale.value);\r\n      } else {\r\n        params.push(record[field]);\r\n      }\r\n    }\r\n\r\n    var values = attr.mapping.apply(attr, params);\r\n    return values;\r\n  };\r\n\r\n  _proto.getAttrValue = function getAttrValue(attrName, record) {\r\n    var attr = this.getAttr(attrName);\r\n    var rst = null;\r\n\r\n    if (attr) {\r\n      var values = this._getAttrValues(attr, record);\r\n\r\n      rst = values[0];\r\n    }\r\n\r\n    return rst;\r\n  };\r\n\r\n  _proto._beforeMapping = function _beforeMapping(dataArray) {\r\n    var self = this;\r\n\r\n    if (self.get('sortable')) {\r\n      self._sort(dataArray);\r\n    }\r\n\r\n    if (self.get('generatePoints')) {\r\n      Util.each(dataArray, function (data) {\r\n        self._generatePoints(data);\r\n      }); // 添加nextPoints\r\n\r\n      Util.each(dataArray, function (data, index) {\r\n        var nextData = dataArray[index + 1];\r\n\r\n        if (nextData) {\r\n          data[0].nextPoints = nextData[0].points;\r\n        }\r\n      });\r\n    }\r\n  };\r\n\r\n  _proto.isInCircle = function isInCircle() {\r\n    var coord = this.get('coord');\r\n    return coord && coord.isPolar;\r\n  };\r\n\r\n  _proto.getCallbackCfg = function getCallbackCfg(fields, cfg, origin) {\r\n    if (!fields) {\r\n      return cfg;\r\n    }\r\n\r\n    var tmpCfg = {};\r\n    var params = fields.map(function (field) {\r\n      return origin[field];\r\n    });\r\n    Util.each(cfg, function (v, k) {\r\n      if (Util.isFunction(v)) {\r\n        tmpCfg[k] = v.apply(null, params);\r\n      } else {\r\n        tmpCfg[k] = v;\r\n      }\r\n    });\r\n    return tmpCfg;\r\n  };\r\n\r\n  _proto.getDrawCfg = function getDrawCfg(obj) {\r\n    var self = this;\r\n    var isInCircle = self.isInCircle();\r\n    var cfg = {\r\n      origin: obj,\r\n      x: obj.x,\r\n      y: obj.y,\r\n      color: obj.color,\r\n      size: obj.size,\r\n      shape: obj.shape,\r\n      isInCircle: isInCircle,\r\n      opacity: obj.opacity\r\n    };\r\n    var styleOptions = self.get('styleOptions');\r\n\r\n    if (styleOptions && styleOptions.style) {\r\n      cfg.style = self.getCallbackCfg(styleOptions.fields, styleOptions.style, obj[FIELD_ORIGIN]);\r\n    }\r\n\r\n    if (self.get('generatePoints')) {\r\n      cfg.points = obj.points;\r\n      cfg.nextPoints = obj.nextPoints;\r\n    }\r\n\r\n    if (isInCircle) {\r\n      cfg.center = self.get('coord').center;\r\n    }\r\n\r\n    return cfg;\r\n  };\r\n\r\n  _proto.draw = function draw(data, shapeFactory) {\r\n    var self = this;\r\n    var container = self.get('container');\r\n    var yScale = self.getYScale();\r\n    Util.each(data, function (obj, index) {\r\n      if (yScale && Util.isNil(obj._origin[yScale.field])) {\r\n        return;\r\n      }\r\n\r\n      obj.index = index;\r\n      var cfg = self.getDrawCfg(obj);\r\n      var shape = obj.shape;\r\n      self.drawShape(shape, obj, cfg, container, shapeFactory);\r\n    });\r\n  };\r\n\r\n  _proto.drawShape = function drawShape(shape, shapeData, cfg, container, shapeFactory) {\r\n    var gShape = shapeFactory.drawShape(shape, cfg, container);\r\n\r\n    if (gShape) {\r\n      Util.each([].concat(gShape), function (s) {\r\n        s.set('origin', shapeData);\r\n      });\r\n    }\r\n  };\r\n\r\n  _proto._generatePoints = function _generatePoints(data) {\r\n    var self = this;\r\n    var shapeFactory = self.getShapeFactory();\r\n    var shapeAttr = self.getAttr('shape');\r\n\r\n    for (var i = 0, len = data.length; i < len; i++) {\r\n      var obj = data[i];\r\n      var cfg = self.createShapePointsCfg(obj);\r\n      var shape = shapeAttr ? self._getAttrValues(shapeAttr, obj) : null;\r\n      var points = shapeFactory.getShapePoints(shape, cfg);\r\n      obj.points = points;\r\n    }\r\n  }\r\n  /**\r\n   * get the info of each shape\r\n   * @protected\r\n   * @param  {Object} obj the data item\r\n   * @return {Object} cfg return the result\r\n   */\r\n  ;\r\n\r\n  _proto.createShapePointsCfg = function createShapePointsCfg(obj) {\r\n    var xScale = this.getXScale();\r\n    var yScale = this.getYScale();\r\n\r\n    var x = this._normalizeValues(obj[xScale.field], xScale);\r\n\r\n    var y;\r\n\r\n    if (yScale) {\r\n      y = this._normalizeValues(obj[yScale.field], yScale);\r\n    } else {\r\n      y = obj.y ? obj.y : 0.1;\r\n    }\r\n\r\n    return {\r\n      x: x,\r\n      y: y,\r\n      y0: yScale ? yScale.scale(this.getYMinValue()) : undefined\r\n    };\r\n  };\r\n\r\n  _proto.getYMinValue = function getYMinValue() {\r\n    var yScale = this.getYScale();\r\n    var min = yScale.min,\r\n        max = yScale.max;\r\n    var value;\r\n\r\n    if (this.get('startOnZero')) {\r\n      if (max <= 0 && min <= 0) {\r\n        value = max;\r\n      } else {\r\n        value = min >= 0 ? min : 0;\r\n      }\r\n    } else {\r\n      value = min;\r\n    }\r\n\r\n    return value;\r\n  };\r\n\r\n  _proto._normalizeValues = function _normalizeValues(values, scale) {\r\n    var rst = [];\r\n\r\n    if (Util.isArray(values)) {\r\n      for (var i = 0, len = values.length; i < len; i++) {\r\n        var v = values[i];\r\n        rst.push(scale.scale(v));\r\n      }\r\n    } else {\r\n      rst = scale.scale(values);\r\n    }\r\n\r\n    return rst;\r\n  };\r\n\r\n  _proto.getAttr = function getAttr(name) {\r\n    return this.get('attrs')[name];\r\n  };\r\n\r\n  _proto.getXScale = function getXScale() {\r\n    return this.getAttr('position').scales[0];\r\n  };\r\n\r\n  _proto.getYScale = function getYScale() {\r\n    return this.getAttr('position').scales[1];\r\n  };\r\n\r\n  _proto.hasAdjust = function hasAdjust(adjust) {\r\n    return this.get('adjust') && this.get('adjust').type === adjust;\r\n  };\r\n\r\n  _proto._getSnap = function _getSnap(scale, item, arr) {\r\n    var i = 0;\r\n    var values;\r\n    var yField = this.getYScale().field; // 叠加的维度\r\n\r\n    if (this.hasAdjust('stack') && scale.field === yField) {\r\n      values = [];\r\n      arr.forEach(function (obj) {\r\n        values.push(obj[FIELD_ORIGIN_Y]);\r\n      });\r\n\r\n      for (var len = values.length; i < len; i++) {\r\n        if (values[0][0] > item) {\r\n          break;\r\n        }\r\n\r\n        if (values[values.length - 1][1] <= item) {\r\n          i = values.length - 1;\r\n          break;\r\n        }\r\n\r\n        if (values[i][0] <= item && values[i][1] > item) {\r\n          break;\r\n        }\r\n      }\r\n    } else {\r\n      values = scale.values;\r\n      values.sort(function (a, b) {\r\n        return a - b;\r\n      });\r\n\r\n      for (var _len2 = values.length; i < _len2; i++) {\r\n        // 如果只有1个点直接返回第1个点\r\n        if (_len2 <= 1) {\r\n          break;\r\n        } // 第1个点和第2个点之间\r\n\r\n\r\n        if ((values[0] + values[1]) / 2 > item) {\r\n          break;\r\n        } // 中间的点\r\n\r\n\r\n        if ((values[i - 1] + values[i]) / 2 <= item && (values[i + 1] + values[i]) / 2 > item) {\r\n          break;\r\n        } // 最后2个点\r\n\r\n\r\n        if ((values[values.length - 2] + values[values.length - 1]) / 2 <= item) {\r\n          i = values.length - 1;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    var result = values[i];\r\n    return result;\r\n  };\r\n\r\n  _proto.getSnapRecords = function getSnapRecords(point) {\r\n    var self = this;\r\n    var coord = self.get('coord');\r\n    var xScale = self.getXScale();\r\n    var yScale = self.getYScale();\r\n    var xfield = xScale.field;\r\n    var dataArray = self.get('dataArray');\r\n\r\n    if (!this.get('hasSorted')) {\r\n      this._sort(dataArray);\r\n    }\r\n\r\n    var rst = [];\r\n    var invertPoint = coord.invertPoint(point);\r\n    var invertPointX = invertPoint.x;\r\n\r\n    if (self.isInCircle() && !coord.transposed && invertPointX > (1 + xScale.rangeMax()) / 2) {\r\n      invertPointX = xScale.rangeMin();\r\n    }\r\n\r\n    var xValue = xScale.invert(invertPointX);\r\n\r\n    if (!xScale.isCategory) {\r\n      xValue = self._getSnap(xScale, xValue);\r\n    }\r\n\r\n    var tmp = [];\r\n    dataArray.forEach(function (data) {\r\n      data.forEach(function (obj) {\r\n        var originValue = Util.isNil(obj[FIELD_ORIGIN]) ? obj[xfield] : obj[FIELD_ORIGIN][xfield];\r\n\r\n        if (self._isEqual(originValue, xValue, xScale)) {\r\n          tmp.push(obj);\r\n        }\r\n      });\r\n    }); // special for pie chart\r\n\r\n    if (this.hasAdjust('stack') && coord.isPolar && coord.transposed) {\r\n      if (invertPointX >= 0 && invertPointX <= 1) {\r\n        var yValue = yScale.invert(invertPoint.y);\r\n        yValue = self._getSnap(yScale, yValue, tmp);\r\n        tmp.forEach(function (obj) {\r\n          if (Util.isArray(yValue) ? obj[FIELD_ORIGIN_Y].toString() === yValue.toString() : obj[FIELD_ORIGIN_Y] === yValue) {\r\n            rst.push(obj);\r\n          }\r\n        });\r\n      }\r\n    } else {\r\n      rst = tmp;\r\n    }\r\n\r\n    return rst;\r\n  };\r\n\r\n  _proto._isEqual = function _isEqual(originValue, value, scale) {\r\n    if (scale.type === 'timeCat') {\r\n      return scale._toTimeStamp(originValue) === value;\r\n    }\r\n\r\n    return value === originValue;\r\n  };\r\n\r\n  _proto.position = function position(field) {\r\n    this._setAttrOptions('position', {\r\n      field: field\r\n    });\r\n\r\n    return this;\r\n  };\r\n\r\n  _proto.color = function color(field, values) {\r\n    this._createAttrOption('color', field, values, Global.colors);\r\n\r\n    return this;\r\n  };\r\n\r\n  _proto.size = function size(field, values) {\r\n    this._createAttrOption('size', field, values, Global.sizes);\r\n\r\n    return this;\r\n  };\r\n\r\n  _proto.shape = function shape(field, values) {\r\n    var type = this.get('type');\r\n    var shapes = Global.shapes[type] || [];\r\n\r\n    this._createAttrOption('shape', field, values, shapes);\r\n\r\n    return this;\r\n  };\r\n\r\n  _proto.style = function style(field, cfg) {\r\n    var styleOptions = this.get('styleOptions');\r\n\r\n    if (!styleOptions) {\r\n      styleOptions = {};\r\n      this.set('styleOptions', styleOptions);\r\n    }\r\n\r\n    if (Util.isObject(field)) {\r\n      cfg = field;\r\n      field = null;\r\n    }\r\n\r\n    var fields;\r\n\r\n    if (field) {\r\n      fields = parseFields(field);\r\n    }\r\n\r\n    styleOptions.fields = fields;\r\n    styleOptions.style = cfg;\r\n    return this;\r\n  };\r\n\r\n  _proto.adjust = function adjust(type) {\r\n    if (Util.isString(type)) {\r\n      type = {\r\n        type: type\r\n      };\r\n    }\r\n\r\n    this.set('adjust', type);\r\n    return this;\r\n  };\r\n\r\n  _proto.animate = function animate(cfg) {\r\n    this.set('animateCfg', cfg);\r\n    return this;\r\n  };\r\n\r\n  _proto.reset = function reset() {\r\n    this.set('attrOptions', {});\r\n    this.set('adjust', null);\r\n    this.clearInner();\r\n  };\r\n\r\n  _proto.clearInner = function clearInner() {\r\n    var container = this.get('container');\r\n\r\n    if (container) {\r\n      container.clear();\r\n      container.setMatrix([1, 0, 0, 1, 0, 0]);\r\n    }\r\n\r\n    container && container.clear();\r\n    this.set('attrs', {});\r\n    this.set('groupScales', null);\r\n    this.set('xDistance', null);\r\n    this.set('_width', null);\r\n  };\r\n\r\n  _proto.clear = function clear() {\r\n    this.clearInner();\r\n    this.set('scales', {});\r\n  };\r\n\r\n  _proto.destroy = function destroy() {\r\n    this.clear();\r\n\r\n    _Base.prototype.destroy.call(this);\r\n  };\r\n\r\n  _proto._display = function _display(visible) {\r\n    this.set('visible', visible);\r\n    var container = this.get('container');\r\n    var canvas = container.get('canvas');\r\n    container.set('visible', visible);\r\n    canvas.draw();\r\n  };\r\n\r\n  _proto.show = function show() {\r\n    this._display(true);\r\n  };\r\n\r\n  _proto.hide = function hide() {\r\n    this._display(false);\r\n  };\r\n\r\n  return Geom;\r\n}(Base);\r\n\r\nmodule.exports = Geom;","\r\n\r\nmodule.exports = {\r\n  Position: require('@antv/attr/lib/position'),\r\n  Shape: require('@antv/attr/lib/shape'),\r\n  Size: require('@antv/attr/lib/size'),\r\n  Color: require('./color')\r\n};","\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\r\n\r\nvar Util = require('../util/common');\r\n\r\nvar ColorUtil = require('./color-util');\r\n\r\nvar Base = require('@antv/attr/lib/base');\r\n\r\nvar Color =\r\n/*#__PURE__*/\r\nfunction (_Base) {\r\n  (0, _inheritsLoose2[\"default\"])(Color, _Base);\r\n\r\n  function Color(cfg) {\r\n    var _this;\r\n\r\n    _this = _Base.call(this, cfg) || this;\r\n    _this.names = ['color'];\r\n    _this.type = 'color';\r\n    _this.gradient = null;\r\n\r\n    if (Util.isString(_this.values)) {\r\n      _this.linear = true;\r\n    }\r\n\r\n    return _this;\r\n  }\r\n  /**\r\n   * @override\r\n   */\r\n\r\n\r\n  var _proto = Color.prototype;\r\n\r\n  _proto.getLinearValue = function getLinearValue(percent) {\r\n    var gradient = this.gradient;\r\n\r\n    if (!gradient) {\r\n      var values = this.values;\r\n      gradient = ColorUtil.gradient(values);\r\n      this.gradient = gradient;\r\n    }\r\n\r\n    return gradient(percent);\r\n  };\r\n\r\n  return Color;\r\n}(Base);\r\n\r\nmodule.exports = Color;","\r\n\r\nvar Util = require('../util/common'); // Get the interpolation between colors\r\n\r\n\r\nfunction getValue(start, end, percent, index) {\r\n  var value = start[index] + (end[index] - start[index]) * percent;\r\n  return value;\r\n} // convert to hex\r\n\r\n\r\nfunction arr2hex(arr) {\r\n  return '#' + toRGBValue(arr[0]) + toRGBValue(arr[1]) + toRGBValue(arr[2]);\r\n}\r\n\r\nfunction toRGBValue(value) {\r\n  value = Math.round(value);\r\n  value = value.toString(16);\r\n\r\n  if (value.length === 1) {\r\n    value = '0' + value;\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\nfunction calColor(colors, percent) {\r\n  var steps = colors.length - 1;\r\n  var step = Math.floor(steps * percent);\r\n  var left = steps * percent - step;\r\n  var start = colors[step];\r\n  var end = step === steps ? start : colors[step + 1];\r\n  var rgb = arr2hex([getValue(start, end, left, 0), getValue(start, end, left, 1), getValue(start, end, left, 2)]);\r\n  return rgb;\r\n}\r\n\r\nfunction hex2arr(str) {\r\n  var arr = [];\r\n  arr.push(parseInt(str.substr(1, 2), 16));\r\n  arr.push(parseInt(str.substr(3, 2), 16));\r\n  arr.push(parseInt(str.substr(5, 2), 16));\r\n  return arr;\r\n}\r\n\r\nvar colorCache = {\r\n  black: '#000000',\r\n  blue: '#0000ff',\r\n  grey: '#808080',\r\n  green: '#008000',\r\n  orange: '#ffa500',\r\n  pink: '#ffc0cb',\r\n  purple: '#800080',\r\n  red: '#ff0000',\r\n  white: '#ffffff',\r\n  yellow: '#ffff00'\r\n};\r\nvar ColorUtil = {\r\n  /**\r\n   * Returns a hexadecimal string representing this color in RGB space, such as #f7eaba.\r\n   * @param  {String} color color value\r\n   * @return {String} Returns a hexadecimal string\r\n   */\r\n  toHex: function toHex(color) {\r\n    if (colorCache[color]) {\r\n      return colorCache[color];\r\n    }\r\n\r\n    if (color[0] === '#') {\r\n      if (color.length === 7) {\r\n        return color;\r\n      }\r\n\r\n      var hex = color.replace(/^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i, function (m, r, g, b) {\r\n        return '#' + r + r + g + g + b + b;\r\n      }); // hex3 to hex6\r\n\r\n      colorCache[color] = hex;\r\n      return hex;\r\n    } // rgb/rgba to hex\r\n\r\n\r\n    var rst = color.match(/^rgba?[\\s+]?\\([\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?/i);\r\n    rst.shift();\r\n    rst = arr2hex(rst);\r\n    colorCache[color] = rst;\r\n    return rst;\r\n  },\r\n  hex2arr: hex2arr,\r\n\r\n  /**\r\n   * handle the gradient color\r\n   * @param  {Array} colors the colors\r\n   * @return {String} return the color value\r\n   */\r\n  gradient: function gradient(colors) {\r\n    var points = [];\r\n\r\n    if (Util.isString(colors)) {\r\n      colors = colors.split('-');\r\n    }\r\n\r\n    Util.each(colors, function (color) {\r\n      if (color.indexOf('#') === -1) {\r\n        color = ColorUtil.toHex(color);\r\n      }\r\n\r\n      points.push(hex2arr(color));\r\n    });\r\n    return function (percent) {\r\n      return calColor(points, percent);\r\n    };\r\n  }\r\n};\r\nmodule.exports = ColorUtil;","\r\n\r\nvar Util = require('../../util/common');\r\n\r\nvar Global = require('../../global');\r\n\r\nvar Shape = {};\r\nvar ShapeBase = {\r\n  _coord: null,\r\n\r\n  /**\r\n   * draw the shape\r\n   * @param {Object} cfg options\r\n   * @param {Object} container container to store the shapes\r\n   */\r\n  draw: function draw(cfg, container) {\r\n    if (this.drawShape) {\r\n      this.drawShape(cfg, container);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * set the coordinate instance\r\n   * @param {Coord} coord coordinate instance\r\n   */\r\n  setCoord: function setCoord(coord) {\r\n    this._coord = coord;\r\n  },\r\n\r\n  /**\r\n   * convert the normalized value to the canvas position\r\n   * @param  {point} point the point to convert\r\n   * @return {point} point return the result\r\n   */\r\n  parsePoint: function parsePoint(point) {\r\n    var coord = this._coord;\r\n\r\n    if (coord.isPolar) {\r\n      if (point.x === 1) point.x = 0.9999999;\r\n      if (point.y === 1) point.y = 0.9999999;\r\n    }\r\n\r\n    return coord.convertPoint(point);\r\n  },\r\n\r\n  /**\r\n   * convert the normalized value to the canvas position\r\n   * @param  {points} points the array that store the points\r\n   * @return {points} points return the result\r\n   */\r\n  parsePoints: function parsePoints(points) {\r\n    if (!points) return false;\r\n    var self = this;\r\n    var rst = [];\r\n    points.forEach(function (point) {\r\n      rst.push(self.parsePoint(point));\r\n    });\r\n    return rst;\r\n  }\r\n};\r\nvar ShapeFactoryBase = {\r\n  defaultShapeType: null,\r\n  setCoord: function setCoord(coord) {\r\n    this._coord = coord;\r\n  },\r\n  getShape: function getShape(type) {\r\n    var self = this;\r\n\r\n    if (Util.isArray(type)) {\r\n      type = type[0];\r\n    }\r\n\r\n    var shape = self[type] || self[self.defaultShapeType];\r\n    shape._coord = self._coord;\r\n    return shape;\r\n  },\r\n  getShapePoints: function getShapePoints(type, cfg) {\r\n    var shape = this.getShape(type);\r\n    var fn = shape.getPoints || shape.getShapePoints || this.getDefaultPoints;\r\n    var points = fn(cfg);\r\n    return points;\r\n  },\r\n  getDefaultPoints: function getDefaultPoints()\r\n  /* cfg */\r\n  {\r\n    return [];\r\n  },\r\n  drawShape: function drawShape(type, cfg, container) {\r\n    var shape = this.getShape(type);\r\n\r\n    if (!cfg.color) {\r\n      cfg.color = Global.colors[0];\r\n    }\r\n\r\n    return shape.draw(cfg, container);\r\n  }\r\n};\r\n\r\nShape.registerFactory = function (factoryName, cfg) {\r\n  var className = Util.upperFirst(factoryName);\r\n  var geomObj = Util.mix({}, ShapeFactoryBase, cfg);\r\n  Shape[className] = geomObj;\r\n  geomObj.name = factoryName;\r\n  return geomObj;\r\n};\r\n\r\nShape.registerShape = function (factoryName, shapeType, cfg) {\r\n  var className = Util.upperFirst(factoryName);\r\n  var factory = Shape[className];\r\n  var shapeObj = Util.mix({}, ShapeBase, cfg);\r\n  factory[shapeType] = shapeObj;\r\n  return shapeObj;\r\n};\r\n\r\nShape.registShape = Shape.registerShape;\r\n\r\nShape.getShapeFactory = function (factoryName) {\r\n  var self = this;\r\n  factoryName = factoryName || 'point';\r\n  var className = Util.upperFirst(factoryName);\r\n  return self[className];\r\n};\r\n\r\nmodule.exports = Shape;","\r\n\r\nvar Util = require('../../util/common');\r\n\r\nvar Global = require('../../global');\r\n\r\nvar Scale = require('../../scale/');\r\n\r\nvar SCALE_TYPES_MAP = {\r\n  linear: 'Linear',\r\n  cat: 'Cat',\r\n  timeCat: 'TimeCat',\r\n  identity: 'Identity'\r\n};\r\n\r\nvar ScaleController =\r\n/*#__PURE__*/\r\nfunction () {\r\n  function ScaleController(cfg) {\r\n    // defs 列定义\r\n    this.defs = {};\r\n    Util.mix(this, cfg);\r\n  }\r\n\r\n  var _proto = ScaleController.prototype;\r\n\r\n  _proto._getDef = function _getDef(field) {\r\n    var defs = this.defs;\r\n    var def = null;\r\n\r\n    if (Global.scales[field] || defs[field]) {\r\n      def = Util.mix({}, Global.scales[field]);\r\n      Util.each(defs[field], function (v, k) {\r\n        if (Util.isNil(v)) {\r\n          delete def[k];\r\n        } else {\r\n          def[k] = v;\r\n        }\r\n      });\r\n    }\r\n\r\n    return def;\r\n  };\r\n\r\n  _proto._getDefaultType = function _getDefaultType(field, data, def) {\r\n    if (def && def.type) {\r\n      return def.type;\r\n    }\r\n\r\n    var type = 'linear';\r\n    var value = Util.Array.firstValue(data, field);\r\n\r\n    if (Util.isArray(value)) {\r\n      value = value[0];\r\n    }\r\n\r\n    if (Util.isString(value)) {\r\n      type = 'cat';\r\n    }\r\n\r\n    return type;\r\n  };\r\n\r\n  _proto._getScaleCfg = function _getScaleCfg(type, field, data, def) {\r\n    var values;\r\n\r\n    if (def && def.values) {\r\n      values = def.values;\r\n    } else {\r\n      values = Util.Array.values(data, field);\r\n    }\r\n\r\n    var cfg = {\r\n      field: field,\r\n      values: values\r\n    };\r\n\r\n    if (type !== 'cat' && type !== 'timeCat') {\r\n      if (!def || !(def.min && def.max)) {\r\n        var _Util$Array$getRange = Util.Array.getRange(values),\r\n            min = _Util$Array$getRange.min,\r\n            max = _Util$Array$getRange.max;\r\n\r\n        cfg.min = min;\r\n        cfg.max = max;\r\n        cfg.nice = true;\r\n      }\r\n    } else {\r\n      cfg.isRounding = false; // used for tickCount calculation\r\n    }\r\n\r\n    return cfg;\r\n  };\r\n\r\n  _proto.createScale = function createScale(field, data) {\r\n    var self = this;\r\n\r\n    var def = self._getDef(field);\r\n\r\n    var scale;\r\n\r\n    if (!data || !data.length) {\r\n      if (def && def.type) {\r\n        def.field = field;\r\n        scale = new Scale[SCALE_TYPES_MAP[def.type]](def);\r\n      } else {\r\n        scale = new Scale.Identity({\r\n          value: field,\r\n          field: field.toString(),\r\n          values: [field]\r\n        });\r\n      }\r\n\r\n      return scale;\r\n    }\r\n\r\n    var firstObj = data[0];\r\n    var firstValue = firstObj[field];\r\n\r\n    if (firstValue === null) {\r\n      firstValue = Util.Array.firstValue(data, field);\r\n    }\r\n\r\n    if (Util.isNumber(field) || Util.isNil(firstValue) && !def) {\r\n      scale = new Scale.Identity({\r\n        value: field,\r\n        field: field.toString(),\r\n        values: [field]\r\n      });\r\n    } else {\r\n      var type = self._getDefaultType(field, data, def);\r\n\r\n      var cfg = self._getScaleCfg(type, field, data, def);\r\n\r\n      def && Util.mix(cfg, def);\r\n      scale = new Scale[SCALE_TYPES_MAP[type]](cfg);\r\n    }\r\n\r\n    return scale;\r\n  };\r\n\r\n  return ScaleController;\r\n}();\r\n\r\nmodule.exports = ScaleController;","\r\n\r\nvar Scale = require('@antv/scale/lib/base');\r\n\r\nrequire('@antv/scale/lib/linear');\r\n\r\nrequire('@antv/scale/lib/identity');\r\n\r\nrequire('@antv/scale/lib/category');\r\n\r\nmodule.exports = Scale;","\r\n\r\nvar Util = require('../../util/common');\r\n\r\nvar Axis = require('../../component/axis/');\r\n\r\nvar Global = require('../../global');\r\n\r\nvar _require = require('../../graphic/index'),\r\n    Shape = _require.Shape;\r\n\r\nfunction formatTicks(ticks) {\r\n  var tmp = ticks.slice(0);\r\n\r\n  if (tmp.length > 0) {\r\n    var first = tmp[0];\r\n    var last = tmp[tmp.length - 1];\r\n\r\n    if (first.value !== 0) {\r\n      tmp.unshift({\r\n        value: 0\r\n      });\r\n    }\r\n\r\n    if (last.value !== 1) {\r\n      tmp.push({\r\n        value: 1\r\n      });\r\n    }\r\n  }\r\n\r\n  return tmp;\r\n}\r\n\r\nvar AxisController =\r\n/*#__PURE__*/\r\nfunction () {\r\n  function AxisController(cfg) {\r\n    this.axisCfg = {};\r\n    this.frontPlot = null;\r\n    this.backPlot = null;\r\n    this.axes = {}; // store the axes's options\r\n\r\n    Util.mix(this, cfg);\r\n  }\r\n\r\n  var _proto = AxisController.prototype;\r\n\r\n  _proto._isHide = function _isHide(field) {\r\n    var axisCfg = this.axisCfg;\r\n    return !axisCfg || axisCfg[field] === false;\r\n  };\r\n\r\n  _proto._getLinePosition = function _getLinePosition(scale, dimType, index, transposed) {\r\n    var position = '';\r\n    var field = scale.field;\r\n    var axisCfg = this.axisCfg;\r\n\r\n    if (axisCfg[field] && axisCfg[field].position) {\r\n      position = axisCfg[field].position;\r\n    } else if (dimType === 'x') {\r\n      position = transposed ? 'left' : 'bottom';\r\n    } else if (dimType === 'y') {\r\n      position = index ? 'right' : 'left';\r\n\r\n      if (transposed) {\r\n        position = 'bottom';\r\n      }\r\n    }\r\n\r\n    return position;\r\n  };\r\n\r\n  _proto._getLineCfg = function _getLineCfg(coord, dimType, position) {\r\n    var start;\r\n    var end;\r\n    var factor = 1; // Mark clockwise or counterclockwise\r\n\r\n    if (dimType === 'x') {\r\n      start = {\r\n        x: 0,\r\n        y: 0\r\n      };\r\n      end = {\r\n        x: 1,\r\n        y: 0\r\n      };\r\n    } else {\r\n      if (position === 'right') {\r\n        // there will be several y axes\r\n        start = {\r\n          x: 1,\r\n          y: 0\r\n        };\r\n        end = {\r\n          x: 1,\r\n          y: 1\r\n        };\r\n      } else {\r\n        start = {\r\n          x: 0,\r\n          y: 0\r\n        };\r\n        end = {\r\n          x: 0,\r\n          y: 1\r\n        };\r\n        factor = -1;\r\n      }\r\n    }\r\n\r\n    if (coord.transposed) {\r\n      factor *= -1;\r\n    }\r\n\r\n    return {\r\n      offsetFactor: factor,\r\n      start: coord.convertPoint(start),\r\n      end: coord.convertPoint(end)\r\n    };\r\n  };\r\n\r\n  _proto._getCircleCfg = function _getCircleCfg(coord) {\r\n    return {\r\n      startAngle: coord.startAngle,\r\n      endAngle: coord.endAngle,\r\n      center: coord.center,\r\n      radius: coord.circleRadius\r\n    };\r\n  };\r\n\r\n  _proto._getRadiusCfg = function _getRadiusCfg(coord) {\r\n    var transposed = coord.transposed;\r\n    var start;\r\n    var end;\r\n\r\n    if (transposed) {\r\n      start = {\r\n        x: 0,\r\n        y: 0\r\n      };\r\n      end = {\r\n        x: 1,\r\n        y: 0\r\n      };\r\n    } else {\r\n      start = {\r\n        x: 0,\r\n        y: 0\r\n      };\r\n      end = {\r\n        x: 0,\r\n        y: 1\r\n      };\r\n    }\r\n\r\n    return {\r\n      offsetFactor: -1,\r\n      start: coord.convertPoint(start),\r\n      end: coord.convertPoint(end)\r\n    };\r\n  };\r\n\r\n  _proto._getAxisCfg = function _getAxisCfg(coord, scale, verticalScale, dimType, defaultCfg) {\r\n    var self = this;\r\n    var axisCfg = this.axisCfg;\r\n    var ticks = scale.getTicks();\r\n    var cfg = Util.deepMix({\r\n      ticks: ticks,\r\n      frontContainer: this.frontPlot,\r\n      backContainer: this.backPlot\r\n    }, defaultCfg, axisCfg[scale.field]);\r\n    var labels = [];\r\n    var label = cfg.label;\r\n    var count = ticks.length;\r\n    var maxWidth = 0;\r\n    var maxHeight = 0;\r\n    var labelCfg = label;\r\n    Util.each(ticks, function (tick, index) {\r\n      if (Util.isFunction(label)) {\r\n        var executedLabel = label(tick.text, index, count);\r\n        labelCfg = executedLabel ? Util.mix({}, Global._defaultAxis.label, executedLabel) : null;\r\n      }\r\n\r\n      if (labelCfg) {\r\n        var textStyle = {};\r\n\r\n        if (labelCfg.textAlign) {\r\n          textStyle.textAlign = labelCfg.textAlign;\r\n        }\r\n\r\n        if (labelCfg.textBaseline) {\r\n          textStyle.textBaseline = labelCfg.textBaseline;\r\n        }\r\n\r\n        var axisLabel = new Shape.Text({\r\n          className: 'axis-label',\r\n          attrs: Util.mix({\r\n            x: 0,\r\n            y: 0,\r\n            text: tick.text,\r\n            fontFamily: self.chart.get('canvas').get('fontFamily')\r\n          }, labelCfg),\r\n          value: tick.value,\r\n          textStyle: textStyle,\r\n          top: labelCfg.top,\r\n          context: self.chart.get('canvas').get('context')\r\n        });\r\n        labels.push(axisLabel);\r\n\r\n        var _axisLabel$getBBox = axisLabel.getBBox(),\r\n            width = _axisLabel$getBBox.width,\r\n            height = _axisLabel$getBBox.height;\r\n\r\n        maxWidth = Math.max(maxWidth, width);\r\n        maxHeight = Math.max(maxHeight, height);\r\n      }\r\n    });\r\n    cfg.labels = labels;\r\n    cfg.maxWidth = maxWidth;\r\n    cfg.maxHeight = maxHeight;\r\n    return cfg;\r\n  };\r\n\r\n  _proto._createAxis = function _createAxis(coord, scale, verticalScale, dimType, index) {\r\n    if (index === void 0) {\r\n      index = '';\r\n    }\r\n\r\n    var self = this;\r\n    var coordType = coord.type;\r\n    var transposed = coord.transposed;\r\n    var type;\r\n    var key;\r\n    var defaultCfg;\r\n\r\n    if (coordType === 'cartesian' || coordType === 'rect') {\r\n      var position = self._getLinePosition(scale, dimType, index, transposed);\r\n\r\n      defaultCfg = Global.axis[position];\r\n      defaultCfg.position = position;\r\n      type = 'Line';\r\n      key = position;\r\n    } else {\r\n      if (dimType === 'x' && !transposed || dimType === 'y' && transposed) {\r\n        defaultCfg = Global.axis.circle;\r\n        type = 'Circle';\r\n        key = 'circle';\r\n      } else {\r\n        defaultCfg = Global.axis.radius;\r\n        type = 'Line';\r\n        key = 'radius';\r\n      }\r\n    }\r\n\r\n    var cfg = self._getAxisCfg(coord, scale, verticalScale, dimType, defaultCfg);\r\n\r\n    cfg.type = type;\r\n    cfg.dimType = dimType;\r\n    cfg.verticalScale = verticalScale;\r\n    cfg.index = index;\r\n    this.axes[key] = cfg;\r\n  };\r\n\r\n  _proto.createAxis = function createAxis(coord, xScale, yScales) {\r\n    var self = this;\r\n\r\n    if (xScale && !self._isHide(xScale.field)) {\r\n      self._createAxis(coord, xScale, yScales[0], 'x');\r\n    }\r\n\r\n    Util.each(yScales, function (yScale, index) {\r\n      if (!self._isHide(yScale.field)) {\r\n        self._createAxis(coord, yScale, xScale, 'y', index);\r\n      }\r\n    });\r\n    var axes = this.axes;\r\n    var chart = self.chart;\r\n\r\n    if (chart._isAutoPadding()) {\r\n      var userPadding = Util.parsePadding(chart.get('padding'));\r\n      var appendPadding = Util.parsePadding(chart.get('appendPadding'));\r\n      var legendRange = chart.get('legendRange') || {\r\n        top: 0,\r\n        right: 0,\r\n        bottom: 0,\r\n        left: 0\r\n      };\r\n      var padding = [userPadding[0] === 'auto' ? legendRange.top + appendPadding[0] * 2 : userPadding[0], userPadding[1] === 'auto' ? legendRange.right + appendPadding[1] : userPadding[1], userPadding[2] === 'auto' ? legendRange.bottom + appendPadding[2] : userPadding[2], userPadding[3] === 'auto' ? legendRange.left + appendPadding[3] : userPadding[3]];\r\n\r\n      if (coord.isPolar) {\r\n        var circleAxis = axes.circle;\r\n\r\n        if (circleAxis) {\r\n          var maxHeight = circleAxis.maxHeight,\r\n              maxWidth = circleAxis.maxWidth,\r\n              labelOffset = circleAxis.labelOffset;\r\n          padding[0] += maxHeight + labelOffset;\r\n          padding[1] += maxWidth + labelOffset;\r\n          padding[2] += maxHeight + labelOffset;\r\n          padding[3] += maxWidth + labelOffset;\r\n        }\r\n      } else {\r\n        if (axes.right && userPadding[1] === 'auto') {\r\n          var _axes$right = axes.right,\r\n              _maxWidth = _axes$right.maxWidth,\r\n              _labelOffset = _axes$right.labelOffset;\r\n          padding[1] += _maxWidth + _labelOffset;\r\n        }\r\n\r\n        if (axes.left && userPadding[3] === 'auto') {\r\n          var _axes$left = axes.left,\r\n              _maxWidth2 = _axes$left.maxWidth,\r\n              _labelOffset2 = _axes$left.labelOffset;\r\n          padding[3] += _maxWidth2 + _labelOffset2;\r\n        }\r\n\r\n        if (axes.bottom && userPadding[2] === 'auto') {\r\n          var _axes$bottom = axes.bottom,\r\n              _maxHeight = _axes$bottom.maxHeight,\r\n              _labelOffset3 = _axes$bottom.labelOffset;\r\n          padding[2] += _maxHeight + _labelOffset3;\r\n        }\r\n      }\r\n\r\n      chart.set('_padding', padding);\r\n\r\n      chart._updateLayout(padding);\r\n    }\r\n\r\n    Util.each(axes, function (axis) {\r\n      var type = axis.type,\r\n          grid = axis.grid,\r\n          verticalScale = axis.verticalScale,\r\n          ticks = axis.ticks,\r\n          dimType = axis.dimType,\r\n          position = axis.position,\r\n          index = axis.index;\r\n      var appendCfg;\r\n\r\n      if (coord.isPolar) {\r\n        if (type === 'Line') {\r\n          appendCfg = self._getRadiusCfg(coord);\r\n        } else if (type === 'Circle') {\r\n          appendCfg = self._getCircleCfg(coord);\r\n        }\r\n      } else {\r\n        appendCfg = self._getLineCfg(coord, dimType, position);\r\n      }\r\n\r\n      if (grid && verticalScale) {\r\n        var gridPoints = [];\r\n        var verticalTicks = formatTicks(verticalScale.getTicks());\r\n        Util.each(ticks, function (tick) {\r\n          var subPoints = [];\r\n          Util.each(verticalTicks, function (verticalTick) {\r\n            var x = dimType === 'x' ? tick.value : verticalTick.value;\r\n            var y = dimType === 'x' ? verticalTick.value : tick.value;\r\n\r\n            if (x >= 0 && x <= 1 && y >= 0 && y <= 1) {\r\n              var point = coord.convertPoint({\r\n                x: x,\r\n                y: y\r\n              });\r\n              subPoints.push(point);\r\n            }\r\n          });\r\n          gridPoints.push({\r\n            points: subPoints,\r\n            _id: 'axis-' + dimType + index + '-grid-' + tick.tickValue\r\n          });\r\n        });\r\n        axis.gridPoints = gridPoints;\r\n\r\n        if (coord.isPolar) {\r\n          axis.center = coord.center;\r\n          axis.startAngle = coord.startAngle;\r\n          axis.endAngle = coord.endAngle;\r\n        }\r\n      }\r\n\r\n      appendCfg._id = 'axis-' + dimType;\r\n\r\n      if (!Util.isNil(index)) {\r\n        appendCfg._id = 'axis-' + dimType + index;\r\n      }\r\n\r\n      new Axis[type](Util.mix(axis, appendCfg));\r\n    });\r\n  };\r\n\r\n  _proto.clear = function clear() {\r\n    this.axes = {};\r\n    this.frontPlot.clear();\r\n    this.backPlot.clear();\r\n  };\r\n\r\n  return AxisController;\r\n}();\r\n\r\nmodule.exports = AxisController;","\r\n\r\nvar Abstract = require('./abstract');\r\n\r\nrequire('./line');\r\n\r\nmodule.exports = Abstract;","\r\n\r\nvar Util = require('../../util/common');\r\n\r\nvar Global = require('../../global');\r\n\r\nvar Vector2 = require('../../graphic/util/vector2');\r\n\r\nvar Abastract =\r\n/*#__PURE__*/\r\nfunction () {\r\n  var _proto = Abastract.prototype;\r\n\r\n  _proto._initDefaultCfg = function _initDefaultCfg() {\r\n    /**\r\n     * ticks\r\n     * @type {Array}\r\n     */\r\n    this.ticks = [];\r\n    /**\r\n     * the configuration for tickLine\r\n     * @type {Object}\r\n     */\r\n\r\n    this.tickLine = {};\r\n    /**\r\n     * the direction of ticks, 1 means clockwise\r\n     * @type {Number}\r\n     */\r\n\r\n    this.offsetFactor = 1;\r\n    /**\r\n     * the top container\r\n     * @type {container}\r\n     */\r\n\r\n    this.frontContainer = null;\r\n    /**\r\n     * the back container\r\n     * @type {[type]}\r\n     */\r\n\r\n    this.backContainer = null;\r\n    /**\r\n     * points for draw grid line\r\n     * @type {Array}\r\n     */\r\n\r\n    this.gridPoints = [];\r\n  };\r\n\r\n  function Abastract(cfg) {\r\n    this._initDefaultCfg();\r\n\r\n    Util.mix(this, cfg);\r\n    this.draw();\r\n  }\r\n\r\n  _proto.draw = function draw() {\r\n    var line = this.line,\r\n        tickLine = this.tickLine,\r\n        label = this.label,\r\n        grid = this.grid;\r\n    grid && this.drawGrid(grid); // draw the grid lines\r\n\r\n    tickLine && this.drawTicks(tickLine); // draw the tickLine\r\n\r\n    line && this.drawLine(line); // draw axis line\r\n\r\n    label && this.drawLabels(); // draw ticks\r\n  };\r\n\r\n  _proto.drawTicks = function drawTicks(tickCfg) {\r\n    var self = this;\r\n    var ticks = self.ticks;\r\n    var length = tickCfg.length;\r\n    var container = self.getContainer(tickCfg.top);\r\n    Util.each(ticks, function (tick) {\r\n      var start = self.getOffsetPoint(tick.value);\r\n      var end = self.getSidePoint(start, length);\r\n      var shape = container.addShape('line', {\r\n        className: 'axis-tick',\r\n        attrs: Util.mix({\r\n          x1: start.x,\r\n          y1: start.y,\r\n          x2: end.x,\r\n          y2: end.y\r\n        }, tickCfg)\r\n      });\r\n      shape._id = self._id + '-ticks';\r\n    });\r\n  };\r\n\r\n  _proto.drawLabels = function drawLabels() {\r\n    var self = this;\r\n    var labelOffset = self.labelOffset;\r\n    var labels = self.labels;\r\n    Util.each(labels, function (labelShape) {\r\n      var container = self.getContainer(labelShape.get('top'));\r\n      var start = self.getOffsetPoint(labelShape.get('value'));\r\n\r\n      var _self$getSidePoint = self.getSidePoint(start, labelOffset),\r\n          x = _self$getSidePoint.x,\r\n          y = _self$getSidePoint.y;\r\n\r\n      labelShape.attr(Util.mix({\r\n        x: x,\r\n        y: y\r\n      }, self.getTextAlignInfo(start, labelOffset), labelShape.get('textStyle')));\r\n      labelShape._id = self._id + '-' + labelShape.attr('text');\r\n      container.add(labelShape);\r\n    });\r\n  };\r\n\r\n  _proto.drawLine = function drawLine() {};\r\n\r\n  _proto.drawGrid = function drawGrid(grid) {\r\n    var self = this;\r\n    var gridPoints = self.gridPoints,\r\n        ticks = self.ticks;\r\n    var gridCfg = grid;\r\n    var count = gridPoints.length;\r\n    Util.each(gridPoints, function (subPoints, index) {\r\n      if (Util.isFunction(grid)) {\r\n        var tick = ticks[index] || {};\r\n        var executedGrid = grid(tick.text, index, count);\r\n        gridCfg = executedGrid ? Util.mix({}, Global._defaultAxis.grid, executedGrid) : null;\r\n      }\r\n\r\n      if (gridCfg) {\r\n        var type = gridCfg.type; // has two types: 'line' and 'arc'\r\n\r\n        var points = subPoints.points;\r\n        var container = self.getContainer(gridCfg.top);\r\n        var shape;\r\n\r\n        if (type === 'arc') {\r\n          var center = self.center,\r\n              startAngle = self.startAngle,\r\n              endAngle = self.endAngle;\r\n          var radius = Vector2.length([points[0].x - center.x, points[0].y - center.y]);\r\n          shape = container.addShape('Arc', {\r\n            className: 'axis-grid',\r\n            attrs: Util.mix({\r\n              x: center.x,\r\n              y: center.y,\r\n              startAngle: startAngle,\r\n              endAngle: endAngle,\r\n              r: radius\r\n            }, gridCfg)\r\n          });\r\n        } else {\r\n          shape = container.addShape('Polyline', {\r\n            className: 'axis-grid',\r\n            attrs: Util.mix({\r\n              points: points\r\n            }, gridCfg)\r\n          });\r\n        }\r\n\r\n        shape._id = subPoints._id;\r\n      }\r\n    });\r\n  };\r\n\r\n  _proto.getOffsetPoint = function getOffsetPoint() {};\r\n\r\n  _proto.getAxisVector = function getAxisVector() {};\r\n\r\n  _proto.getOffsetVector = function getOffsetVector(point, offset) {\r\n    var self = this;\r\n    var axisVector = self.getAxisVector(point);\r\n    var normal = Vector2.normalize([], axisVector);\r\n    var factor = self.offsetFactor;\r\n    var verticalVector = [normal[1] * -1 * factor, normal[0] * factor];\r\n    return Vector2.scale([], verticalVector, offset);\r\n  };\r\n\r\n  _proto.getSidePoint = function getSidePoint(point, offset) {\r\n    var self = this;\r\n    var offsetVector = self.getOffsetVector(point, offset);\r\n    return {\r\n      x: point.x + offsetVector[0],\r\n      y: point.y + offsetVector[1]\r\n    };\r\n  };\r\n\r\n  _proto.getTextAlignInfo = function getTextAlignInfo(point, offset) {\r\n    var self = this;\r\n    var offsetVector = self.getOffsetVector(point, offset);\r\n    var align;\r\n    var baseLine;\r\n\r\n    if (offsetVector[0] > 0) {\r\n      align = 'left';\r\n    } else if (offsetVector[0] < 0) {\r\n      align = 'right';\r\n    } else {\r\n      align = 'center';\r\n    }\r\n\r\n    if (offsetVector[1] > 0) {\r\n      baseLine = 'top';\r\n    } else if (offsetVector[1] < 0) {\r\n      baseLine = 'bottom';\r\n    } else {\r\n      baseLine = 'middle';\r\n    }\r\n\r\n    return {\r\n      textAlign: align,\r\n      textBaseline: baseLine\r\n    };\r\n  };\r\n\r\n  _proto.getContainer = function getContainer(isTop) {\r\n    var frontContainer = this.frontContainer,\r\n        backContainer = this.backContainer;\r\n    return isTop ? frontContainer : backContainer;\r\n  };\r\n\r\n  return Abastract;\r\n}();\r\n\r\nmodule.exports = Abastract;","\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\r\n\r\nvar Util = require('../../util/common');\r\n\r\nvar Abstract = require('./abstract');\r\n\r\nvar Line =\r\n/*#__PURE__*/\r\nfunction (_Abstract) {\r\n  (0, _inheritsLoose2[\"default\"])(Line, _Abstract);\r\n\r\n  function Line() {\r\n    return _Abstract.apply(this, arguments) || this;\r\n  }\r\n\r\n  var _proto = Line.prototype;\r\n\r\n  _proto._initDefaultCfg = function _initDefaultCfg() {\r\n    _Abstract.prototype._initDefaultCfg.call(this);\r\n\r\n    this.start = null;\r\n    this.end = null;\r\n  };\r\n\r\n  _proto.getOffsetPoint = function getOffsetPoint(value) {\r\n    var start = this.start,\r\n        end = this.end;\r\n    return {\r\n      x: start.x + (end.x - start.x) * value,\r\n      y: start.y + (end.y - start.y) * value\r\n    };\r\n  };\r\n\r\n  _proto.getAxisVector = function getAxisVector() {\r\n    var start = this.start,\r\n        end = this.end;\r\n    return [end.x - start.x, end.y - start.y];\r\n  };\r\n\r\n  _proto.drawLine = function drawLine(lineCfg) {\r\n    var container = this.getContainer(lineCfg.top);\r\n    var start = this.start,\r\n        end = this.end;\r\n    container.addShape('line', {\r\n      className: 'axis-line',\r\n      attrs: Util.mix({\r\n        x1: start.x,\r\n        y1: start.y,\r\n        x2: end.x,\r\n        y2: end.y\r\n      }, lineCfg)\r\n    });\r\n  };\r\n\r\n  return Line;\r\n}(Abstract);\r\n\r\nAbstract.Line = Line;\r\nmodule.exports = Line;","\r\n\r\nvar G = {\r\n  Canvas: require('./canvas'),\r\n  Group: require('./group'),\r\n  Shape: require('./shape'),\r\n  Matrix: require('./util/matrix'),\r\n  Vector2: require('./util/vector2')\r\n};\r\n\r\nrequire('./shape/rect');\r\n\r\nrequire('./shape/circle');\r\n\r\nrequire('./shape/line');\r\n\r\nrequire('./shape/polygon');\r\n\r\nrequire('./shape/polyline');\r\n\r\nrequire('./shape/arc');\r\n\r\nrequire('./shape/sector');\r\n\r\nrequire('./shape/text');\r\n\r\nrequire('./shape/custom');\r\n\r\nmodule.exports = G;","\r\n\r\nvar Util = require('../util/common');\r\n\r\nvar Container = require('./container');\r\n\r\nvar Group = require('./group');\r\n\r\nvar _require = require('./util/requestAnimationFrame'),\r\n    requestAnimationFrame = _require.requestAnimationFrame;\r\n\r\nvar CanvasElement = require('./canvas-element');\r\n\r\nvar Canvas =\r\n/*#__PURE__*/\r\nfunction () {\r\n  var _proto = Canvas.prototype;\r\n\r\n  _proto.get = function get(name) {\r\n    return this._attrs[name];\r\n  };\r\n\r\n  _proto.set = function set(name, value) {\r\n    this._attrs[name] = value;\r\n  };\r\n\r\n  function Canvas(cfg) {\r\n    this._attrs = Util.mix({\r\n      type: 'canvas',\r\n      children: []\r\n    }, cfg);\r\n\r\n    this._initPixelRatio();\r\n\r\n    this._initCanvas();\r\n  }\r\n\r\n  _proto._initPixelRatio = function _initPixelRatio() {\r\n    var pixelRatio = this.get('pixelRatio');\r\n\r\n    if (!pixelRatio) {\r\n      this.set('pixelRatio', Util.getPixelRatio());\r\n    }\r\n  };\r\n\r\n  _proto.beforeDraw = function beforeDraw() {\r\n    var context = this._attrs.context;\r\n    var el = this._attrs.el;\r\n    context && context.clearRect && context.clearRect(0, 0, el.width, el.height);\r\n  };\r\n\r\n  _proto._initCanvas = function _initCanvas() {\r\n    var self = this;\r\n    var el = self.get('el');\r\n    var context = self.get('context');\r\n\r\n    if (!el && !context) {\r\n      throw new Error('Please specify the id or el of the chart!');\r\n    }\r\n\r\n    var canvas;\r\n\r\n    if (el) {\r\n      // DOMElement or String\r\n      canvas = Util.isString(el) ? Util.getDomById(el) : el;\r\n    } else {\r\n      // 说明没有指定el\r\n      canvas = CanvasElement.create(context);\r\n    }\r\n\r\n    if (context && canvas && !canvas.getContext) {\r\n      canvas.getContext = function () {\r\n        return context;\r\n      };\r\n    }\r\n\r\n    var width = self.get('width');\r\n\r\n    if (!width) {\r\n      width = Util.getWidth(canvas);\r\n    }\r\n\r\n    var height = self.get('height');\r\n\r\n    if (!height) {\r\n      height = Util.getHeight(canvas);\r\n    }\r\n\r\n    self.set('canvas', this);\r\n    self.set('el', canvas);\r\n    self.set('context', context || canvas.getContext('2d'));\r\n    self.changeSize(width, height);\r\n  };\r\n\r\n  _proto.changeSize = function changeSize(width, height) {\r\n    var pixelRatio = this.get('pixelRatio');\r\n    var canvasDOM = this.get('el'); // HTMLCanvasElement or canvasElement\r\n    // 浏览器环境设置style样式\r\n\r\n    if (canvasDOM.style) {\r\n      canvasDOM.style.width = width + 'px';\r\n      canvasDOM.style.height = height + 'px';\r\n    }\r\n\r\n    if (Util.isCanvasElement(canvasDOM)) {\r\n      canvasDOM.width = width * pixelRatio;\r\n      canvasDOM.height = height * pixelRatio;\r\n\r\n      if (pixelRatio !== 1) {\r\n        var ctx = this.get('context');\r\n        ctx.scale(pixelRatio, pixelRatio);\r\n      }\r\n    }\r\n\r\n    this.set('width', width);\r\n    this.set('height', height);\r\n  };\r\n\r\n  _proto.getWidth = function getWidth() {\r\n    var pixelRatio = this.get('pixelRatio');\r\n    var width = this.get('width');\r\n    return width * pixelRatio;\r\n  };\r\n\r\n  _proto.getHeight = function getHeight() {\r\n    var pixelRatio = this.get('pixelRatio');\r\n    var height = this.get('height');\r\n    return height * pixelRatio;\r\n  };\r\n\r\n  _proto.getPointByClient = function getPointByClient(clientX, clientY) {\r\n    var el = this.get('el');\r\n    var bbox = el.getBoundingClientRect();\r\n    var width = bbox.right - bbox.left;\r\n    var height = bbox.bottom - bbox.top;\r\n    return {\r\n      x: (clientX - bbox.left) * (el.width / width),\r\n      y: (clientY - bbox.top) * (el.height / height)\r\n    };\r\n  };\r\n\r\n  _proto._beginDraw = function _beginDraw() {\r\n    this._attrs.toDraw = true;\r\n  };\r\n\r\n  _proto._endDraw = function _endDraw() {\r\n    this._attrs.toDraw = false;\r\n  };\r\n\r\n  _proto.draw = function draw() {\r\n    var self = this;\r\n\r\n    function drawInner() {\r\n      self.set('animateHandler', requestAnimationFrame(function () {\r\n        self.set('animateHandler', undefined);\r\n\r\n        if (self.get('toDraw')) {\r\n          drawInner();\r\n        }\r\n      }));\r\n      self.beforeDraw();\r\n\r\n      try {\r\n        var context = self._attrs.context;\r\n        var children = self._attrs.children;\r\n\r\n        for (var i = 0, len = children.length; i < len; i++) {\r\n          var child = children[i];\r\n          child.draw(context);\r\n        } // 支付宝，微信小程序，需要调context.draw才能完成绘制， 所以这里直接判断是否有.draw方法\r\n\r\n\r\n        if (context.draw) {\r\n          context.draw();\r\n        }\r\n      } catch (ev) {\r\n        console.warn('error in draw canvas, detail as:');\r\n        console.warn(ev);\r\n\r\n        self._endDraw();\r\n      }\r\n\r\n      self._endDraw();\r\n    }\r\n\r\n    if (self.get('destroyed')) {\r\n      return;\r\n    }\r\n\r\n    if (self.get('animateHandler')) {\r\n      this._beginDraw();\r\n    } else {\r\n      drawInner();\r\n    }\r\n  };\r\n\r\n  _proto.destroy = function destroy() {\r\n    if (this.get('destroyed')) {\r\n      return;\r\n    }\r\n\r\n    this.clear();\r\n    this._attrs = {};\r\n    this.set('destroyed', true);\r\n  };\r\n\r\n  _proto.isDestroyed = function isDestroyed() {\r\n    return this.get('destroyed');\r\n  };\r\n\r\n  return Canvas;\r\n}();\r\n\r\nUtil.mix(Canvas.prototype, Container, {\r\n  getGroupClass: function getGroupClass() {\r\n    return Group;\r\n  }\r\n});\r\nmodule.exports = Canvas;","\r\n\r\nvar Util = require('../util/common');\r\n\r\nvar Shape = require('./shape');\r\n\r\nvar SHAPE_MAP = {};\r\nvar INDEX = '_INDEX';\r\n\r\nfunction getComparer(compare) {\r\n  return function (left, right) {\r\n    var result = compare(left, right);\r\n    return result === 0 ? left[INDEX] - right[INDEX] : result;\r\n  };\r\n}\r\n\r\nmodule.exports = {\r\n  getGroupClass: function getGroupClass() {},\r\n  getChildren: function getChildren() {\r\n    return this.get('children');\r\n  },\r\n  addShape: function addShape(type, cfg) {\r\n    if (cfg === void 0) {\r\n      cfg = {};\r\n    }\r\n\r\n    var canvas = this.get('canvas');\r\n    var shapeType = SHAPE_MAP[type];\r\n\r\n    if (!shapeType) {\r\n      shapeType = Util.upperFirst(type);\r\n      SHAPE_MAP[type] = shapeType;\r\n    }\r\n\r\n    cfg.canvas = canvas;\r\n\r\n    if (shapeType === 'Text' && canvas && canvas.get('fontFamily')) {\r\n      cfg.attrs.fontFamily = cfg.attrs.fontFamily || canvas.get('fontFamily');\r\n    }\r\n\r\n    var shape = new Shape[shapeType](cfg);\r\n    this.add(shape);\r\n    return shape;\r\n  },\r\n  addGroup: function addGroup(cfg) {\r\n    var canvas = this.get('canvas');\r\n    var groupClass = this.getGroupClass();\r\n    cfg = Util.mix({}, cfg);\r\n    cfg.canvas = canvas;\r\n    cfg.parent = this;\r\n    var rst = new groupClass(cfg);\r\n    this.add(rst);\r\n    return rst;\r\n  },\r\n  contain: function contain(item) {\r\n    var children = this.get('children');\r\n    return children.indexOf(item) > -1;\r\n  },\r\n  sort: function sort() {\r\n    var children = this.get('children');\r\n\r\n    for (var i = 0, len = children.length; i < len; i++) {\r\n      var child = children[i];\r\n      child[INDEX] = i;\r\n    }\r\n\r\n    children.sort(getComparer(function (obj1, obj2) {\r\n      return obj1.get('zIndex') - obj2.get('zIndex');\r\n    }));\r\n    return this;\r\n  },\r\n  clear: function clear() {\r\n    var children = this.get('children');\r\n\r\n    while (children.length !== 0) {\r\n      children[children.length - 1].remove(true);\r\n    }\r\n\r\n    return this;\r\n  },\r\n  add: function add(items) {\r\n    var self = this;\r\n    var children = self.get('children');\r\n\r\n    if (!Util.isArray(items)) {\r\n      items = [items];\r\n    }\r\n\r\n    for (var i = 0, len = items.length; i < len; i++) {\r\n      var item = items[i];\r\n      var parent = item.get('parent');\r\n\r\n      if (parent) {\r\n        var descendants = parent.get('children');\r\n        Util.Array.remove(descendants, item);\r\n      }\r\n\r\n      self._setEvn(item);\r\n\r\n      children.push(item);\r\n    }\r\n\r\n    return self;\r\n  },\r\n  _setEvn: function _setEvn(item) {\r\n    var self = this;\r\n    item._attrs.parent = self;\r\n    item._attrs.context = self._attrs.context;\r\n    item._attrs.canvas = self._attrs.canvas;\r\n    var clip = item._attrs.attrs.clip;\r\n\r\n    if (clip) {\r\n      clip.set('parent', self);\r\n      clip.set('context', self.get('context'));\r\n    }\r\n\r\n    if (item._attrs.isGroup) {\r\n      var children = item._attrs.children;\r\n\r\n      for (var i = 0, len = children.length; i < len; i++) {\r\n        item._setEvn(children[i]);\r\n      }\r\n    }\r\n  }\r\n};","\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\r\n\r\nvar Util = require('../util/common');\r\n\r\nvar Element = require('./element');\r\n\r\nvar Shape =\r\n/*#__PURE__*/\r\nfunction (_Element) {\r\n  (0, _inheritsLoose2[\"default\"])(Shape, _Element);\r\n\r\n  function Shape() {\r\n    return _Element.apply(this, arguments) || this;\r\n  }\r\n\r\n  var _proto = Shape.prototype;\r\n\r\n  _proto._initProperties = function _initProperties() {\r\n    this._attrs = {\r\n      zIndex: 0,\r\n      visible: true,\r\n      destroyed: false,\r\n      isShape: true,\r\n      attrs: {}\r\n    };\r\n  };\r\n\r\n  _proto.getType = function getType() {\r\n    return this._attrs.type;\r\n  };\r\n\r\n  _proto.drawInner = function drawInner(context) {\r\n    var self = this;\r\n    var attrs = self.get('attrs');\r\n    self.createPath(context);\r\n    var originOpacity = context.globalAlpha;\r\n\r\n    if (self.hasFill()) {\r\n      var fillOpacity = attrs.fillOpacity;\r\n\r\n      if (!Util.isNil(fillOpacity) && fillOpacity !== 1) {\r\n        context.globalAlpha = fillOpacity;\r\n        context.fill();\r\n        context.globalAlpha = originOpacity;\r\n      } else {\r\n        context.fill();\r\n      }\r\n    }\r\n\r\n    if (self.hasStroke()) {\r\n      var lineWidth = attrs.lineWidth;\r\n\r\n      if (lineWidth > 0) {\r\n        var strokeOpacity = attrs.strokeOpacity;\r\n\r\n        if (!Util.isNil(strokeOpacity) && strokeOpacity !== 1) {\r\n          context.globalAlpha = strokeOpacity;\r\n        }\r\n\r\n        context.stroke();\r\n      }\r\n    }\r\n  };\r\n\r\n  _proto.getBBox = function getBBox() {\r\n    var bbox = this._attrs.bbox;\r\n\r\n    if (!bbox) {\r\n      bbox = this.calculateBox();\r\n\r\n      if (bbox) {\r\n        bbox.x = bbox.minX;\r\n        bbox.y = bbox.minY;\r\n        bbox.width = bbox.maxX - bbox.minX;\r\n        bbox.height = bbox.maxY - bbox.minY;\r\n      }\r\n\r\n      this._attrs.bbox = bbox;\r\n    }\r\n\r\n    return bbox;\r\n  };\r\n\r\n  _proto.calculateBox = function calculateBox() {\r\n    return null;\r\n  };\r\n\r\n  _proto.createPath = function createPath() {};\r\n\r\n  return Shape;\r\n}(Element);\r\n\r\nmodule.exports = Shape;","\r\n\r\nvar Util = require('../util/common');\r\n\r\nvar MatrixUtil = require('./util/matrix');\r\n\r\nvar Vector2 = require('./util/vector2');\r\n\r\nvar StyleUtil = require('./util/style-parse');\r\n\r\nfunction isUnchanged(m) {\r\n  return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1 && m[4] === 0 && m[5] === 0;\r\n}\r\n\r\nvar ALIAS_ATTRS_MAP = {\r\n  stroke: 'strokeStyle',\r\n  fill: 'fillStyle',\r\n  opacity: 'globalAlpha'\r\n};\r\nvar SHAPE_ATTRS = ['fillStyle', 'font', 'globalAlpha', 'lineCap', 'lineWidth', 'lineJoin', 'miterLimit', 'shadowBlur', 'shadowColor', 'shadowOffsetX', 'shadowOffsetY', 'strokeStyle', 'textAlign', 'textBaseline', 'lineDash', 'shadow' // 兼容支付宝小程序\r\n];\r\nvar CLIP_SHAPES = ['circle', 'sector', 'polygon', 'rect', 'polyline'];\r\n\r\nvar Element =\r\n/*#__PURE__*/\r\nfunction () {\r\n  var _proto = Element.prototype;\r\n\r\n  _proto._initProperties = function _initProperties() {\r\n    this._attrs = {\r\n      zIndex: 0,\r\n      visible: true,\r\n      destroyed: false\r\n    };\r\n  };\r\n\r\n  function Element(cfg) {\r\n    this._initProperties();\r\n\r\n    Util.mix(this._attrs, cfg);\r\n    var attrs = this._attrs.attrs;\r\n\r\n    if (attrs) {\r\n      this.initAttrs(attrs);\r\n    }\r\n\r\n    this.initTransform();\r\n  }\r\n\r\n  _proto.get = function get(name) {\r\n    return this._attrs[name];\r\n  };\r\n\r\n  _proto.set = function set(name, value) {\r\n    this._attrs[name] = value;\r\n  };\r\n\r\n  _proto.isGroup = function isGroup() {\r\n    return this.get('isGroup');\r\n  };\r\n\r\n  _proto.isShape = function isShape() {\r\n    return this.get('isShape');\r\n  };\r\n\r\n  _proto.initAttrs = function initAttrs(attrs) {\r\n    this.attr(Util.mix(this.getDefaultAttrs(), attrs));\r\n  };\r\n\r\n  _proto.getDefaultAttrs = function getDefaultAttrs() {\r\n    return {};\r\n  };\r\n\r\n  _proto._setAttr = function _setAttr(name, value) {\r\n    var attrs = this._attrs.attrs;\r\n\r\n    if (name === 'clip') {\r\n      value = this._setAttrClip(value);\r\n    } else {\r\n      var alias = ALIAS_ATTRS_MAP[name];\r\n\r\n      if (alias) {\r\n        attrs[alias] = value;\r\n      }\r\n    }\r\n\r\n    attrs[name] = value;\r\n  };\r\n\r\n  _proto._getAttr = function _getAttr(name) {\r\n    return this._attrs.attrs[name];\r\n  } // _afterAttrsSet() {}\r\n  ;\r\n\r\n  _proto._setAttrClip = function _setAttrClip(clip) {\r\n    if (clip && CLIP_SHAPES.indexOf(clip._attrs.type) > -1) {\r\n      if (clip.get('canvas') === null) {\r\n        clip = Object.assign({}, clip);\r\n      }\r\n\r\n      clip.set('parent', this.get('parent'));\r\n      clip.set('context', this.get('context'));\r\n      return clip;\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  _proto.attr = function attr(name, value) {\r\n    var self = this;\r\n    if (self.get('destroyed')) return null;\r\n    var argumentsLen = arguments.length;\r\n\r\n    if (argumentsLen === 0) {\r\n      return self._attrs.attrs;\r\n    }\r\n\r\n    if (Util.isObject(name)) {\r\n      this._attrs.bbox = null;\r\n\r\n      for (var k in name) {\r\n        self._setAttr(k, name[k]);\r\n      }\r\n\r\n      if (self._afterAttrsSet) {\r\n        self._afterAttrsSet();\r\n      }\r\n\r\n      return self;\r\n    }\r\n\r\n    if (argumentsLen === 2) {\r\n      this._attrs.bbox = null;\r\n\r\n      self._setAttr(name, value);\r\n\r\n      if (self._afterAttrsSet) {\r\n        self._afterAttrsSet();\r\n      }\r\n\r\n      return self;\r\n    }\r\n\r\n    return self._getAttr(name);\r\n  };\r\n\r\n  _proto.getParent = function getParent() {\r\n    return this.get('parent');\r\n  };\r\n\r\n  _proto.draw = function draw(context) {\r\n    if (this.get('destroyed')) {\r\n      return;\r\n    }\r\n\r\n    if (this.get('visible')) {\r\n      this.setContext(context);\r\n      this.drawInner(context);\r\n      this.restoreContext(context);\r\n    }\r\n  };\r\n\r\n  _proto.setContext = function setContext(context) {\r\n    var clip = this._attrs.attrs.clip;\r\n    context.save();\r\n\r\n    if (clip) {\r\n      clip.resetTransform(context);\r\n      clip.createPath(context);\r\n      context.clip();\r\n    }\r\n\r\n    this.resetContext(context);\r\n    this.resetTransform(context);\r\n  };\r\n\r\n  _proto.restoreContext = function restoreContext(context) {\r\n    context.restore();\r\n  };\r\n\r\n  _proto.resetContext = function resetContext(context) {\r\n    var elAttrs = this._attrs.attrs;\r\n\r\n    if (!this._attrs.isGroup) {\r\n      for (var k in elAttrs) {\r\n        if (SHAPE_ATTRS.indexOf(k) > -1) {\r\n          var v = elAttrs[k];\r\n\r\n          if (k === 'fillStyle' || k === 'strokeStyle') {\r\n            v = StyleUtil.parseStyle(v, this, context);\r\n          }\r\n\r\n          if (k === 'lineDash' && context.setLineDash && Util.isArray(v)) {\r\n            context.setLineDash(v);\r\n          } else {\r\n            context[k] = v;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  _proto.hasFill = function hasFill() {\r\n    return this.get('canFill') && this._attrs.attrs.fillStyle;\r\n  };\r\n\r\n  _proto.hasStroke = function hasStroke() {\r\n    return this.get('canStroke') && this._attrs.attrs.strokeStyle;\r\n  };\r\n\r\n  _proto.drawInner = function drawInner()\r\n  /* context */\r\n  {};\r\n\r\n  _proto.show = function show() {\r\n    this.set('visible', true);\r\n    return this;\r\n  };\r\n\r\n  _proto.hide = function hide() {\r\n    this.set('visible', false);\r\n    return this;\r\n  };\r\n\r\n  _proto.isVisible = function isVisible() {\r\n    return this.get('visible');\r\n  };\r\n\r\n  _proto._removeFromParent = function _removeFromParent() {\r\n    var parent = this.get('parent');\r\n\r\n    if (parent) {\r\n      var children = parent.get('children');\r\n      Util.Array.remove(children, this);\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  _proto.remove = function remove(destroy) {\r\n    if (destroy) {\r\n      this.destroy();\r\n    } else {\r\n      this._removeFromParent();\r\n    }\r\n  };\r\n\r\n  _proto.destroy = function destroy() {\r\n    var destroyed = this.get('destroyed');\r\n\r\n    if (destroyed) {\r\n      return null;\r\n    }\r\n\r\n    this._removeFromParent();\r\n\r\n    this._attrs = {};\r\n    this.set('destroyed', true);\r\n  };\r\n\r\n  _proto.getBBox = function getBBox() {\r\n    return {\r\n      minX: 0,\r\n      maxX: 0,\r\n      minY: 0,\r\n      maxY: 0,\r\n      width: 0,\r\n      height: 0\r\n    };\r\n  };\r\n\r\n  _proto.initTransform = function initTransform() {\r\n    var attrs = this._attrs.attrs || {};\r\n\r\n    if (!attrs.matrix) {\r\n      attrs.matrix = [1, 0, 0, 1, 0, 0];\r\n    }\r\n\r\n    this._attrs.attrs = attrs;\r\n  };\r\n\r\n  _proto.getMatrix = function getMatrix() {\r\n    return this._attrs.attrs.matrix;\r\n  };\r\n\r\n  _proto.setMatrix = function setMatrix(m) {\r\n    this._attrs.attrs.matrix = [m[0], m[1], m[2], m[3], m[4], m[5]];\r\n  };\r\n\r\n  _proto.transform = function transform(actions) {\r\n    var matrix = this._attrs.attrs.matrix;\r\n    this._attrs.attrs.matrix = MatrixUtil.transform(matrix, actions);\r\n    return this;\r\n  };\r\n\r\n  _proto.setTransform = function setTransform(actions) {\r\n    this._attrs.attrs.matrix = [1, 0, 0, 1, 0, 0];\r\n    return this.transform(actions);\r\n  };\r\n\r\n  _proto.translate = function translate(x, y) {\r\n    var matrix = this._attrs.attrs.matrix;\r\n    MatrixUtil.translate(matrix, matrix, [x, y]);\r\n  };\r\n\r\n  _proto.rotate = function rotate(rad) {\r\n    var matrix = this._attrs.attrs.matrix;\r\n    MatrixUtil.rotate(matrix, matrix, rad);\r\n  };\r\n\r\n  _proto.scale = function scale(sx, sy) {\r\n    var matrix = this._attrs.attrs.matrix;\r\n    MatrixUtil.scale(matrix, matrix, [sx, sy]);\r\n  };\r\n\r\n  _proto.moveTo = function moveTo(x, y) {\r\n    var cx = this._attrs.x || 0;\r\n    var cy = this._attrs.y || 0;\r\n    this.translate(x - cx, y - cy);\r\n    this.set('x', x);\r\n    this.set('y', y);\r\n  };\r\n\r\n  _proto.apply = function apply(v) {\r\n    var m = this._attrs.attrs.matrix;\r\n    Vector2.transformMat2d(v, v, m);\r\n    return this;\r\n  };\r\n\r\n  _proto.resetTransform = function resetTransform(context) {\r\n    var mo = this._attrs.attrs.matrix;\r\n\r\n    if (!isUnchanged(mo)) {\r\n      context.transform(mo[0], mo[1], mo[2], mo[3], mo[4], mo[5]);\r\n    }\r\n  };\r\n\r\n  _proto.isDestroyed = function isDestroyed() {\r\n    return this.get('destroyed');\r\n  };\r\n\r\n  return Element;\r\n}();\r\n\r\nmodule.exports = Element;","\r\n\r\nvar Util = require('../../util/common');\r\n\r\nfunction _mod(n, m) {\r\n  return (n % m + m) % m;\r\n}\r\n\r\nfunction _addStop(steps, gradient) {\r\n  Util.each(steps, function (item) {\r\n    item = item.split(':');\r\n    gradient.addColorStop(Number(item[0]), item[1]);\r\n  });\r\n} // the string format: 'l(0) 0:#ffffff 0.5:#7ec2f3 1:#1890ff'\r\n\r\n\r\nfunction _parseLineGradient(color, shape, context) {\r\n  var arr = color.split(' ');\r\n  var angle = arr[0].slice(2, arr[0].length - 1);\r\n  angle = _mod(parseFloat(angle) * Math.PI / 180, Math.PI * 2);\r\n  var steps = arr.slice(1);\r\n\r\n  var _shape$getBBox = shape.getBBox(),\r\n      minX = _shape$getBBox.minX,\r\n      minY = _shape$getBBox.minY,\r\n      maxX = _shape$getBBox.maxX,\r\n      maxY = _shape$getBBox.maxY;\r\n\r\n  var start;\r\n  var end;\r\n\r\n  if (angle >= 0 && angle < 0.5 * Math.PI) {\r\n    start = {\r\n      x: minX,\r\n      y: minY\r\n    };\r\n    end = {\r\n      x: maxX,\r\n      y: maxY\r\n    };\r\n  } else if (0.5 * Math.PI <= angle && angle < Math.PI) {\r\n    start = {\r\n      x: maxX,\r\n      y: minY\r\n    };\r\n    end = {\r\n      x: minX,\r\n      y: maxY\r\n    };\r\n  } else if (Math.PI <= angle && angle < 1.5 * Math.PI) {\r\n    start = {\r\n      x: maxX,\r\n      y: maxY\r\n    };\r\n    end = {\r\n      x: minX,\r\n      y: minY\r\n    };\r\n  } else {\r\n    start = {\r\n      x: minX,\r\n      y: maxY\r\n    };\r\n    end = {\r\n      x: maxX,\r\n      y: minY\r\n    };\r\n  }\r\n\r\n  var tanTheta = Math.tan(angle);\r\n  var tanTheta2 = tanTheta * tanTheta;\r\n  var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;\r\n  var y = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;\r\n  var gradient = context.createLinearGradient(start.x, start.y, x, y);\r\n\r\n  _addStop(steps, gradient);\r\n\r\n  return gradient;\r\n} // the string format: 'r(0.5, 0.5, 0.1) 0:#ffffff 1:#1890ff'\r\n\r\n\r\nfunction _parseRadialGradient(color, shape, context) {\r\n  var arr = color.split(' ');\r\n  var circleCfg = arr[0].slice(2, arr[0].length - 1);\r\n  circleCfg = circleCfg.split(',');\r\n  var fx = parseFloat(circleCfg[0]);\r\n  var fy = parseFloat(circleCfg[1]);\r\n  var fr = parseFloat(circleCfg[2]);\r\n  var steps = arr.slice(1); // if radius is 0, no gradient, stroke with the last color\r\n\r\n  if (fr === 0) {\r\n    var _color = steps[steps.length - 1];\r\n    return _color.split(':')[1];\r\n  }\r\n\r\n  var _shape$getBBox2 = shape.getBBox(),\r\n      width = _shape$getBBox2.width,\r\n      height = _shape$getBBox2.height,\r\n      minX = _shape$getBBox2.minX,\r\n      minY = _shape$getBBox2.minY;\r\n\r\n  var r = Math.sqrt(width * width + height * height) / 2;\r\n  var gradient = context.createRadialGradient(minX + width * fx, minY + height * fy, fr * r, minX + width / 2, minY + height / 2, r);\r\n\r\n  _addStop(steps, gradient);\r\n\r\n  return gradient;\r\n}\r\n\r\nmodule.exports = {\r\n  parseStyle: function parseStyle(color, shape, context) {\r\n    if (color[1] === '(') {\r\n      try {\r\n        var firstCode = color[0];\r\n\r\n        if (firstCode === 'l') {\r\n          return _parseLineGradient(color, shape, context);\r\n        } else if (firstCode === 'r') {\r\n          return _parseRadialGradient(color, shape, context);\r\n        }\r\n      } catch (ev) {\r\n        console.error('error in parsing gradient string, please check if there are any extra whitespaces.');\r\n        console.error(ev);\r\n      }\r\n    }\r\n\r\n    return color;\r\n  }\r\n};","\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\r\n\r\nvar Util = require('../util/common');\r\n\r\nvar Element = require('./element');\r\n\r\nvar Container = require('./container');\r\n\r\nvar Vector2 = require('./util/vector2');\r\n\r\nvar Group =\r\n/*#__PURE__*/\r\nfunction (_Element) {\r\n  (0, _inheritsLoose2[\"default\"])(Group, _Element);\r\n\r\n  function Group() {\r\n    return _Element.apply(this, arguments) || this;\r\n  }\r\n\r\n  var _proto = Group.prototype;\r\n\r\n  _proto._initProperties = function _initProperties() {\r\n    this._attrs = {\r\n      zIndex: 0,\r\n      visible: true,\r\n      destroyed: false,\r\n      isGroup: true,\r\n      children: []\r\n    };\r\n  };\r\n\r\n  _proto.drawInner = function drawInner(context) {\r\n    var children = this.get('children');\r\n\r\n    for (var i = 0, len = children.length; i < len; i++) {\r\n      var child = children[i];\r\n      child.draw(context);\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  _proto.getBBox = function getBBox() {\r\n    var self = this;\r\n    var minX = Infinity;\r\n    var maxX = -Infinity;\r\n    var minY = Infinity;\r\n    var maxY = -Infinity;\r\n    var children = self.get('children');\r\n\r\n    for (var i = 0, length = children.length; i < length; i++) {\r\n      var child = children[i];\r\n\r\n      if (child.get('visible')) {\r\n        var box = child.getBBox();\r\n\r\n        if (!box) {\r\n          continue;\r\n        }\r\n\r\n        var leftTop = [box.minX, box.minY];\r\n        var leftBottom = [box.minX, box.maxY];\r\n        var rightTop = [box.maxX, box.minY];\r\n        var rightBottom = [box.maxX, box.maxY];\r\n        var matrix = child.attr('matrix');\r\n        Vector2.transformMat2d(leftTop, leftTop, matrix);\r\n        Vector2.transformMat2d(leftBottom, leftBottom, matrix);\r\n        Vector2.transformMat2d(rightTop, rightTop, matrix);\r\n        Vector2.transformMat2d(rightBottom, rightBottom, matrix);\r\n        minX = Math.min(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0], minX);\r\n        maxX = Math.max(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0], maxX);\r\n        minY = Math.min(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1], minY);\r\n        maxY = Math.max(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1], maxY);\r\n      }\r\n    }\r\n\r\n    return {\r\n      minX: minX,\r\n      minY: minY,\r\n      maxX: maxX,\r\n      maxY: maxY,\r\n      x: minX,\r\n      y: minY,\r\n      width: maxX - minX,\r\n      height: maxY - minY\r\n    };\r\n  };\r\n\r\n  _proto.destroy = function destroy() {\r\n    if (this.get('destroyed')) {\r\n      return;\r\n    }\r\n\r\n    this.clear();\r\n\r\n    _Element.prototype.destroy.call(this);\r\n  };\r\n\r\n  return Group;\r\n}(Element);\r\n\r\nUtil.mix(Group.prototype, Container, {\r\n  getGroupClass: function getGroupClass() {\r\n    return Group;\r\n  }\r\n});\r\nmodule.exports = Group;","\r\n\r\nmodule.exports = {\r\n  requestAnimationFrame: typeof window === 'object' && window.requestAnimationFrame ? window.requestAnimationFrame : function (fn) {\r\n    return setTimeout(fn, 16);\r\n  }\r\n};","\r\n\r\nvar Util = require('../util/common');\r\n\r\nvar CanvasElement =\r\n/*#__PURE__*/\r\nfunction () {\r\n  function CanvasElement(ctx) {\r\n    this.context = ctx; // canvas实际的宽高 (width/height) * pixelRatio\r\n\r\n    this.width = 0;\r\n    this.height = 0;\r\n    this.style = {};\r\n    this.currentStyle = {}; // 用来标识是CanvasElement实例\r\n\r\n    this.isCanvasElement = true; // 实现简单的事件机制\r\n\r\n    this.__events = {};\r\n  }\r\n\r\n  var _proto = CanvasElement.prototype;\r\n\r\n  _proto.getContext = function getContext()\r\n  /* type */\r\n  {\r\n    return this.context;\r\n  };\r\n\r\n  _proto.getBoundingClientRect = function getBoundingClientRect() {\r\n    var width = this.width;\r\n    var height = this.height; // 默认都处理成可视窗口的顶部位置\r\n\r\n    return {\r\n      top: 0,\r\n      right: width,\r\n      bottom: height,\r\n      left: 0\r\n    };\r\n  };\r\n\r\n  _proto.addEventListener = function addEventListener(type, listener) {\r\n    var events = this.__events[type] || [];\r\n    events.push(listener);\r\n    this.__events[type] = events;\r\n  };\r\n\r\n  _proto.removeEventListener = function removeEventListener(type) {\r\n    delete this.__events[type];\r\n  };\r\n\r\n  _proto.dispatchEvent = function dispatchEvent(type, e) {\r\n    var _this = this;\r\n\r\n    if (Util.isObject(type)) {\r\n      e = type;\r\n      type = e && e.type;\r\n    }\r\n\r\n    if (!type) {\r\n      return;\r\n    }\r\n\r\n    var events = this.__events[type];\r\n\r\n    if (!events || !events.length) {\r\n      return;\r\n    }\r\n\r\n    events.forEach(function (listener) {\r\n      listener.call(_this, e);\r\n    });\r\n  };\r\n\r\n  return CanvasElement;\r\n}();\r\n\r\nfunction supportEventListener(canvas) {\r\n  if (!canvas) {\r\n    return false;\r\n  } // 非 HTMLCanvasElement\r\n\r\n\r\n  if (canvas.nodeType !== 1 || !canvas.nodeName || canvas.nodeName.toLowerCase() !== 'canvas') {\r\n    return false;\r\n  } // 微信小程序canvas.getContext('2d')时也是CanvasRenderingContext2D\r\n  // 也会有ctx.canvas, 而且nodeType也是1，所以还要在看下是否支持addEventListener\r\n\r\n\r\n  var support = false;\r\n\r\n  try {\r\n    canvas.addEventListener('eventTest', function () {\r\n      support = true;\r\n    });\r\n    canvas.dispatchEvent(new Event('eventTest'));\r\n  } catch (error) {\r\n    support = false;\r\n  }\r\n\r\n  return support;\r\n}\r\n\r\nmodule.exports = {\r\n  create: function create(ctx) {\r\n    if (!ctx) {\r\n      return null;\r\n    }\r\n\r\n    if (supportEventListener(ctx.canvas)) {\r\n      return ctx.canvas;\r\n    }\r\n\r\n    return new CanvasElement(ctx);\r\n  }\r\n};","\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\r\n\r\nvar Util = require('../../util/common');\r\n\r\nvar Shape = require('../shape');\r\n\r\nvar Rect =\r\n/*#__PURE__*/\r\nfunction (_Shape) {\r\n  (0, _inheritsLoose2[\"default\"])(Rect, _Shape);\r\n\r\n  function Rect() {\r\n    return _Shape.apply(this, arguments) || this;\r\n  }\r\n\r\n  var _proto = Rect.prototype;\r\n\r\n  _proto._initProperties = function _initProperties() {\r\n    _Shape.prototype._initProperties.call(this);\r\n\r\n    this._attrs.canFill = true;\r\n    this._attrs.canStroke = true;\r\n    this._attrs.type = 'rect';\r\n  };\r\n\r\n  _proto.getDefaultAttrs = function getDefaultAttrs() {\r\n    return {\r\n      x: 0,\r\n      y: 0,\r\n      width: 0,\r\n      height: 0,\r\n      radius: 0,\r\n      lineWidth: 0\r\n    };\r\n  };\r\n\r\n  _proto.createPath = function createPath(context) {\r\n    var self = this;\r\n    var attrs = self.get('attrs');\r\n    var x = attrs.x,\r\n        y = attrs.y,\r\n        width = attrs.width,\r\n        height = attrs.height;\r\n    context.beginPath();\r\n    var radius = attrs.radius;\r\n\r\n    if (!radius || !(width * height)) {\r\n      context.rect(x, y, width, height);\r\n    } else {\r\n      radius = Util.parsePadding(radius);\r\n      context.moveTo(x + radius[0], y);\r\n      context.lineTo(x + width - radius[1], y);\r\n      context.arc(x + width - radius[1], y + radius[1], radius[1], -Math.PI / 2, 0, false);\r\n      context.lineTo(x + width, y + height - radius[2]);\r\n      context.arc(x + width - radius[2], y + height - radius[2], radius[2], 0, Math.PI / 2, false);\r\n      context.lineTo(x + radius[3], y + height);\r\n      context.arc(x + radius[3], y + height - radius[3], radius[3], Math.PI / 2, Math.PI, false);\r\n      context.lineTo(x, y + radius[0]);\r\n      context.arc(x + radius[0], y + radius[0], radius[0], Math.PI, Math.PI * 3 / 2, false);\r\n      context.closePath();\r\n    }\r\n  };\r\n\r\n  _proto.calculateBox = function calculateBox() {\r\n    var attrs = this.get('attrs');\r\n    var x = attrs.x,\r\n        y = attrs.y,\r\n        width = attrs.width,\r\n        height = attrs.height;\r\n    return {\r\n      minX: x,\r\n      minY: y,\r\n      maxX: x + width,\r\n      maxY: y + height\r\n    };\r\n  };\r\n\r\n  return Rect;\r\n}(Shape);\r\n\r\nShape.Rect = Rect;\r\nmodule.exports = Rect;","\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\r\n\r\nvar Shape = require('../shape');\r\n\r\nvar Circle =\r\n/*#__PURE__*/\r\nfunction (_Shape) {\r\n  (0, _inheritsLoose2[\"default\"])(Circle, _Shape);\r\n\r\n  function Circle() {\r\n    return _Shape.apply(this, arguments) || this;\r\n  }\r\n\r\n  var _proto = Circle.prototype;\r\n\r\n  _proto._initProperties = function _initProperties() {\r\n    _Shape.prototype._initProperties.call(this);\r\n\r\n    this._attrs.canFill = true;\r\n    this._attrs.canStroke = true;\r\n    this._attrs.type = 'circle';\r\n  };\r\n\r\n  _proto.getDefaultAttrs = function getDefaultAttrs() {\r\n    return {\r\n      x: 0,\r\n      y: 0,\r\n      r: 0,\r\n      lineWidth: 0\r\n    };\r\n  };\r\n\r\n  _proto.createPath = function createPath(context) {\r\n    var attrs = this.get('attrs');\r\n    var x = attrs.x,\r\n        y = attrs.y,\r\n        r = attrs.r;\r\n    context.beginPath();\r\n    context.arc(x, y, r, 0, Math.PI * 2, false);\r\n    context.closePath();\r\n  };\r\n\r\n  _proto.calculateBox = function calculateBox() {\r\n    var attrs = this.get('attrs');\r\n    var x = attrs.x,\r\n        y = attrs.y,\r\n        r = attrs.r;\r\n    return {\r\n      minX: x - r,\r\n      maxX: x + r,\r\n      minY: y - r,\r\n      maxY: y + r\r\n    };\r\n  };\r\n\r\n  return Circle;\r\n}(Shape);\r\n\r\nShape.Circle = Circle;\r\nmodule.exports = Circle;","\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\r\n\r\nvar Shape = require('../shape');\r\n\r\nvar bbox = require('../util/bbox');\r\n\r\nvar Line =\r\n/*#__PURE__*/\r\nfunction (_Shape) {\r\n  (0, _inheritsLoose2[\"default\"])(Line, _Shape);\r\n\r\n  function Line() {\r\n    return _Shape.apply(this, arguments) || this;\r\n  }\r\n\r\n  var _proto = Line.prototype;\r\n\r\n  _proto._initProperties = function _initProperties() {\r\n    _Shape.prototype._initProperties.call(this);\r\n\r\n    this._attrs.canStroke = true;\r\n    this._attrs.type = 'line';\r\n  };\r\n\r\n  _proto.getDefaultAttrs = function getDefaultAttrs() {\r\n    return {\r\n      x1: 0,\r\n      y1: 0,\r\n      x2: 0,\r\n      y2: 0,\r\n      lineWidth: 1\r\n    };\r\n  };\r\n\r\n  _proto.createPath = function createPath(context) {\r\n    var attrs = this.get('attrs');\r\n    var x1 = attrs.x1,\r\n        y1 = attrs.y1,\r\n        x2 = attrs.x2,\r\n        y2 = attrs.y2;\r\n    context.beginPath();\r\n    context.moveTo(x1, y1);\r\n    context.lineTo(x2, y2);\r\n  };\r\n\r\n  _proto.calculateBox = function calculateBox() {\r\n    var attrs = this.get('attrs');\r\n    var x1 = attrs.x1,\r\n        y1 = attrs.y1,\r\n        x2 = attrs.x2,\r\n        y2 = attrs.y2,\r\n        lineWidth = attrs.lineWidth;\r\n    return bbox.getBBoxFromLine(x1, y1, x2, y2, lineWidth);\r\n  };\r\n\r\n  return Line;\r\n}(Shape);\r\n\r\nShape.Line = Line;\r\nmodule.exports = Line;","\r\n\r\nvar Vector2 = require('./vector2');\r\n\r\nvar start = Vector2.create();\r\nvar end = Vector2.create();\r\nvar extremity = Vector2.create();\r\n\r\nfunction getCubicBezierXYatT(startPt, controlPt1, controlPt2, endPt, T) {\r\n  var x = CubicN(T, startPt.x, controlPt1.x, controlPt2.x, endPt.x);\r\n  var y = CubicN(T, startPt.y, controlPt1.y, controlPt2.y, endPt.y);\r\n  return {\r\n    x: x,\r\n    y: y\r\n  };\r\n} // cubic helper formula at T distance\r\n\r\n\r\nfunction CubicN(T, a, b, c, d) {\r\n  var t2 = T * T;\r\n  var t3 = t2 * T;\r\n  return a + (-a * 3 + T * (3 * a - a * T)) * T + (3 * b + T * (-6 * b + b * 3 * T)) * T + (c * 3 - c * 3 * T) * t2 + d * t3;\r\n}\r\n\r\nfunction cubicBezierBounds(c) {\r\n  var minX = Infinity;\r\n  var maxX = -Infinity;\r\n  var minY = Infinity;\r\n  var maxY = -Infinity;\r\n  var s = {\r\n    x: c[0],\r\n    y: c[1]\r\n  };\r\n  var c1 = {\r\n    x: c[2],\r\n    y: c[3]\r\n  };\r\n  var c2 = {\r\n    x: c[4],\r\n    y: c[5]\r\n  };\r\n  var e = {\r\n    x: c[6],\r\n    y: c[7]\r\n  };\r\n\r\n  for (var t = 0; t < 100; t++) {\r\n    var pt = getCubicBezierXYatT(s, c1, c2, e, t / 100);\r\n\r\n    if (pt.x < minX) {\r\n      minX = pt.x;\r\n    }\r\n\r\n    if (pt.x > maxX) {\r\n      maxX = pt.x;\r\n    }\r\n\r\n    if (pt.y < minY) {\r\n      minY = pt.y;\r\n    }\r\n\r\n    if (pt.y > maxY) {\r\n      maxY = pt.y;\r\n    }\r\n  }\r\n\r\n  return {\r\n    minX: minX,\r\n    minY: minY,\r\n    maxX: maxX,\r\n    maxY: maxY\r\n  };\r\n}\r\n\r\nmodule.exports = {\r\n  getBBoxFromPoints: function getBBoxFromPoints(points, lineWidth) {\r\n    if (points.length === 0) {\r\n      return;\r\n    }\r\n\r\n    var p = points[0];\r\n    var left = p.x;\r\n    var right = p.x;\r\n    var top = p.y;\r\n    var bottom = p.y;\r\n    var len = points.length;\r\n\r\n    for (var i = 1; i < len; i++) {\r\n      p = points[i];\r\n      left = Math.min(left, p.x);\r\n      right = Math.max(right, p.x);\r\n      top = Math.min(top, p.y);\r\n      bottom = Math.max(bottom, p.y);\r\n    }\r\n\r\n    lineWidth = lineWidth / 2 || 0;\r\n    return {\r\n      minX: left - lineWidth,\r\n      minY: top - lineWidth,\r\n      maxX: right + lineWidth,\r\n      maxY: bottom + lineWidth\r\n    };\r\n  },\r\n  getBBoxFromLine: function getBBoxFromLine(x0, y0, x1, y1, lineWidth) {\r\n    lineWidth = lineWidth / 2 || 0;\r\n    return {\r\n      minX: Math.min(x0, x1) - lineWidth,\r\n      minY: Math.min(y0, y1) - lineWidth,\r\n      maxX: Math.max(x0, x1) + lineWidth,\r\n      maxY: Math.max(y0, y1) + lineWidth\r\n    };\r\n  },\r\n  getBBoxFromArc: function getBBoxFromArc(x, y, r, startAngle, endAngle, anticlockwise) {\r\n    var diff = Math.abs(startAngle - endAngle);\r\n\r\n    if (diff % (Math.PI * 2) < 1e-4 && diff > 1e-4) {\r\n      // Is a circle\r\n      return {\r\n        minX: x - r,\r\n        minY: y - r,\r\n        maxX: x + r,\r\n        maxY: y + r\r\n      };\r\n    }\r\n\r\n    start[0] = Math.cos(startAngle) * r + x;\r\n    start[1] = Math.sin(startAngle) * r + y;\r\n    end[0] = Math.cos(endAngle) * r + x;\r\n    end[1] = Math.sin(endAngle) * r + y;\r\n    var min = [0, 0];\r\n    var max = [0, 0];\r\n    Vector2.min(min, start, end);\r\n    Vector2.max(max, start, end); // Thresh to [0, Math.PI * 2]\r\n\r\n    startAngle = startAngle % (Math.PI * 2);\r\n\r\n    if (startAngle < 0) {\r\n      startAngle = startAngle + Math.PI * 2;\r\n    }\r\n\r\n    endAngle = endAngle % (Math.PI * 2);\r\n\r\n    if (endAngle < 0) {\r\n      endAngle = endAngle + Math.PI * 2;\r\n    }\r\n\r\n    if (startAngle > endAngle && !anticlockwise) {\r\n      endAngle += Math.PI * 2;\r\n    } else if (startAngle < endAngle && anticlockwise) {\r\n      startAngle += Math.PI * 2;\r\n    }\r\n\r\n    if (anticlockwise) {\r\n      var tmp = endAngle;\r\n      endAngle = startAngle;\r\n      startAngle = tmp;\r\n    }\r\n\r\n    for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\r\n      if (angle > startAngle) {\r\n        extremity[0] = Math.cos(angle) * r + x;\r\n        extremity[1] = Math.sin(angle) * r + y;\r\n        Vector2.min(min, extremity, min);\r\n        Vector2.max(max, extremity, max);\r\n      }\r\n    }\r\n\r\n    return {\r\n      minX: min[0],\r\n      minY: min[1],\r\n      maxX: max[0],\r\n      maxY: max[1]\r\n    };\r\n  },\r\n  getBBoxFromBezierGroup: function getBBoxFromBezierGroup(points, lineWidth) {\r\n    var minX = Infinity;\r\n    var maxX = -Infinity;\r\n    var minY = Infinity;\r\n    var maxY = -Infinity;\r\n\r\n    for (var i = 0, len = points.length; i < len; i++) {\r\n      var bbox = cubicBezierBounds(points[i]);\r\n\r\n      if (bbox.minX < minX) {\r\n        minX = bbox.minX;\r\n      }\r\n\r\n      if (bbox.maxX > maxX) {\r\n        maxX = bbox.maxX;\r\n      }\r\n\r\n      if (bbox.minY < minY) {\r\n        minY = bbox.minY;\r\n      }\r\n\r\n      if (bbox.maxY > maxY) {\r\n        maxY = bbox.maxY;\r\n      }\r\n    }\r\n\r\n    lineWidth = lineWidth / 2 || 0;\r\n    return {\r\n      minX: minX - lineWidth,\r\n      minY: minY - lineWidth,\r\n      maxX: maxX + lineWidth,\r\n      maxY: maxY + lineWidth\r\n    };\r\n  }\r\n};","\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\r\n\r\nvar Shape = require('../shape');\r\n\r\nvar bbox = require('../util/bbox');\r\n\r\nvar Polygon =\r\n/*#__PURE__*/\r\nfunction (_Shape) {\r\n  (0, _inheritsLoose2[\"default\"])(Polygon, _Shape);\r\n\r\n  function Polygon() {\r\n    return _Shape.apply(this, arguments) || this;\r\n  }\r\n\r\n  var _proto = Polygon.prototype;\r\n\r\n  _proto._initProperties = function _initProperties() {\r\n    _Shape.prototype._initProperties.call(this);\r\n\r\n    this._attrs.canFill = true;\r\n    this._attrs.canStroke = true;\r\n    this._attrs.type = 'polygon';\r\n  };\r\n\r\n  _proto.getDefaultAttrs = function getDefaultAttrs() {\r\n    return {\r\n      points: null,\r\n      lineWidth: 0\r\n    };\r\n  };\r\n\r\n  _proto.createPath = function createPath(context) {\r\n    var self = this;\r\n    var attrs = self.get('attrs');\r\n    var points = attrs.points;\r\n    context.beginPath();\r\n\r\n    for (var i = 0, len = points.length; i < len; i++) {\r\n      var point = points[i];\r\n\r\n      if (i === 0) {\r\n        context.moveTo(point.x, point.y);\r\n      } else {\r\n        context.lineTo(point.x, point.y);\r\n      }\r\n    }\r\n\r\n    context.closePath();\r\n  };\r\n\r\n  _proto.calculateBox = function calculateBox() {\r\n    var attrs = this.get('attrs');\r\n    var points = attrs.points;\r\n    return bbox.getBBoxFromPoints(points);\r\n  };\r\n\r\n  return Polygon;\r\n}(Shape);\r\n\r\nShape.Polygon = Polygon;\r\nmodule.exports = Polygon;","\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\r\n\r\nvar Shape = require('../shape');\r\n\r\nvar Smooth = require('../util/smooth');\r\n\r\nvar bbox = require('../util/bbox'); // filter the point which x or y is NaN\r\n\r\n\r\nfunction _filterPoints(points) {\r\n  var filteredPoints = [];\r\n\r\n  for (var i = 0, len = points.length; i < len; i++) {\r\n    var point = points[i];\r\n\r\n    if (!isNaN(point.x) && !isNaN(point.y)) {\r\n      filteredPoints.push(point);\r\n    }\r\n  }\r\n\r\n  return filteredPoints;\r\n}\r\n\r\nvar Polyline =\r\n/*#__PURE__*/\r\nfunction (_Shape) {\r\n  (0, _inheritsLoose2[\"default\"])(Polyline, _Shape);\r\n\r\n  function Polyline() {\r\n    return _Shape.apply(this, arguments) || this;\r\n  }\r\n\r\n  var _proto = Polyline.prototype;\r\n\r\n  _proto._initProperties = function _initProperties() {\r\n    _Shape.prototype._initProperties.call(this);\r\n\r\n    this._attrs.canFill = true;\r\n    this._attrs.canStroke = true;\r\n    this._attrs.type = 'polyline';\r\n  };\r\n\r\n  _proto.getDefaultAttrs = function getDefaultAttrs() {\r\n    return {\r\n      points: null,\r\n      lineWidth: 1,\r\n      smooth: false\r\n    };\r\n  };\r\n\r\n  _proto.createPath = function createPath(context) {\r\n    var self = this;\r\n    var attrs = self.get('attrs');\r\n    var points = attrs.points,\r\n        smooth = attrs.smooth;\r\n\r\n    var filteredPoints = _filterPoints(points);\r\n\r\n    context.beginPath();\r\n\r\n    if (filteredPoints.length) {\r\n      context.moveTo(filteredPoints[0].x, filteredPoints[0].y);\r\n\r\n      if (smooth) {\r\n        var constaint = [[0, 0], [1, 1]];\r\n        var sps = Smooth.smooth(filteredPoints, false, constaint);\r\n\r\n        for (var i = 0, n = sps.length; i < n; i++) {\r\n          var sp = sps[i];\r\n          context.bezierCurveTo(sp[1], sp[2], sp[3], sp[4], sp[5], sp[6]);\r\n        }\r\n      } else {\r\n        var _i;\r\n\r\n        var l;\r\n\r\n        for (_i = 1, l = filteredPoints.length - 1; _i < l; _i++) {\r\n          context.lineTo(filteredPoints[_i].x, filteredPoints[_i].y);\r\n        }\r\n\r\n        context.lineTo(filteredPoints[l].x, filteredPoints[l].y);\r\n      }\r\n    }\r\n  };\r\n\r\n  _proto.calculateBox = function calculateBox() {\r\n    var attrs = this.get('attrs');\r\n    var points = attrs.points,\r\n        smooth = attrs.smooth,\r\n        lineWidth = attrs.lineWidth;\r\n\r\n    var filteredPoints = _filterPoints(points);\r\n\r\n    if (smooth) {\r\n      var newPoints = [];\r\n      var constaint = [[0, 0], [1, 1]];\r\n      var sps = Smooth.smooth(filteredPoints, false, constaint);\r\n\r\n      for (var i = 0, n = sps.length; i < n; i++) {\r\n        var sp = sps[i];\r\n\r\n        if (i === 0) {\r\n          newPoints.push([filteredPoints[0].x, filteredPoints[0].y, sp[1], sp[2], sp[3], sp[4], sp[5], sp[6]]);\r\n        } else {\r\n          var lastPoint = sps[i - 1];\r\n          newPoints.push([lastPoint[5], lastPoint[6], sp[1], sp[2], sp[3], sp[4], sp[5], sp[6]]);\r\n        }\r\n      }\r\n\r\n      return bbox.getBBoxFromBezierGroup(newPoints, lineWidth);\r\n    }\r\n\r\n    return bbox.getBBoxFromPoints(filteredPoints, lineWidth);\r\n  };\r\n\r\n  return Polyline;\r\n}(Shape);\r\n\r\nShape.Polyline = Polyline;\r\nmodule.exports = Polyline;","\r\n\r\n/**\r\n * @fileOverview convert the line to curve\r\n * @author dxq613@gmail.com\r\n */\r\nvar Vector2 = require('./vector2');\r\n\r\nfunction getPoint(v) {\r\n  return [v.x, v.y];\r\n}\r\n\r\nfunction smoothBezier(points, smooth, isLoop, constraint) {\r\n  var cps = [];\r\n  var prevPoint;\r\n  var nextPoint;\r\n  var hasConstraint = !!constraint;\r\n  var min;\r\n  var max;\r\n  var point;\r\n  var len;\r\n  var l;\r\n  var i;\r\n\r\n  if (hasConstraint) {\r\n    min = [Infinity, Infinity];\r\n    max = [-Infinity, -Infinity];\r\n\r\n    for (i = 0, l = points.length; i < l; i++) {\r\n      point = getPoint(points[i]);\r\n      Vector2.min(min, min, point);\r\n      Vector2.max(max, max, point);\r\n    }\r\n\r\n    Vector2.min(min, min, constraint[0]);\r\n    Vector2.max(max, max, constraint[1]);\r\n  }\r\n\r\n  for (i = 0, len = points.length; i < len; i++) {\r\n    point = getPoint(points[i]);\r\n\r\n    if (isLoop) {\r\n      prevPoint = getPoint(points[i ? i - 1 : len - 1]);\r\n      nextPoint = getPoint(points[(i + 1) % len]);\r\n    } else {\r\n      if (i === 0 || i === len - 1) {\r\n        cps.push([point[0], point[1]]);\r\n        continue;\r\n      } else {\r\n        prevPoint = getPoint(points[i - 1]);\r\n        nextPoint = getPoint(points[i + 1]);\r\n      }\r\n    }\r\n\r\n    var v = Vector2.sub([], nextPoint, prevPoint);\r\n    Vector2.scale(v, v, smooth);\r\n    var d0 = Vector2.distance(point, prevPoint);\r\n    var d1 = Vector2.distance(point, nextPoint);\r\n    var sum = d0 + d1;\r\n\r\n    if (sum !== 0) {\r\n      d0 /= sum;\r\n      d1 /= sum;\r\n    }\r\n\r\n    var v1 = Vector2.scale([], v, -d0);\r\n    var v2 = Vector2.scale([], v, d1);\r\n    var cp0 = Vector2.add([], point, v1);\r\n    var cp1 = Vector2.add([], point, v2);\r\n\r\n    if (hasConstraint) {\r\n      Vector2.max(cp0, cp0, min);\r\n      Vector2.min(cp0, cp0, max);\r\n      Vector2.max(cp1, cp1, min);\r\n      Vector2.min(cp1, cp1, max);\r\n    }\r\n\r\n    cps.push([cp0[0], cp0[1]]);\r\n    cps.push([cp1[0], cp1[1]]);\r\n  }\r\n\r\n  if (isLoop) {\r\n    cps.push(cps.shift());\r\n  }\r\n\r\n  return cps;\r\n}\r\n\r\nfunction catmullRom2bezier(pointList, z, constraint) {\r\n  var isLoop = !!z;\r\n  var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);\r\n  var len = pointList.length;\r\n  var d1 = [];\r\n  var cp1;\r\n  var cp2;\r\n  var p;\r\n\r\n  for (var i = 0; i < len - 1; i++) {\r\n    cp1 = controlPointList[i * 2];\r\n    cp2 = controlPointList[i * 2 + 1];\r\n    p = pointList[i + 1];\r\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p.x, p.y]);\r\n  }\r\n\r\n  if (isLoop) {\r\n    cp1 = controlPointList[len];\r\n    cp2 = controlPointList[len + 1];\r\n    p = pointList[0];\r\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p.x, p.y]);\r\n  }\r\n\r\n  return d1;\r\n}\r\n\r\nmodule.exports = {\r\n  smooth: catmullRom2bezier\r\n};","\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\r\n\r\nvar Shape = require('../shape');\r\n\r\nvar bbox = require('../util/bbox');\r\n\r\nvar Arc =\r\n/*#__PURE__*/\r\nfunction (_Shape) {\r\n  (0, _inheritsLoose2[\"default\"])(Arc, _Shape);\r\n\r\n  function Arc() {\r\n    return _Shape.apply(this, arguments) || this;\r\n  }\r\n\r\n  var _proto = Arc.prototype;\r\n\r\n  _proto._initProperties = function _initProperties() {\r\n    _Shape.prototype._initProperties.call(this);\r\n\r\n    this._attrs.canStroke = true;\r\n    this._attrs.canFill = true;\r\n    this._attrs.type = 'arc';\r\n  };\r\n\r\n  _proto.getDefaultAttrs = function getDefaultAttrs() {\r\n    return {\r\n      x: 0,\r\n      y: 0,\r\n      r: 0,\r\n      startAngle: 0,\r\n      endAngle: Math.PI * 2,\r\n      anticlockwise: false,\r\n      lineWidth: 1\r\n    };\r\n  };\r\n\r\n  _proto.createPath = function createPath(context) {\r\n    var attrs = this.get('attrs');\r\n    var x = attrs.x,\r\n        y = attrs.y,\r\n        r = attrs.r,\r\n        startAngle = attrs.startAngle,\r\n        endAngle = attrs.endAngle,\r\n        anticlockwise = attrs.anticlockwise;\r\n    context.beginPath();\r\n\r\n    if (startAngle !== endAngle) {\r\n      context.arc(x, y, r, startAngle, endAngle, anticlockwise);\r\n    }\r\n  };\r\n\r\n  _proto.calculateBox = function calculateBox() {\r\n    var attrs = this.get('attrs');\r\n    var x = attrs.x,\r\n        y = attrs.y,\r\n        r = attrs.r,\r\n        startAngle = attrs.startAngle,\r\n        endAngle = attrs.endAngle,\r\n        anticlockwise = attrs.anticlockwise;\r\n    return bbox.getBBoxFromArc(x, y, r, startAngle, endAngle, anticlockwise);\r\n  };\r\n\r\n  return Arc;\r\n}(Shape);\r\n\r\nShape.Arc = Arc;\r\nmodule.exports = Arc;","\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\r\n\r\nvar Shape = require('../shape');\r\n\r\nvar bbox = require('../util/bbox');\r\n\r\nvar Sector =\r\n/*#__PURE__*/\r\nfunction (_Shape) {\r\n  (0, _inheritsLoose2[\"default\"])(Sector, _Shape);\r\n\r\n  function Sector() {\r\n    return _Shape.apply(this, arguments) || this;\r\n  }\r\n\r\n  var _proto = Sector.prototype;\r\n\r\n  _proto._initProperties = function _initProperties() {\r\n    _Shape.prototype._initProperties.call(this);\r\n\r\n    this._attrs.canFill = true;\r\n    this._attrs.canStroke = true;\r\n    this._attrs.type = 'sector';\r\n  };\r\n\r\n  _proto.getDefaultAttrs = function getDefaultAttrs() {\r\n    return {\r\n      x: 0,\r\n      y: 0,\r\n      lineWidth: 0,\r\n      r: 0,\r\n      r0: 0,\r\n      startAngle: 0,\r\n      endAngle: Math.PI * 2,\r\n      anticlockwise: false\r\n    };\r\n  };\r\n\r\n  _proto.createPath = function createPath(context) {\r\n    var attrs = this.get('attrs');\r\n    var x = attrs.x,\r\n        y = attrs.y,\r\n        startAngle = attrs.startAngle,\r\n        endAngle = attrs.endAngle,\r\n        r = attrs.r,\r\n        r0 = attrs.r0,\r\n        anticlockwise = attrs.anticlockwise;\r\n    context.beginPath();\r\n    var unitX = Math.cos(startAngle);\r\n    var unitY = Math.sin(startAngle);\r\n    context.moveTo(unitX * r0 + x, unitY * r0 + y);\r\n    context.lineTo(unitX * r + x, unitY * r + y); // 当扇形的角度非常小的时候，就不进行弧线的绘制；或者整个只有1个扇形时，会出现end<0的情况不绘制\r\n\r\n    if (Math.abs(endAngle - startAngle) > 0.0001 || startAngle === 0 && endAngle < 0) {\r\n      context.arc(x, y, r, startAngle, endAngle, anticlockwise);\r\n      context.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);\r\n\r\n      if (r0 !== 0) {\r\n        context.arc(x, y, r0, endAngle, startAngle, !anticlockwise);\r\n      }\r\n    }\r\n\r\n    context.closePath();\r\n  };\r\n\r\n  _proto.calculateBox = function calculateBox() {\r\n    var attrs = this.get('attrs');\r\n    var x = attrs.x,\r\n        y = attrs.y,\r\n        r = attrs.r,\r\n        r0 = attrs.r0,\r\n        startAngle = attrs.startAngle,\r\n        endAngle = attrs.endAngle,\r\n        anticlockwise = attrs.anticlockwise;\r\n    var outerBBox = bbox.getBBoxFromArc(x, y, r, startAngle, endAngle, anticlockwise);\r\n    var innerBBox = bbox.getBBoxFromArc(x, y, r0, startAngle, endAngle, anticlockwise);\r\n    return {\r\n      minX: Math.min(outerBBox.minX, innerBBox.minX),\r\n      minY: Math.min(outerBBox.minY, innerBBox.minY),\r\n      maxX: Math.max(outerBBox.maxX, innerBBox.maxX),\r\n      maxY: Math.max(outerBBox.maxY, innerBBox.maxY)\r\n    };\r\n  };\r\n\r\n  return Sector;\r\n}(Shape);\r\n\r\nShape.Sector = Sector;\r\nmodule.exports = Sector;","\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\r\n\r\nvar Util = require('../../util/common');\r\n\r\nvar Shape = require('../shape');\r\n\r\nvar RectUtil = require('../util/rect');\r\n\r\nvar textWidthCacheCounter = 0;\r\nvar textWidthCache = {};\r\nvar TEXT_CACHE_MAX = 5000;\r\n\r\nvar Text =\r\n/*#__PURE__*/\r\nfunction (_Shape) {\r\n  (0, _inheritsLoose2[\"default\"])(Text, _Shape);\r\n\r\n  function Text() {\r\n    return _Shape.apply(this, arguments) || this;\r\n  }\r\n\r\n  var _proto = Text.prototype;\r\n\r\n  _proto._initProperties = function _initProperties() {\r\n    _Shape.prototype._initProperties.call(this);\r\n\r\n    this._attrs.canFill = true;\r\n    this._attrs.canStroke = true;\r\n    this._attrs.type = 'text';\r\n  };\r\n\r\n  _proto.getDefaultAttrs = function getDefaultAttrs() {\r\n    return {\r\n      lineWidth: 0,\r\n      lineCount: 1,\r\n      fontSize: 12,\r\n      fontFamily: 'sans-serif',\r\n      fontStyle: 'normal',\r\n      fontWeight: 'normal',\r\n      fontVariant: 'normal',\r\n      textAlign: 'start',\r\n      textBaseline: 'bottom',\r\n      lineHeight: null,\r\n      textArr: null\r\n    };\r\n  };\r\n\r\n  _proto._getFontStyle = function _getFontStyle() {\r\n    var attrs = this._attrs.attrs;\r\n    var fontSize = attrs.fontSize,\r\n        fontFamily = attrs.fontFamily,\r\n        fontWeight = attrs.fontWeight,\r\n        fontStyle = attrs.fontStyle,\r\n        fontVariant = attrs.fontVariant;\r\n    return fontStyle + \" \" + fontVariant + \" \" + fontWeight + \" \" + fontSize + \"px \" + fontFamily;\r\n  };\r\n\r\n  _proto._afterAttrsSet = function _afterAttrsSet() {\r\n    var attrs = this._attrs.attrs;\r\n    attrs.font = this._getFontStyle();\r\n\r\n    if (attrs.text) {\r\n      var text = attrs.text;\r\n      var textArr = null;\r\n      var lineCount = 1;\r\n\r\n      if (Util.isString(text) && text.indexOf('\\n') !== -1) {\r\n        textArr = text.split('\\n');\r\n        lineCount = textArr.length;\r\n      }\r\n\r\n      attrs.lineCount = lineCount;\r\n      attrs.textArr = textArr;\r\n    }\r\n\r\n    this.set('attrs', attrs);\r\n  };\r\n\r\n  _proto._getTextHeight = function _getTextHeight() {\r\n    var attrs = this._attrs.attrs;\r\n\r\n    if (attrs.height) {\r\n      return attrs.height;\r\n    }\r\n\r\n    var lineCount = attrs.lineCount;\r\n    var fontSize = attrs.fontSize * 1;\r\n\r\n    if (lineCount > 1) {\r\n      var spaceingY = this._getSpaceingY();\r\n\r\n      return fontSize * lineCount + spaceingY * (lineCount - 1);\r\n    }\r\n\r\n    return fontSize;\r\n  };\r\n\r\n  _proto._getSpaceingY = function _getSpaceingY() {\r\n    var attrs = this._attrs.attrs;\r\n    var lineHeight = attrs.lineHeight;\r\n    var fontSize = attrs.fontSize * 1;\r\n    return lineHeight ? lineHeight - fontSize : fontSize * 0.14;\r\n  };\r\n\r\n  _proto.drawInner = function drawInner(context) {\r\n    var self = this;\r\n    var attrs = self._attrs.attrs;\r\n    var text = attrs.text;\r\n    var x = attrs.x;\r\n    var y = attrs.y;\r\n\r\n    if (Util.isNil(text) || isNaN(x) || isNaN(y)) {\r\n      // text will be 0\r\n      return;\r\n    }\r\n\r\n    var textArr = attrs.textArr;\r\n    var fontSize = attrs.fontSize * 1;\r\n\r\n    var spaceingY = self._getSpaceingY();\r\n\r\n    if (attrs.rotate) {\r\n      // do rotation\r\n      context.translate(x, y);\r\n      context.rotate(attrs.rotate);\r\n      x = 0;\r\n      y = 0;\r\n    }\r\n\r\n    var textBaseline = attrs.textBaseline;\r\n    var height;\r\n\r\n    if (textArr) {\r\n      height = self._getTextHeight();\r\n    }\r\n\r\n    var subY; // context.beginPath();\r\n\r\n    if (self.hasFill()) {\r\n      var fillOpacity = attrs.fillOpacity;\r\n\r\n      if (!Util.isNil(fillOpacity) && fillOpacity !== 1) {\r\n        context.globalAlpha = fillOpacity;\r\n      }\r\n\r\n      if (textArr) {\r\n        for (var i = 0, len = textArr.length; i < len; i++) {\r\n          var subText = textArr[i];\r\n          subY = y + i * (spaceingY + fontSize) - height + fontSize; // bottom;\r\n\r\n          if (textBaseline === 'middle') {\r\n            subY += height - fontSize - (height - fontSize) / 2;\r\n          }\r\n\r\n          if (textBaseline === 'top') {\r\n            subY += height - fontSize;\r\n          }\r\n\r\n          context.fillText(subText, x, subY);\r\n        }\r\n      } else {\r\n        context.fillText(text, x, y);\r\n      }\r\n    }\r\n\r\n    if (self.hasStroke()) {\r\n      if (textArr) {\r\n        for (var _i = 0, _len = textArr.length; _i < _len; _i++) {\r\n          var _subText = textArr[_i];\r\n          subY = y + _i * (spaceingY + fontSize) - height + fontSize; // bottom;\r\n\r\n          if (textBaseline === 'middle') {\r\n            subY += height - fontSize - (height - fontSize) / 2;\r\n          }\r\n\r\n          if (textBaseline === 'top') {\r\n            subY += height - fontSize;\r\n          }\r\n\r\n          context.strokeText(_subText, x, subY);\r\n        }\r\n      } else {\r\n        context.strokeText(text, x, y);\r\n      }\r\n    }\r\n  };\r\n\r\n  _proto.calculateBox = function calculateBox() {\r\n    var self = this;\r\n    var attrs = self._attrs.attrs;\r\n    var x = attrs.x,\r\n        y = attrs.y,\r\n        textAlign = attrs.textAlign,\r\n        textBaseline = attrs.textBaseline;\r\n\r\n    var width = self._getTextWidth(); // attrs.width\r\n\r\n\r\n    if (!width) {\r\n      return {\r\n        minX: x,\r\n        minY: y,\r\n        maxX: x,\r\n        maxY: y\r\n      };\r\n    }\r\n\r\n    var height = self._getTextHeight(); // attrs.height\r\n\r\n\r\n    if (attrs.rotate) {\r\n      var rotatedBox = RectUtil.calcRotatedBox({\r\n        width: width,\r\n        height: height,\r\n        rotate: attrs.rotate\r\n      });\r\n      width = rotatedBox.width;\r\n      height = rotatedBox.height;\r\n    }\r\n\r\n    var point = {\r\n      x: x,\r\n      y: y - height\r\n    }; // default textAlign: start, textBaseline: bottom\r\n\r\n    if (textAlign) {\r\n      if (textAlign === 'end' || textAlign === 'right') {\r\n        point.x -= width;\r\n      } else if (textAlign === 'center') {\r\n        point.x -= width / 2;\r\n      }\r\n    }\r\n\r\n    if (textBaseline) {\r\n      if (textBaseline === 'top') {\r\n        point.y += height;\r\n      } else if (textBaseline === 'middle') {\r\n        point.y += height / 2;\r\n      }\r\n    }\r\n\r\n    return {\r\n      minX: point.x,\r\n      minY: point.y,\r\n      maxX: point.x + width,\r\n      maxY: point.y + height\r\n    };\r\n  };\r\n\r\n  _proto._getTextWidth = function _getTextWidth() {\r\n    var attrs = this._attrs.attrs;\r\n\r\n    if (attrs.width) {\r\n      return attrs.width;\r\n    }\r\n\r\n    var text = attrs.text;\r\n    var context = this.get('context');\r\n    if (Util.isNil(text)) return undefined;\r\n    var font = attrs.font;\r\n    var textArr = attrs.textArr;\r\n    var key = text + '' + font;\r\n\r\n    if (textWidthCache[key]) {\r\n      return textWidthCache[key];\r\n    }\r\n\r\n    var width = 0;\r\n\r\n    if (textArr) {\r\n      for (var i = 0, length = textArr.length; i < length; i++) {\r\n        var subText = textArr[i];\r\n        width = Math.max(width, Util.measureText(subText, font, context).width);\r\n      }\r\n    } else {\r\n      width = Util.measureText(text, font, context).width;\r\n    }\r\n\r\n    if (textWidthCacheCounter > TEXT_CACHE_MAX) {\r\n      textWidthCacheCounter = 0;\r\n      textWidthCache = {};\r\n    }\r\n\r\n    textWidthCacheCounter++;\r\n    textWidthCache[key] = width;\r\n    return width;\r\n  };\r\n\r\n  return Text;\r\n}(Shape);\r\n\r\nShape.Text = Text;\r\nmodule.exports = Text;","\r\n\r\nvar Rect = {\r\n  calcRotatedBox: function calcRotatedBox(_ref) {\r\n    var width = _ref.width,\r\n        height = _ref.height,\r\n        rotate = _ref.rotate;\r\n    var absRotate = Math.abs(rotate);\r\n    return {\r\n      width: Math.abs(width * Math.cos(absRotate) + height * Math.sin(absRotate)),\r\n      height: Math.abs(height * Math.cos(absRotate) + width * Math.sin(absRotate))\r\n    };\r\n  }\r\n};\r\nmodule.exports = Rect;","\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\r\n\r\nvar Shape = require('../shape');\r\n\r\nvar Custom =\r\n/*#__PURE__*/\r\nfunction (_Shape) {\r\n  (0, _inheritsLoose2[\"default\"])(Custom, _Shape);\r\n\r\n  function Custom() {\r\n    return _Shape.apply(this, arguments) || this;\r\n  }\r\n\r\n  var _proto = Custom.prototype;\r\n\r\n  _proto._initProperties = function _initProperties() {\r\n    _Shape.prototype._initProperties.call(this);\r\n\r\n    this._attrs.canFill = true;\r\n    this._attrs.canStroke = true;\r\n    this._attrs.createPath = null;\r\n    this._attrs.type = 'custom';\r\n  };\r\n\r\n  _proto.createPath = function createPath(context) {\r\n    var createPath = this.get('createPath');\r\n    createPath && createPath.call(this, context);\r\n  };\r\n\r\n  _proto.calculateBox = function calculateBox() {\r\n    var calculateBox = this.get('calculateBox');\r\n    return calculateBox && calculateBox.call(this);\r\n  };\r\n\r\n  return Custom;\r\n}(Shape);\r\n\r\nShape.Custom = Custom;\r\nmodule.exports = Custom;","\r\n\r\nvar _require = require('../graphic/index'),\r\n    Shape = _require.Shape;\r\n\r\nmodule.exports = {\r\n  getClip: function getClip(coord) {\r\n    var start = coord.start;\r\n    var end = coord.end;\r\n    var width = end.x - start.x;\r\n    var height = Math.abs(end.y - start.y);\r\n    var margin = 10;\r\n    var clip;\r\n\r\n    if (coord.isPolar) {\r\n      var circleRadius = coord.circleRadius,\r\n          center = coord.center,\r\n          startAngle = coord.startAngle,\r\n          endAngle = coord.endAngle;\r\n      clip = new Shape.Sector({\r\n        attrs: {\r\n          x: center.x,\r\n          y: center.y,\r\n          r: circleRadius,\r\n          r0: 0,\r\n          startAngle: startAngle,\r\n          endAngle: endAngle\r\n        }\r\n      });\r\n    } else {\r\n      clip = new Shape.Rect({\r\n        attrs: {\r\n          x: start.x,\r\n          y: end.y - margin,\r\n          width: width,\r\n          height: height + 2 * margin\r\n        }\r\n      });\r\n    }\r\n\r\n    clip.isClip = true;\r\n    return clip;\r\n  },\r\n  isPointInPlot: function isPointInPlot(point, plot) {\r\n    var x = point.x,\r\n        y = point.y;\r\n    var tl = plot.tl,\r\n        tr = plot.tr,\r\n        br = plot.br;\r\n    return x >= tl.x && x <= tr.x && y >= tl.y && y <= br.y;\r\n  }\r\n};","\r\n\r\nvar Geom = require('./base');\r\n\r\nrequire('./point');\r\n\r\nrequire('./path');\r\n\r\nrequire('./line');\r\n\r\nrequire('./area');\r\n\r\nrequire('./interval');\r\n\r\nrequire('./polygon');\r\n\r\nrequire('./schema');\r\n\r\nmodule.exports = Geom;","\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\r\n\r\nvar Util = require('../util/common');\r\n\r\nvar Geom = require('./base');\r\n\r\nrequire('./shape/point');\r\n\r\nvar Point =\r\n/*#__PURE__*/\r\nfunction (_Geom) {\r\n  (0, _inheritsLoose2[\"default\"])(Point, _Geom);\r\n\r\n  function Point() {\r\n    return _Geom.apply(this, arguments) || this;\r\n  }\r\n\r\n  var _proto = Point.prototype;\r\n\r\n  _proto.getDefaultCfg = function getDefaultCfg() {\r\n    var cfg = _Geom.prototype.getDefaultCfg.call(this);\r\n\r\n    cfg.type = 'point';\r\n    cfg.shapeType = 'point';\r\n    cfg.generatePoints = true;\r\n    return cfg;\r\n  };\r\n\r\n  _proto.draw = function draw(data, shapeFactory) {\r\n    var self = this;\r\n    var container = self.get('container');\r\n    Util.each(data, function (obj) {\r\n      var shape = obj.shape;\r\n      var cfg = self.getDrawCfg(obj);\r\n\r\n      if (Util.isArray(obj.y)) {\r\n        var hasStack = self.hasAdjust('stack');\r\n        Util.each(obj.y, function (y, idx) {\r\n          cfg.y = y;\r\n\r\n          if (!hasStack || idx !== 0) {\r\n            self.drawShape(shape, obj, cfg, container, shapeFactory);\r\n          }\r\n        });\r\n      } else if (!Util.isNil(obj.y)) {\r\n        self.drawShape(shape, obj, cfg, container, shapeFactory);\r\n      }\r\n    });\r\n  };\r\n\r\n  return Point;\r\n}(Geom);\r\n\r\nGeom.Point = Point;\r\nmodule.exports = Point;","\r\n\r\nvar Util = require('../../util/common');\r\n\r\nvar Global = require('../../global');\r\n\r\nvar ShapeUtil = require('./util');\r\n\r\nvar Shape = require('./shape');\r\n\r\nvar SHAPES = ['circle', 'hollowCircle', 'rect'];\r\nvar Point = Shape.registerFactory('point', {\r\n  defaultShapeType: 'circle',\r\n  getDefaultPoints: function getDefaultPoints(pointInfo) {\r\n    return ShapeUtil.splitPoints(pointInfo);\r\n  }\r\n});\r\n\r\nfunction getPointsCfg(cfg) {\r\n  var style = {\r\n    lineWidth: 0,\r\n    stroke: cfg.color,\r\n    fill: cfg.color\r\n  };\r\n\r\n  if (cfg.size) {\r\n    style.size = cfg.size;\r\n  }\r\n\r\n  Util.mix(style, cfg.style);\r\n  return Util.mix({}, Global.shape.point, style);\r\n}\r\n\r\nfunction drawShape(cfg, container, shape) {\r\n  if (cfg.size === 0) return;\r\n  var pointCfg = getPointsCfg(cfg);\r\n  var size = pointCfg.r || pointCfg.size;\r\n  var x = cfg.x;\r\n  var y = !Util.isArray(cfg.y) ? [cfg.y] : cfg.y;\r\n\r\n  if (shape === 'hollowCircle') {\r\n    pointCfg.lineWidth = 1;\r\n    pointCfg.fill = null;\r\n  }\r\n\r\n  for (var i = 0, len = y.length; i < len; i++) {\r\n    if (shape === 'rect') {\r\n      return container.addShape('Rect', {\r\n        className: 'point',\r\n        attrs: Util.mix({\r\n          x: x - size,\r\n          y: y[i] - size,\r\n          width: size * 2,\r\n          height: size * 2\r\n        }, pointCfg)\r\n      });\r\n    }\r\n\r\n    return container.addShape('Circle', {\r\n      className: 'point',\r\n      attrs: Util.mix({\r\n        x: x,\r\n        y: y[i],\r\n        r: size\r\n      }, pointCfg)\r\n    });\r\n  }\r\n}\r\n\r\nUtil.each(SHAPES, function (shapeType) {\r\n  Shape.registerShape('point', shapeType, {\r\n    draw: function draw(cfg, container) {\r\n      return drawShape(cfg, container, shapeType);\r\n    }\r\n  });\r\n});\r\nmodule.exports = Point;","\r\n\r\n/**\r\n * @fileOverview shape util\r\n * @author dxq613@gmail.com\r\n */\r\nvar Util = require('../../util/common');\r\n\r\nvar ShapeUtil = {\r\n  splitPoints: function splitPoints(obj) {\r\n    var points = [];\r\n    var x = obj.x;\r\n    var y = obj.y;\r\n    y = Util.isArray(y) ? y : [y];\r\n    y.forEach(function (yItem, index) {\r\n      var point = {\r\n        x: Util.isArray(x) ? x[index] : x,\r\n        y: yItem\r\n      };\r\n      points.push(point);\r\n    });\r\n    return points;\r\n  },\r\n  splitArray: function splitArray(data, yField, connectNulls) {\r\n    if (!data.length) return [];\r\n    var arr = [];\r\n    var tmp = [];\r\n    var yValue;\r\n    Util.each(data, function (obj) {\r\n      yValue = obj._origin ? obj._origin[yField] : obj[yField];\r\n\r\n      if (connectNulls) {\r\n        if (!Util.isNil(yValue)) {\r\n          tmp.push(obj);\r\n        }\r\n      } else {\r\n        if (Util.isArray(yValue) && Util.isNil(yValue[0]) || Util.isNil(yValue)) {\r\n          if (tmp.length) {\r\n            arr.push(tmp);\r\n            tmp = [];\r\n          }\r\n        } else {\r\n          tmp.push(obj);\r\n        }\r\n      }\r\n    });\r\n\r\n    if (tmp.length) {\r\n      arr.push(tmp);\r\n    }\r\n\r\n    return arr;\r\n  }\r\n};\r\nmodule.exports = ShapeUtil;","\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\r\n\r\nvar Geom = require('./base');\r\n\r\nvar ShapeUtil = require('./shape/util');\r\n\r\nvar Util = require('../util/common');\r\n\r\nrequire('./shape/line');\r\n\r\nvar Path =\r\n/*#__PURE__*/\r\nfunction (_Geom) {\r\n  (0, _inheritsLoose2[\"default\"])(Path, _Geom);\r\n\r\n  function Path() {\r\n    return _Geom.apply(this, arguments) || this;\r\n  }\r\n\r\n  var _proto = Path.prototype;\r\n\r\n  _proto.getDefaultCfg = function getDefaultCfg() {\r\n    var cfg = _Geom.prototype.getDefaultCfg.call(this);\r\n\r\n    cfg.type = 'path';\r\n    cfg.shapeType = 'line';\r\n    return cfg;\r\n  };\r\n\r\n  _proto.getDrawCfg = function getDrawCfg(obj) {\r\n    var cfg = _Geom.prototype.getDrawCfg.call(this, obj);\r\n\r\n    cfg.isStack = this.hasAdjust('stack');\r\n    return cfg;\r\n  };\r\n\r\n  _proto.draw = function draw(data, shapeFactory) {\r\n    var self = this;\r\n    var container = self.get('container');\r\n    var yScale = self.getYScale();\r\n    var connectNulls = self.get('connectNulls');\r\n    var splitArray = ShapeUtil.splitArray(data, yScale.field, connectNulls);\r\n    var cfg = this.getDrawCfg(data[0]);\r\n    cfg.origin = data;\r\n    Util.each(splitArray, function (subData, splitedIndex) {\r\n      cfg.splitedIndex = splitedIndex;\r\n      cfg.points = subData;\r\n      self.drawShape(cfg.shape, data[0], cfg, container, shapeFactory);\r\n    });\r\n  };\r\n\r\n  return Path;\r\n}(Geom);\r\n\r\nGeom.Path = Path;\r\nmodule.exports = Path;","\r\n\r\nvar Util = require('../../util/common');\r\n\r\nvar Shape = require('./shape');\r\n\r\nvar ShapeUtil = require('./util');\r\n\r\nvar Global = require('../../global'); // register line geom\r\n\r\n\r\nvar Line = Shape.registerFactory('line', {\r\n  defaultShapeType: 'line'\r\n});\r\n\r\nfunction getStyle(cfg) {\r\n  var style = {\r\n    strokeStyle: cfg.color\r\n  };\r\n\r\n  if (cfg.size >= 0) {\r\n    style.lineWidth = cfg.size;\r\n  }\r\n\r\n  Util.mix(style, cfg.style);\r\n  return Util.mix({}, Global.shape.line, style);\r\n}\r\n\r\nfunction drawLines(cfg, container, style, smooth) {\r\n  var points = cfg.points;\r\n\r\n  if (points.length && Util.isArray(points[0].y)) {\r\n    var topPoints = [];\r\n    var bottomPoints = [];\r\n\r\n    for (var i = 0, len = points.length; i < len; i++) {\r\n      var point = points[i];\r\n      var tmp = ShapeUtil.splitPoints(point);\r\n      bottomPoints.push(tmp[0]);\r\n      topPoints.push(tmp[1]);\r\n    }\r\n\r\n    if (cfg.isInCircle) {\r\n      topPoints.push(topPoints[0]);\r\n      bottomPoints.push(bottomPoints[0]);\r\n    }\r\n\r\n    if (cfg.isStack) {\r\n      return container.addShape('Polyline', {\r\n        className: 'line',\r\n        attrs: Util.mix({\r\n          points: topPoints,\r\n          smooth: smooth\r\n        }, style)\r\n      });\r\n    }\r\n\r\n    var topShape = container.addShape('Polyline', {\r\n      className: 'line',\r\n      attrs: Util.mix({\r\n        points: topPoints,\r\n        smooth: smooth\r\n      }, style)\r\n    });\r\n    var bottomShape = container.addShape('Polyline', {\r\n      className: 'line',\r\n      attrs: Util.mix({\r\n        points: bottomPoints,\r\n        smooth: smooth\r\n      }, style)\r\n    });\r\n    return [topShape, bottomShape];\r\n  }\r\n\r\n  if (cfg.isInCircle) {\r\n    points.push(points[0]);\r\n  }\r\n\r\n  return container.addShape('Polyline', {\r\n    className: 'line',\r\n    attrs: Util.mix({\r\n      points: points,\r\n      smooth: smooth\r\n    }, style)\r\n  });\r\n}\r\n\r\nvar SHAPES = ['line', 'smooth', 'dash'];\r\nUtil.each(SHAPES, function (shapeType) {\r\n  Shape.registerShape('line', shapeType, {\r\n    draw: function draw(cfg, container) {\r\n      var smooth = shapeType === 'smooth';\r\n      var style = getStyle(cfg);\r\n\r\n      if (shapeType === 'dash') {\r\n        style.lineDash = Global.lineDash;\r\n      }\r\n\r\n      return drawLines(cfg, container, style, smooth);\r\n    }\r\n  });\r\n});\r\nmodule.exports = Line;","\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\r\n\r\nvar Path = require('./path');\r\n\r\nvar Geom = require('./base');\r\n\r\nrequire('./shape/line');\r\n\r\nvar Line =\r\n/*#__PURE__*/\r\nfunction (_Path) {\r\n  (0, _inheritsLoose2[\"default\"])(Line, _Path);\r\n\r\n  function Line() {\r\n    return _Path.apply(this, arguments) || this;\r\n  }\r\n\r\n  var _proto = Line.prototype;\r\n\r\n  _proto.getDefaultCfg = function getDefaultCfg() {\r\n    var cfg = _Path.prototype.getDefaultCfg.call(this);\r\n\r\n    cfg.type = 'line';\r\n    cfg.sortable = true;\r\n    return cfg;\r\n  };\r\n\r\n  return Line;\r\n}(Path);\r\n\r\nGeom.Line = Line;\r\nmodule.exports = Line;","\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\r\n\r\n/**\r\n * @fileOverview area geometry\r\n * @author dxq613 @gmail.com\r\n * @author sima.zhang1990@gmail.com\r\n */\r\nvar Geom = require('./base');\r\n\r\nvar ShapeUtil = require('./shape/util');\r\n\r\nvar Util = require('../util/common');\r\n\r\nrequire('./shape/area');\r\n\r\nvar Area =\r\n/*#__PURE__*/\r\nfunction (_Geom) {\r\n  (0, _inheritsLoose2[\"default\"])(Area, _Geom);\r\n\r\n  function Area() {\r\n    return _Geom.apply(this, arguments) || this;\r\n  }\r\n\r\n  var _proto = Area.prototype;\r\n\r\n  /**\r\n   * get the default configuration\r\n   * @protected\r\n   * @return {Object} return the result\r\n   */\r\n  _proto.getDefaultCfg = function getDefaultCfg() {\r\n    var cfg = _Geom.prototype.getDefaultCfg.call(this);\r\n\r\n    cfg.type = 'area';\r\n    cfg.shapeType = 'area';\r\n    cfg.generatePoints = true;\r\n    cfg.sortable = true;\r\n    return cfg;\r\n  };\r\n\r\n  _proto.draw = function draw(data, shapeFactory) {\r\n    var self = this;\r\n    var container = self.get('container');\r\n    var cfg = this.getDrawCfg(data[0]);\r\n    var yScale = self.getYScale();\r\n    var connectNulls = self.get('connectNulls');\r\n    var splitArray = ShapeUtil.splitArray(data, yScale.field, connectNulls);\r\n    cfg.origin = data;\r\n    Util.each(splitArray, function (subData, splitedIndex) {\r\n      cfg.splitedIndex = splitedIndex;\r\n      var points = subData.map(function (obj) {\r\n        return obj.points;\r\n      });\r\n      cfg.points = points;\r\n      self.drawShape(cfg.shape, data[0], cfg, container, shapeFactory);\r\n    });\r\n  };\r\n\r\n  return Area;\r\n}(Geom);\r\n\r\nGeom.Area = Area;\r\nmodule.exports = Area;","\r\n\r\nvar Util = require('../../util/common');\r\n\r\nvar Shape = require('./shape');\r\n\r\nvar Smooth = require('../../graphic/util/smooth');\r\n\r\nvar bbox = require('../../graphic/util/bbox');\r\n\r\nvar Global = require('../../global');\r\n\r\nfunction equals(v1, v2) {\r\n  return Math.abs(v1 - v2) < 0.00001;\r\n}\r\n\r\nfunction notEmpty(value) {\r\n  return !isNaN(value) && !Util.isNil(value);\r\n}\r\n\r\nfunction filterPoints(points) {\r\n  var filteredPoints = []; // filter the point which x or y is NaN\r\n\r\n  for (var i = 0, len = points.length; i < len; i++) {\r\n    var point = points[i];\r\n\r\n    if (notEmpty(point.x) && notEmpty(point.y)) {\r\n      filteredPoints.push(point);\r\n    }\r\n  }\r\n\r\n  return filteredPoints;\r\n}\r\n\r\nfunction equalsCenter(points, center) {\r\n  var eqls = true;\r\n  Util.each(points, function (point) {\r\n    if (!equals(point.x, center.x) || !equals(point.y, center.y)) {\r\n      eqls = false;\r\n      return false;\r\n    }\r\n  });\r\n  return eqls;\r\n}\r\n\r\nfunction drawRectShape(topPoints, bottomPoints, container, style, isSmooth) {\r\n  var shape;\r\n  var points = topPoints.concat(bottomPoints);\r\n\r\n  if (isSmooth) {\r\n    shape = container.addShape('Custom', {\r\n      className: 'area',\r\n      attrs: Util.mix({\r\n        points: points\r\n      }, style),\r\n      createPath: function createPath(context) {\r\n        var constaint = [[0, 0], [1, 1]];\r\n        var points = filterPoints(this._attrs.attrs.points);\r\n        var pointsLen = points.length;\r\n        var topPoints = points.slice(0, pointsLen / 2);\r\n        var bottomPoints = points.slice(pointsLen / 2, pointsLen);\r\n        var topSps = Smooth.smooth(topPoints, false, constaint);\r\n        context.beginPath();\r\n        context.moveTo(topPoints[0].x, topPoints[0].y);\r\n\r\n        for (var i = 0, n = topSps.length; i < n; i++) {\r\n          var sp = topSps[i];\r\n          context.bezierCurveTo(sp[1], sp[2], sp[3], sp[4], sp[5], sp[6]);\r\n        }\r\n\r\n        if (bottomPoints.length) {\r\n          var bottomSps = Smooth.smooth(bottomPoints, false, constaint);\r\n          context.lineTo(bottomPoints[0].x, bottomPoints[0].y);\r\n\r\n          for (var _i = 0, _n = bottomSps.length; _i < _n; _i++) {\r\n            var _sp = bottomSps[_i];\r\n            context.bezierCurveTo(_sp[1], _sp[2], _sp[3], _sp[4], _sp[5], _sp[6]);\r\n          }\r\n        }\r\n\r\n        context.closePath();\r\n      },\r\n      calculateBox: function calculateBox() {\r\n        var points = filterPoints(this._attrs.attrs.points);\r\n        return bbox.getBBoxFromPoints(points);\r\n      }\r\n    });\r\n  } else {\r\n    shape = container.addShape('Polyline', {\r\n      className: 'area',\r\n      attrs: Util.mix({\r\n        points: points\r\n      }, style)\r\n    });\r\n  }\r\n\r\n  return shape;\r\n}\r\n\r\nfunction drawShape(cfg, container, isSmooth) {\r\n  var self = this;\r\n  var points = cfg.points;\r\n  var topPoints = [];\r\n  var bottomPoints = [];\r\n  Util.each(points, function (point) {\r\n    bottomPoints.push(point[0]);\r\n    topPoints.push(point[1]);\r\n  });\r\n  var style = Util.mix({\r\n    fillStyle: cfg.color\r\n  }, Global.shape.area, cfg.style);\r\n  bottomPoints.reverse();\r\n  topPoints = self.parsePoints(topPoints);\r\n  bottomPoints = self.parsePoints(bottomPoints);\r\n\r\n  if (cfg.isInCircle) {\r\n    topPoints.push(topPoints[0]);\r\n    bottomPoints.unshift(bottomPoints[bottomPoints.length - 1]);\r\n\r\n    if (equalsCenter(bottomPoints, cfg.center)) {\r\n      bottomPoints = [];\r\n    }\r\n  }\r\n\r\n  return drawRectShape(topPoints, bottomPoints, container, style, isSmooth);\r\n}\r\n\r\nvar Area = Shape.registerFactory('area', {\r\n  defaultShapeType: 'area',\r\n  getDefaultPoints: function getDefaultPoints(obj) {\r\n    var x = obj.x;\r\n    var y = obj.y;\r\n    var y0 = obj.y0;\r\n    y = Util.isArray(y) ? y : [y0, y];\r\n    var points = [];\r\n    points.push({\r\n      x: x,\r\n      y: y[0]\r\n    }, {\r\n      x: x,\r\n      y: y[1]\r\n    });\r\n    return points;\r\n  }\r\n});\r\nvar SHAPES = ['area', 'smooth'];\r\nUtil.each(SHAPES, function (shapeType) {\r\n  Shape.registerShape('area', shapeType, {\r\n    draw: function draw(cfg, container) {\r\n      var smooth = shapeType === 'smooth';\r\n      return drawShape.call(this, cfg, container, smooth);\r\n    }\r\n  });\r\n});\r\nmodule.exports = Area;","\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\r\n\r\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\r\n\r\nvar Geom = require('./base');\r\n\r\nvar Util = require('../util/common');\r\n\r\nvar SizeMixin = require('./mixin/size');\r\n\r\nrequire('./shape/interval');\r\n\r\nvar Interval =\r\n/*#__PURE__*/\r\nfunction (_Geom) {\r\n  (0, _inheritsLoose2[\"default\"])(Interval, _Geom);\r\n  var _proto = Interval.prototype;\r\n\r\n  _proto.getDefaultCfg = function getDefaultCfg() {\r\n    var cfg = _Geom.prototype.getDefaultCfg.call(this);\r\n\r\n    cfg.type = 'interval';\r\n    cfg.shapeType = 'interval';\r\n    cfg.generatePoints = true;\r\n    return cfg;\r\n  };\r\n\r\n  function Interval(cfg) {\r\n    var _this;\r\n\r\n    _this = _Geom.call(this, cfg) || this;\r\n    Util.mix((0, _assertThisInitialized2[\"default\"])(_this), SizeMixin);\r\n    return _this;\r\n  }\r\n\r\n  _proto.createShapePointsCfg = function createShapePointsCfg(obj) {\r\n    var cfg = _Geom.prototype.createShapePointsCfg.call(this, obj);\r\n\r\n    cfg.size = this.getNormalizedSize(obj);\r\n    return cfg;\r\n  };\r\n\r\n  _proto.clearInner = function clearInner() {\r\n    _Geom.prototype.clearInner.call(this);\r\n\r\n    this.set('defaultSize', null);\r\n  };\r\n\r\n  return Interval;\r\n}(Geom);\r\n\r\nGeom.Interval = Interval;\r\nmodule.exports = Interval;","\r\n\r\n/**\r\n * @fileOverview Utility for calculate the with ratui in x axis\r\n * @author sima.zhang1990@gmail.com\r\n * @author dxq613@gmail.com\r\n */\r\nvar Global = require('../../global');\r\n\r\nvar Util = require('../../util/common');\r\n\r\nvar SizeMixin = {\r\n  getDefalutSize: function getDefalutSize() {\r\n    var defaultSize = this.get('defaultSize');\r\n\r\n    if (!defaultSize) {\r\n      var coord = this.get('coord');\r\n      var xScale = this.getXScale();\r\n      var dataArray = this.get('dataArray');\r\n      var values = Util.uniq(xScale.values);\r\n      var count = values.length;\r\n      var range = xScale.range;\r\n      var normalizeSize = 1 / count;\r\n      var widthRatio = 1;\r\n\r\n      if (coord && coord.isPolar) {\r\n        if (coord.transposed && count > 1) {\r\n          widthRatio = Global.widthRatio.multiplePie;\r\n        } else {\r\n          widthRatio = Global.widthRatio.rose;\r\n        }\r\n      } else {\r\n        if (xScale.isLinear) {\r\n          normalizeSize *= range[1] - range[0];\r\n        }\r\n\r\n        widthRatio = Global.widthRatio.column;\r\n      }\r\n\r\n      normalizeSize *= widthRatio;\r\n\r\n      if (this.hasAdjust('dodge')) {\r\n        normalizeSize = normalizeSize / dataArray.length;\r\n      }\r\n\r\n      defaultSize = normalizeSize;\r\n      this.set('defaultSize', defaultSize);\r\n    }\r\n\r\n    return defaultSize;\r\n  },\r\n  getDimWidth: function getDimWidth(dimName) {\r\n    var coord = this.get('coord');\r\n    var start = coord.convertPoint({\r\n      x: 0,\r\n      y: 0\r\n    });\r\n    var end = coord.convertPoint({\r\n      x: dimName === 'x' ? 1 : 0,\r\n      y: dimName === 'x' ? 0 : 1\r\n    });\r\n    var width = 0;\r\n\r\n    if (start && end) {\r\n      width = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));\r\n    }\r\n\r\n    return width;\r\n  },\r\n  _getWidth: function _getWidth() {\r\n    var width = this.get('_width');\r\n\r\n    if (!width) {\r\n      var coord = this.get('coord');\r\n\r\n      if (coord && coord.isPolar && !coord.transposed) {\r\n        width = (coord.endAngle - coord.startAngle) * coord.circleRadius;\r\n      } else {\r\n        width = this.getDimWidth('x');\r\n      }\r\n\r\n      this.set('_width', width);\r\n    }\r\n\r\n    return width;\r\n  },\r\n  _toNormalizedSize: function _toNormalizedSize(size) {\r\n    var width = this._getWidth();\r\n\r\n    return size / width;\r\n  },\r\n  _toCoordSize: function _toCoordSize(normalizeSize) {\r\n    var width = this._getWidth();\r\n\r\n    return width * normalizeSize;\r\n  },\r\n  getNormalizedSize: function getNormalizedSize(obj) {\r\n    var size = this.getAttrValue('size', obj);\r\n\r\n    if (Util.isNil(size)) {\r\n      size = this.getDefalutSize();\r\n    } else {\r\n      size = this._toNormalizedSize(size);\r\n    }\r\n\r\n    return size;\r\n  },\r\n  getSize: function getSize(obj) {\r\n    var size = this.getAttrValue('size', obj);\r\n\r\n    if (Util.isNil(size)) {\r\n      var normalizeSize = this.getDefalutSize();\r\n      size = this._toCoordSize(normalizeSize);\r\n    }\r\n\r\n    return size;\r\n  }\r\n};\r\nmodule.exports = SizeMixin;","\r\n\r\nvar Util = require('../../util/common');\r\n\r\nvar Shape = require('./shape');\r\n\r\nvar Vector2 = require('../../graphic/util/vector2');\r\n\r\nvar Global = require('../../global');\r\n\r\nfunction getRectPoints(cfg) {\r\n  var x = cfg.x,\r\n      y = cfg.y,\r\n      y0 = cfg.y0,\r\n      size = cfg.size;\r\n  var ymin = y0;\r\n  var ymax = y;\r\n\r\n  if (Util.isArray(y)) {\r\n    ymax = y[1];\r\n    ymin = y[0];\r\n  }\r\n\r\n  var xmin;\r\n  var xmax;\r\n\r\n  if (Util.isArray(x)) {\r\n    xmin = x[0];\r\n    xmax = x[1];\r\n  } else {\r\n    xmin = x - size / 2;\r\n    xmax = x + size / 2;\r\n  }\r\n\r\n  return [{\r\n    x: xmin,\r\n    y: ymin\r\n  }, {\r\n    x: xmin,\r\n    y: ymax\r\n  }, {\r\n    x: xmax,\r\n    y: ymax\r\n  }, {\r\n    x: xmax,\r\n    y: ymin\r\n  }];\r\n}\r\n\r\nfunction getRectRange(points) {\r\n  var xValues = [];\r\n  var yValues = [];\r\n\r\n  for (var i = 0, len = points.length; i < len; i++) {\r\n    var point = points[i];\r\n    xValues.push(point.x);\r\n    yValues.push(point.y);\r\n  }\r\n\r\n  var xMin = Math.min.apply(null, xValues);\r\n  var yMin = Math.min.apply(null, yValues);\r\n  var xMax = Math.max.apply(null, xValues);\r\n  var yMax = Math.max.apply(null, yValues);\r\n  return {\r\n    x: xMin,\r\n    y: yMin,\r\n    width: xMax - xMin,\r\n    height: yMax - yMin\r\n  };\r\n}\r\n\r\nfunction getMiddlePoint(a, b) {\r\n  var x = (a.x - b.x) / 2 + b.x;\r\n  var y = (a.y - b.y) / 2 + b.y;\r\n  return {\r\n    x: x,\r\n    y: y\r\n  };\r\n}\r\n\r\nvar Interval = Shape.registerFactory('interval', {\r\n  defaultShapeType: 'rect',\r\n  getDefaultPoints: function getDefaultPoints(cfg) {\r\n    return getRectPoints(cfg);\r\n  }\r\n});\r\nShape.registerShape('interval', 'rect', {\r\n  draw: function draw(cfg, container) {\r\n    var points = this.parsePoints(cfg.points);\r\n    var style = Util.mix({\r\n      fill: cfg.color\r\n    }, Global.shape.interval, cfg.style);\r\n\r\n    if (cfg.isInCircle) {\r\n      var newPoints = points.slice(0);\r\n\r\n      if (this._coord.transposed) {\r\n        newPoints = [points[0], points[3], points[2], points[1]];\r\n      }\r\n\r\n      var _cfg$center = cfg.center,\r\n          x = _cfg$center.x,\r\n          y = _cfg$center.y;\r\n      var v = [1, 0];\r\n      var v0 = [newPoints[0].x - x, newPoints[0].y - y];\r\n      var v1 = [newPoints[1].x - x, newPoints[1].y - y];\r\n      var v2 = [newPoints[2].x - x, newPoints[2].y - y];\r\n      var startAngle = Vector2.angleTo(v, v1);\r\n      var endAngle = Vector2.angleTo(v, v2);\r\n      var r0 = Vector2.length(v0);\r\n      var r = Vector2.length(v1);\r\n\r\n      if (startAngle >= 1.5 * Math.PI) {\r\n        startAngle = startAngle - 2 * Math.PI;\r\n      }\r\n\r\n      if (endAngle >= 1.5 * Math.PI) {\r\n        endAngle = endAngle - 2 * Math.PI;\r\n      }\r\n\r\n      return container.addShape('Sector', {\r\n        className: 'interval',\r\n        attrs: Util.mix({\r\n          x: x,\r\n          y: y,\r\n          r: r,\r\n          r0: r0,\r\n          startAngle: startAngle,\r\n          endAngle: endAngle\r\n        }, style)\r\n      });\r\n    }\r\n\r\n    var rectCfg = getRectRange(points);\r\n    return container.addShape('rect', {\r\n      className: 'interval',\r\n      attrs: Util.mix(rectCfg, style)\r\n    });\r\n  }\r\n}); // 金字塔 和 漏斗图\r\n\r\n['pyramid', 'funnel'].forEach(function (shapeType) {\r\n  Shape.registerShape('interval', shapeType, {\r\n    getPoints: function getPoints(cfg) {\r\n      cfg.size = cfg.size * 2; // 漏斗图的 size 是柱状图的两倍\r\n\r\n      return getRectPoints(cfg);\r\n    },\r\n    draw: function draw(cfg, container) {\r\n      var points = this.parsePoints(cfg.points);\r\n      var nextPoints = this.parsePoints(cfg.nextPoints);\r\n      var polygonPoints = null;\r\n\r\n      if (nextPoints) {\r\n        polygonPoints = [points[0], points[1], nextPoints[1], nextPoints[0]];\r\n      } else {\r\n        polygonPoints = [points[0], points[1]]; // pyramid 顶部是三角形，所以取中心点就好了，funnel顶部是长方形\r\n\r\n        if (shapeType === 'pyramid') {\r\n          polygonPoints.push(getMiddlePoint(points[2], points[3]));\r\n        } else {\r\n          polygonPoints.push(points[2], points[3]);\r\n        }\r\n      }\r\n\r\n      var attrs = Util.mix({\r\n        fill: cfg.color,\r\n        points: polygonPoints\r\n      }, Global.shape.interval, cfg.style);\r\n      return container.addShape('polygon', {\r\n        className: 'interval',\r\n        attrs: attrs\r\n      });\r\n    }\r\n  });\r\n});\r\nmodule.exports = Interval;","\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\r\n\r\nvar Geom = require('./base');\r\n\r\nvar Util = require('../util/common');\r\n\r\nrequire('./shape/polygon');\r\n\r\nvar Polygon =\r\n/*#__PURE__*/\r\nfunction (_Geom) {\r\n  (0, _inheritsLoose2[\"default\"])(Polygon, _Geom);\r\n\r\n  function Polygon() {\r\n    return _Geom.apply(this, arguments) || this;\r\n  }\r\n\r\n  var _proto = Polygon.prototype;\r\n\r\n  _proto.getDefaultCfg = function getDefaultCfg() {\r\n    var cfg = _Geom.prototype.getDefaultCfg.call(this);\r\n\r\n    cfg.type = 'polygon';\r\n    cfg.shapeType = 'polygon';\r\n    cfg.generatePoints = true;\r\n    return cfg;\r\n  };\r\n\r\n  _proto.createShapePointsCfg = function createShapePointsCfg(obj) {\r\n    var cfg = _Geom.prototype.createShapePointsCfg.call(this, obj);\r\n\r\n    var self = this;\r\n    var x = cfg.x;\r\n    var y = cfg.y;\r\n    var temp;\r\n\r\n    if (!(Util.isArray(x) && Util.isArray(y))) {\r\n      var xScale = self.getXScale();\r\n      var yScale = self.getYScale();\r\n      var xCount = xScale.values ? xScale.values.length : xScale.ticks.length;\r\n      var yCount = yScale.values ? yScale.values.length : yScale.ticks.length;\r\n      var xOffset = 0.5 * 1 / xCount;\r\n      var yOffset = 0.5 * 1 / yCount;\r\n\r\n      if (xScale.isCategory && yScale.isCategory) {\r\n        x = [x - xOffset, x - xOffset, x + xOffset, x + xOffset];\r\n        y = [y - yOffset, y + yOffset, y + yOffset, y - yOffset];\r\n      } else if (Util.isArray(x)) {\r\n        temp = x;\r\n        x = [temp[0], temp[0], temp[1], temp[1]];\r\n        y = [y - yOffset / 2, y + yOffset / 2, y + yOffset / 2, y - yOffset / 2];\r\n      } else if (Util.isArray(y)) {\r\n        temp = y;\r\n        y = [temp[0], temp[1], temp[1], temp[0]];\r\n        x = [x - xOffset / 2, x - xOffset / 2, x + xOffset / 2, x + xOffset / 2];\r\n      }\r\n\r\n      cfg.x = x;\r\n      cfg.y = y;\r\n    }\r\n\r\n    return cfg;\r\n  };\r\n\r\n  return Polygon;\r\n}(Geom);\r\n\r\nGeom.Polygon = Polygon;\r\nmodule.exports = Polygon;","\r\n\r\nvar Shape = require('./shape');\r\n\r\nvar Util = require('../../util/common');\r\n\r\nvar Polygon = Shape.registerFactory('polygon', {\r\n  defaultShapeType: 'polygon',\r\n  getDefaultPoints: function getDefaultPoints(pointInfo) {\r\n    var points = [];\r\n    var x = pointInfo.x,\r\n        y = pointInfo.y;\r\n\r\n    for (var i = 0, len = x.length; i < len; i++) {\r\n      points.push({\r\n        x: x[i],\r\n        y: y[i]\r\n      });\r\n    }\r\n\r\n    return points;\r\n  }\r\n});\r\nShape.registerShape('polygon', 'polygon', {\r\n  draw: function draw(cfg, container) {\r\n    var points = this.parsePoints(cfg.points);\r\n    var style = Util.mix({\r\n      fill: cfg.color,\r\n      points: points\r\n    }, cfg.style);\r\n    return container.addShape('Polygon', {\r\n      className: 'polygon',\r\n      attrs: style\r\n    });\r\n  }\r\n});\r\nmodule.exports = Polygon;","\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\r\n\r\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\r\n\r\nvar Geom = require('./base');\r\n\r\nvar Util = require('../util/common');\r\n\r\nvar SizeMixin = require('./mixin/size');\r\n\r\nrequire('./shape/schema');\r\n\r\nvar Schema =\r\n/*#__PURE__*/\r\nfunction (_Geom) {\r\n  (0, _inheritsLoose2[\"default\"])(Schema, _Geom);\r\n  var _proto = Schema.prototype;\r\n\r\n  _proto.getDefaultCfg = function getDefaultCfg() {\r\n    var cfg = _Geom.prototype.getDefaultCfg.call(this);\r\n\r\n    cfg.type = 'schema';\r\n    cfg.shapeType = 'schema';\r\n    cfg.generatePoints = true;\r\n    return cfg;\r\n  };\r\n\r\n  function Schema(cfg) {\r\n    var _this;\r\n\r\n    _this = _Geom.call(this, cfg) || this;\r\n    Util.mix((0, _assertThisInitialized2[\"default\"])(_this), SizeMixin);\r\n    return _this;\r\n  }\r\n\r\n  _proto.createShapePointsCfg = function createShapePointsCfg(obj) {\r\n    var cfg = _Geom.prototype.createShapePointsCfg.call(this, obj);\r\n\r\n    cfg.size = this.getNormalizedSize(obj);\r\n    return cfg;\r\n  };\r\n\r\n  _proto.clearInner = function clearInner() {\r\n    _Geom.prototype.clearInner.call(this);\r\n\r\n    this.set('defaultSize', null);\r\n  };\r\n\r\n  return Schema;\r\n}(Geom);\r\n\r\nGeom.Schema = Schema;\r\nmodule.exports = Schema;","\r\n\r\nvar Shape = require('./shape');\r\n\r\nvar Util = require('../../util/common');\r\n\r\nfunction _sortValue(value) {\r\n  var sorted = value.sort(function (a, b) {\r\n    return a < b ? 1 : -1;\r\n  });\r\n  var length = sorted.length;\r\n\r\n  if (length < 4) {\r\n    var min = sorted[length - 1];\r\n\r\n    for (var i = 0; i < 4 - length; i++) {\r\n      sorted.push(min);\r\n    }\r\n  }\r\n\r\n  return sorted;\r\n} // from left bottom corner, and clockwise\r\n\r\n\r\nfunction getCandlePoints(x, y, width) {\r\n  var yValues = _sortValue(y);\r\n\r\n  var points = [{\r\n    x: x,\r\n    y: yValues[0]\r\n  }, {\r\n    x: x,\r\n    y: yValues[1]\r\n  }, {\r\n    x: x - width / 2,\r\n    y: yValues[2]\r\n  }, {\r\n    x: x - width / 2,\r\n    y: yValues[1]\r\n  }, {\r\n    x: x + width / 2,\r\n    y: yValues[1]\r\n  }, {\r\n    x: x + width / 2,\r\n    y: yValues[2]\r\n  }, {\r\n    x: x,\r\n    y: yValues[2]\r\n  }, {\r\n    x: x,\r\n    y: yValues[3]\r\n  }];\r\n  return points;\r\n}\r\n\r\nvar Schema = Shape.registerFactory('schema', {});\r\nShape.registerShape('schema', 'candle', {\r\n  getPoints: function getPoints(cfg) {\r\n    return getCandlePoints(cfg.x, cfg.y, cfg.size);\r\n  },\r\n  draw: function draw(cfg, container) {\r\n    var points = this.parsePoints(cfg.points);\r\n    var style = Util.mix({\r\n      stroke: cfg.color,\r\n      fill: cfg.color,\r\n      lineWidth: 1\r\n    }, cfg.style);\r\n    return container.addShape('Custom', {\r\n      className: 'schema',\r\n      attrs: style,\r\n      createPath: function createPath(ctx) {\r\n        ctx.beginPath();\r\n        ctx.moveTo(points[0].x, points[0].y);\r\n        ctx.lineTo(points[1].x, points[1].y);\r\n        ctx.moveTo(points[2].x, points[2].y);\r\n\r\n        for (var i = 3; i < 6; i++) {\r\n          ctx.lineTo(points[i].x, points[i].y);\r\n        }\r\n\r\n        ctx.closePath();\r\n        ctx.moveTo(points[6].x, points[6].y);\r\n        ctx.lineTo(points[7].x, points[7].y);\r\n      }\r\n    });\r\n  }\r\n});\r\nmodule.exports = Schema;","\r\n\r\nmodule.exports = {\r\n  Stack: require('./stack'),\r\n  Dodge: require('./dodge'),\r\n  Symmetric: require('./symmetric')\r\n};","\r\n\r\nvar Stack = require('@antv/adjust/lib/stack');\r\n\r\nmodule.exports = Stack;","\r\n\r\nvar Dodge = require('@antv/adjust/lib/dodge');\r\n\r\nmodule.exports = Dodge;","\r\n\r\nvar Symmetric = require('@antv/adjust/lib/symmetric');\r\n\r\nmodule.exports = Symmetric;","\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\r\n\r\nvar Base = require('./base');\r\n\r\nvar Vector2 = require('../graphic/util/vector2');\r\n\r\nvar Matrix = require('../graphic/util/matrix');\r\n\r\nvar Polar =\r\n/*#__PURE__*/\r\nfunction (_Base) {\r\n  (0, _inheritsLoose2[\"default\"])(Polar, _Base);\r\n\r\n  function Polar() {\r\n    return _Base.apply(this, arguments) || this;\r\n  }\r\n\r\n  var _proto = Polar.prototype;\r\n\r\n  _proto._initDefaultCfg = function _initDefaultCfg() {\r\n    this.type = 'polar';\r\n    this.startAngle = -Math.PI / 2;\r\n    this.endAngle = Math.PI * 3 / 2;\r\n    this.inner = 0;\r\n    this.innerRadius = 0; // alias\r\n\r\n    this.isPolar = true;\r\n    this.transposed = false;\r\n    this.center = null;\r\n    this.radius = null; // relative, 0 ~ 1\r\n  };\r\n\r\n  _proto.init = function init(start, end) {\r\n    _Base.prototype.init.call(this, start, end);\r\n\r\n    var self = this;\r\n    var inner = self.inner || self.innerRadius;\r\n    var width = Math.abs(end.x - start.x);\r\n    var height = Math.abs(end.y - start.y);\r\n    var maxRadius;\r\n    var center;\r\n\r\n    if (self.startAngle === -Math.PI && self.endAngle === 0) {\r\n      maxRadius = Math.min(width / 2, height);\r\n      center = {\r\n        x: (start.x + end.x) / 2,\r\n        y: start.y\r\n      };\r\n    } else {\r\n      maxRadius = Math.min(width, height) / 2;\r\n      center = {\r\n        x: (start.x + end.x) / 2,\r\n        y: (start.y + end.y) / 2\r\n      };\r\n    }\r\n\r\n    var radius = self.radius;\r\n\r\n    if (radius > 0 && radius <= 1) {\r\n      maxRadius = maxRadius * radius;\r\n    }\r\n\r\n    this.x = {\r\n      start: self.startAngle,\r\n      end: self.endAngle\r\n    };\r\n    this.y = {\r\n      start: maxRadius * inner,\r\n      end: maxRadius\r\n    };\r\n    this.center = center;\r\n    this.circleRadius = maxRadius; // the radius value in px\r\n  };\r\n\r\n  _proto._convertPoint = function _convertPoint(point) {\r\n    var self = this;\r\n    var center = self.center;\r\n    var transposed = self.transposed;\r\n    var xDim = transposed ? 'y' : 'x';\r\n    var yDim = transposed ? 'x' : 'y';\r\n    var x = self.x;\r\n    var y = self.y;\r\n    var angle = x.start + (x.end - x.start) * point[xDim];\r\n    var radius = y.start + (y.end - y.start) * point[yDim];\r\n    return {\r\n      x: center.x + Math.cos(angle) * radius,\r\n      y: center.y + Math.sin(angle) * radius\r\n    };\r\n  };\r\n\r\n  _proto._invertPoint = function _invertPoint(point) {\r\n    var self = this;\r\n    var center = self.center,\r\n        transposed = self.transposed,\r\n        x = self.x,\r\n        y = self.y;\r\n    var xDim = transposed ? 'y' : 'x';\r\n    var yDim = transposed ? 'x' : 'y';\r\n    var m = [1, 0, 0, 1, 0, 0];\r\n    Matrix.rotate(m, m, x.start);\r\n    var startV = [1, 0];\r\n    Vector2.transformMat2d(startV, startV, m);\r\n    startV = [startV[0], startV[1]];\r\n    var pointV = [point.x - center.x, point.y - center.y];\r\n\r\n    if (Vector2.zero(pointV)) {\r\n      return {\r\n        x: 0,\r\n        y: 0\r\n      };\r\n    }\r\n\r\n    var theta = Vector2.angleTo(startV, pointV, x.end < x.start);\r\n\r\n    if (Math.abs(theta - Math.PI * 2) < 0.001) {\r\n      theta = 0;\r\n    }\r\n\r\n    var l = Vector2.length(pointV);\r\n    var percentX = theta / (x.end - x.start);\r\n    percentX = x.end - x.start > 0 ? percentX : -percentX;\r\n    var percentY = (l - y.start) / (y.end - y.start);\r\n    var rst = {};\r\n    rst[xDim] = percentX;\r\n    rst[yDim] = percentY;\r\n    return rst;\r\n  };\r\n\r\n  return Polar;\r\n}(Base);\r\n\r\nBase.Polar = Polar;\r\nmodule.exports = Polar;","\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\r\n\r\nvar Util = require('../../util/common');\r\n\r\nvar Abstract = require('./abstract');\r\n\r\nvar Circle =\r\n/*#__PURE__*/\r\nfunction (_Abstract) {\r\n  (0, _inheritsLoose2[\"default\"])(Circle, _Abstract);\r\n\r\n  function Circle() {\r\n    return _Abstract.apply(this, arguments) || this;\r\n  }\r\n\r\n  var _proto = Circle.prototype;\r\n\r\n  _proto._initDefaultCfg = function _initDefaultCfg() {\r\n    _Abstract.prototype._initDefaultCfg.call(this);\r\n\r\n    this.startAngle = -Math.PI / 2; // start angle，in radian\r\n\r\n    this.endAngle = Math.PI * 3 / 2; // end angle, in radian\r\n\r\n    this.radius = null; // radius\r\n\r\n    this.center = null; // center\r\n  };\r\n\r\n  _proto.getOffsetPoint = function getOffsetPoint(value) {\r\n    var startAngle = this.startAngle,\r\n        endAngle = this.endAngle;\r\n    var angle = startAngle + (endAngle - startAngle) * value;\r\n    return this._getCirclePoint(angle);\r\n  };\r\n\r\n  _proto._getCirclePoint = function _getCirclePoint(angle, radius) {\r\n    var self = this;\r\n    var center = self.center;\r\n    radius = radius || self.radius;\r\n    return {\r\n      x: center.x + Math.cos(angle) * radius,\r\n      y: center.y + Math.sin(angle) * radius\r\n    };\r\n  };\r\n\r\n  _proto.getTextAlignInfo = function getTextAlignInfo(point, offset) {\r\n    var self = this;\r\n    var offsetVector = self.getOffsetVector(point, offset);\r\n    var align;\r\n    var baseLine = 'middle';\r\n\r\n    if (offsetVector[0] > 0) {\r\n      align = 'left';\r\n    } else if (offsetVector[0] < 0) {\r\n      align = 'right';\r\n    } else {\r\n      align = 'center';\r\n\r\n      if (offsetVector[1] > 0) {\r\n        baseLine = 'top';\r\n      } else if (offsetVector[1] < 0) {\r\n        baseLine = 'bottom';\r\n      }\r\n    }\r\n\r\n    return {\r\n      textAlign: align,\r\n      textBaseline: baseLine\r\n    };\r\n  };\r\n\r\n  _proto.getAxisVector = function getAxisVector(point) {\r\n    var center = this.center;\r\n    var factor = this.offsetFactor;\r\n    return [(point.y - center.y) * factor, (point.x - center.x) * -1 * factor];\r\n  };\r\n\r\n  _proto.drawLine = function drawLine(lineCfg) {\r\n    var center = this.center,\r\n        radius = this.radius,\r\n        startAngle = this.startAngle,\r\n        endAngle = this.endAngle;\r\n    var container = this.getContainer(lineCfg.top);\r\n    container.addShape('arc', {\r\n      className: 'axis-line',\r\n      attrs: Util.mix({\r\n        x: center.x,\r\n        y: center.y,\r\n        r: radius,\r\n        startAngle: startAngle,\r\n        endAngle: endAngle\r\n      }, lineCfg)\r\n    });\r\n  };\r\n\r\n  return Circle;\r\n}(Abstract);\r\n\r\nAbstract.Circle = Circle;\r\nmodule.exports = Circle;","\r\n\r\nvar TimeCat = require('@antv/scale/lib/time-cat');\r\n\r\nmodule.exports = TimeCat;","\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\r\n\r\nvar Util = require('../../util/common');\r\n\r\nvar GuideBase = require('./base');\r\n\r\nvar Arc =\r\n/*#__PURE__*/\r\nfunction (_GuideBase) {\r\n  (0, _inheritsLoose2[\"default\"])(Arc, _GuideBase);\r\n\r\n  function Arc() {\r\n    return _GuideBase.apply(this, arguments) || this;\r\n  }\r\n\r\n  var _proto = Arc.prototype;\r\n\r\n  _proto._initDefaultCfg = function _initDefaultCfg() {\r\n    this.type = 'arc';\r\n    /**\r\n     * start point\r\n     * @type {Array | Function}\r\n     */\r\n\r\n    this.start = [];\r\n    /**\r\n     * end point\r\n     * @type {Array | Function}\r\n     */\r\n\r\n    this.end = [];\r\n    /**\r\n     * style configuration\r\n     * @type {Object}\r\n     */\r\n\r\n    this.style = {\r\n      stroke: '#999',\r\n      lineWidth: 1\r\n    };\r\n  };\r\n\r\n  _proto.render = function render(coord, container) {\r\n    var self = this;\r\n    var start = self.parsePoint(coord, self.start);\r\n    var end = self.parsePoint(coord, self.end);\r\n\r\n    if (!start || !end) {\r\n      return;\r\n    }\r\n\r\n    var coordCenter = coord.center;\r\n    var radius = Math.sqrt((start.x - coordCenter.x) * (start.x - coordCenter.x) + (start.y - coordCenter.y) * (start.y - coordCenter.y));\r\n    var startAngle = Math.atan2(start.y - coordCenter.y, start.x - coordCenter.x);\r\n    var endAngle = Math.atan2(end.y - coordCenter.y, end.x - coordCenter.x);\r\n    var shape = container.addShape('arc', {\r\n      className: 'guide-arc',\r\n      attrs: Util.mix({\r\n        x: coordCenter.x,\r\n        y: coordCenter.y,\r\n        r: radius,\r\n        startAngle: startAngle,\r\n        endAngle: endAngle\r\n      }, self.style)\r\n    });\r\n    self.element = shape;\r\n    return shape;\r\n  };\r\n\r\n  return Arc;\r\n}(GuideBase);\r\n\r\nGuideBase.Arc = Arc;\r\nmodule.exports = Arc;","\r\n\r\nvar Util = require('../../util/common');\r\n\r\nvar KEYWORDS_PERCENT = {\r\n  min: 0,\r\n  median: 0.5,\r\n  max: 1\r\n};\r\n\r\nvar GuideBase =\r\n/*#__PURE__*/\r\nfunction () {\r\n  var _proto = GuideBase.prototype;\r\n\r\n  _proto._initDefaultCfg = function _initDefaultCfg() {};\r\n\r\n  function GuideBase(cfg) {\r\n    this._initDefaultCfg();\r\n\r\n    Util.deepMix(this, cfg);\r\n  }\r\n\r\n  _proto._getNormalizedValue = function _getNormalizedValue(val, scale) {\r\n    var rst;\r\n\r\n    if (Util.isNil(KEYWORDS_PERCENT[val])) {\r\n      rst = scale.scale(val);\r\n    } else {\r\n      rst = KEYWORDS_PERCENT[val];\r\n    }\r\n\r\n    return rst;\r\n  };\r\n\r\n  _proto.parsePercentPoint = function parsePercentPoint(coord, position) {\r\n    var xPercent = parseFloat(position[0]) / 100;\r\n    var yPercent = parseFloat(position[1]) / 100;\r\n    var start = coord.start;\r\n    var end = coord.end;\r\n    var width = Math.abs(start.x - end.x);\r\n    var height = Math.abs(start.y - end.y);\r\n    var x = width * xPercent + Math.min(start.x, end.x);\r\n    var y = height * yPercent + Math.min(start.y, end.y);\r\n    return {\r\n      x: x,\r\n      y: y\r\n    };\r\n  };\r\n\r\n  _proto.parsePoint = function parsePoint(coord, position) {\r\n    var self = this;\r\n    var xScale = self.xScale;\r\n    var yScales = self.yScales;\r\n\r\n    if (Util.isFunction(position)) {\r\n      position = position(xScale, yScales); // position 必须是对象\r\n    } // 如果数据格式是 ['50%', '50%'] 的格式\r\n    // fix: 原始数据中可能会包含 'xxx5%xxx' 这样的数据，需要判断下 https://github.com/antvis/f2/issues/590\r\n\r\n\r\n    if (Util.isString(position[0]) && position[0].indexOf('%') !== -1 && !isNaN(position[0].slice(0, -1))) {\r\n      return this.parsePercentPoint(coord, position);\r\n    }\r\n\r\n    var x = self._getNormalizedValue(position[0], xScale);\r\n\r\n    var y = self._getNormalizedValue(position[1], yScales[0]);\r\n\r\n    var point = coord.convertPoint({\r\n      x: x,\r\n      y: y\r\n    });\r\n\r\n    if (self.limitInPlot) {\r\n      // limit in chart plotRange\r\n      if (x >= 0 && x <= 1 && y >= 0 && y <= 1) {\r\n        return point;\r\n      }\r\n\r\n      return null;\r\n    }\r\n\r\n    return point;\r\n  }\r\n  /**\r\n   * render the guide component\r\n   * @param  {Coord} coord  coordinate instance\r\n   * @param  {Canvas.Group} group the container\r\n   */\r\n  ;\r\n\r\n  _proto.render = function render()\r\n  /* coord,group */\r\n  {};\r\n\r\n  _proto.repaint = function repaint() {\r\n    this.remove();\r\n    var coord = this.coord,\r\n        container = this.container,\r\n        canvas = this.canvas;\r\n\r\n    if (container && !container.isDestroyed()) {\r\n      this.render(coord, container);\r\n      canvas.draw();\r\n    }\r\n  };\r\n\r\n  _proto.remove = function remove() {\r\n    var element = this.element;\r\n    element && element.remove(true);\r\n  };\r\n\r\n  _proto.changeVisible = function changeVisible(visible) {\r\n    var self = this;\r\n    self.visible = visible;\r\n    var element = self.element;\r\n    if (!element) return;\r\n\r\n    if (element.set) {\r\n      element.set('visible', visible);\r\n    } else {\r\n      element.style.display = visible ? '' : 'none';\r\n    }\r\n  };\r\n\r\n  return GuideBase;\r\n}();\r\n\r\nmodule.exports = GuideBase;","\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\r\n\r\nvar Util = require('../../util/common');\r\n\r\nvar GuideBase = require('./base');\r\n\r\nfunction getOffsetFromAlign(alignX, alignY, width, height) {\r\n  var result = [];\r\n\r\n  if (alignX === 'left' && alignY === 'top') {\r\n    result[0] = 0;\r\n    result[1] = 0;\r\n  } else if (alignX === 'right' && alignY === 'top') {\r\n    result[0] = -width;\r\n    result[1] = 0;\r\n  } else if (alignX === 'left' && alignY === 'bottom') {\r\n    result[0] = 0;\r\n    result[1] = Math.floor(-height);\r\n  } else if (alignX === 'right' && alignY === 'bottom') {\r\n    result[0] = Math.floor(-width);\r\n    result[1] = Math.floor(-height);\r\n  } else if (alignX === 'right' && alignY === 'middle') {\r\n    result[0] = Math.floor(-width);\r\n    result[1] = Math.floor(-height / 2);\r\n  } else if (alignX === 'left' && alignY === 'middle') {\r\n    result[0] = 0;\r\n    result[1] = Math.floor(-height / 2);\r\n  } else if (alignX === 'center' && alignY === 'bottom') {\r\n    result[0] = Math.floor(-width / 2);\r\n    result[1] = Math.floor(-height);\r\n  } else if (alignX === 'center' && alignY === 'top') {\r\n    result[0] = Math.floor(-width / 2);\r\n    result[1] = 0;\r\n  } else {\r\n    result[0] = Math.floor(-width / 2);\r\n    result[1] = Math.floor(-height / 2);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction modifyCSS(DOM, CSS) {\r\n  for (var key in CSS) {\r\n    if (CSS.hasOwnProperty(key)) {\r\n      DOM.style[key] = CSS[key];\r\n    }\r\n  }\r\n\r\n  return DOM;\r\n}\r\n\r\nfunction createDom(str) {\r\n  var container = document.createElement('div');\r\n  str = str.replace(/(^\\s*)|(\\s*$)/g, '');\r\n  container.innerHTML = '' + str;\r\n  return container.childNodes[0];\r\n}\r\n\r\nvar Html =\r\n/*#__PURE__*/\r\nfunction (_GuideBase) {\r\n  (0, _inheritsLoose2[\"default\"])(Html, _GuideBase);\r\n\r\n  function Html() {\r\n    return _GuideBase.apply(this, arguments) || this;\r\n  }\r\n\r\n  var _proto = Html.prototype;\r\n\r\n  _proto._initDefaultCfg = function _initDefaultCfg() {\r\n    this.type = 'html';\r\n    /**\r\n     * dom position\r\n     * @type {Object | Array}\r\n     */\r\n\r\n    this.position = null;\r\n    /**\r\n      * alignment for horizontal direction，can be 'left','center','right'\r\n      * @type {String}\r\n      */\r\n\r\n    this.alignX = 'center';\r\n    /**\r\n      * alignment for vertical direction，can be 'top', 'middle', 'bottom'\r\n      * @type {String}\r\n      */\r\n\r\n    this.alignY = 'middle';\r\n    /**\r\n      * offset for horizontal direction\r\n      * @type {Number}\r\n      */\r\n\r\n    this.offsetX = null;\r\n    /**\r\n      * offset for vertical direction\r\n      * @type {Number}\r\n      */\r\n\r\n    this.offsetY = null;\r\n    /**\r\n    * the html string\r\n    *@type {String | Function}\r\n    */\r\n\r\n    this.html = null;\r\n  } // override paint\r\n  ;\r\n\r\n  _proto.render = function render(coord, container) {\r\n    var self = this;\r\n    var position = self.parsePoint(coord, self.position);\r\n\r\n    if (!position) {\r\n      return;\r\n    }\r\n\r\n    var myNode = createDom(self.html);\r\n    myNode = modifyCSS(myNode, {\r\n      position: 'absolute',\r\n      top: Math.floor(position.y) + 'px',\r\n      left: Math.floor(position.x) + 'px',\r\n      visibility: 'hidden'\r\n    });\r\n    var canvasDom = container.get('canvas').get('el');\r\n    var parentNode = canvasDom.parentNode;\r\n    parentNode = modifyCSS(parentNode, {\r\n      position: 'relative'\r\n    });\r\n    var wrapperNode = createDom('<div class=\"guideWapper\" style=\"position: absolute;top: 0; left: 0;\"></div>');\r\n    parentNode.appendChild(wrapperNode);\r\n    wrapperNode.appendChild(myNode);\r\n    var canvasOffsetTop = canvasDom.offsetTop;\r\n    var canvasOffsetLeft = canvasDom.offsetLeft;\r\n    var alignX = self.alignX,\r\n        alignY = self.alignY,\r\n        offsetX = self.offsetX,\r\n        offsetY = self.offsetY;\r\n    var width = Util.getWidth(myNode);\r\n    var height = Util.getHeight(myNode);\r\n    var newOffset = getOffsetFromAlign(alignX, alignY, width, height);\r\n    position.x = position.x + newOffset[0] + canvasOffsetLeft;\r\n    position.y = position.y + newOffset[1] + canvasOffsetTop;\r\n\r\n    if (offsetX) {\r\n      position.x += offsetX;\r\n    }\r\n\r\n    if (offsetY) {\r\n      position.y += offsetY;\r\n    }\r\n\r\n    modifyCSS(myNode, {\r\n      top: Math.floor(position.y) + 'px',\r\n      left: Math.floor(position.x) + 'px',\r\n      visibility: 'visible'\r\n    });\r\n    self.element = wrapperNode;\r\n  };\r\n\r\n  _proto.remove = function remove() {\r\n    var element = this.element;\r\n    element && element.parentNode && element.parentNode.removeChild(element);\r\n  };\r\n\r\n  return Html;\r\n}(GuideBase);\r\n\r\nGuideBase.Html = Html;\r\nmodule.exports = Html;","\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\r\n\r\nvar Util = require('../../util/common');\r\n\r\nvar GuideBase = require('./base');\r\n\r\nvar Line =\r\n/*#__PURE__*/\r\nfunction (_GuideBase) {\r\n  (0, _inheritsLoose2[\"default\"])(Line, _GuideBase);\r\n\r\n  function Line() {\r\n    return _GuideBase.apply(this, arguments) || this;\r\n  }\r\n\r\n  var _proto = Line.prototype;\r\n\r\n  _proto._initDefaultCfg = function _initDefaultCfg() {\r\n    this.type = 'line';\r\n    this.start = [];\r\n    this.end = [];\r\n    this.style = {\r\n      stroke: '#000',\r\n      lineWidth: 1\r\n    };\r\n  };\r\n\r\n  _proto.render = function render(coord, container) {\r\n    var points = [];\r\n    points[0] = this.parsePoint(coord, this.start);\r\n    points[1] = this.parsePoint(coord, this.end);\r\n\r\n    if (!points[0] || !points[1]) {\r\n      return;\r\n    }\r\n\r\n    var shape = container.addShape('Line', {\r\n      className: 'guide-line',\r\n      attrs: Util.mix({\r\n        x1: points[0].x,\r\n        y1: points[0].y,\r\n        x2: points[1].x,\r\n        y2: points[1].y\r\n      }, this.style)\r\n    });\r\n    this.element = shape;\r\n    return shape;\r\n  };\r\n\r\n  return Line;\r\n}(GuideBase);\r\n\r\nGuideBase.Line = Line;\r\nmodule.exports = Line;","\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\r\n\r\nvar Util = require('../../util/common');\r\n\r\nvar GuideBase = require('./base');\r\n\r\nvar Rect =\r\n/*#__PURE__*/\r\nfunction (_GuideBase) {\r\n  (0, _inheritsLoose2[\"default\"])(Rect, _GuideBase);\r\n\r\n  function Rect() {\r\n    return _GuideBase.apply(this, arguments) || this;\r\n  }\r\n\r\n  var _proto = Rect.prototype;\r\n\r\n  _proto._initDefaultCfg = function _initDefaultCfg() {\r\n    this.type = 'rect';\r\n    this.start = [];\r\n    this.end = [];\r\n    this.style = {\r\n      fill: '#CCD7EB',\r\n      opacity: 0.4\r\n    };\r\n  };\r\n\r\n  _proto.render = function render(coord, container) {\r\n    var start = this.parsePoint(coord, this.start);\r\n    var end = this.parsePoint(coord, this.end);\r\n\r\n    if (!start || !end) {\r\n      return;\r\n    }\r\n\r\n    var shape = container.addShape('rect', {\r\n      className: 'guide-rect',\r\n      attrs: Util.mix({\r\n        x: Math.min(start.x, end.x),\r\n        y: Math.min(start.y, end.y),\r\n        width: Math.abs(end.x - start.x),\r\n        height: Math.abs(start.y - end.y)\r\n      }, this.style)\r\n    });\r\n    this.element = shape;\r\n    return shape;\r\n  };\r\n\r\n  return Rect;\r\n}(GuideBase);\r\n\r\nGuideBase.Rect = Rect;\r\nmodule.exports = Rect;","\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\r\n\r\nvar Util = require('../../util/common');\r\n\r\nvar GuideBase = require('./base');\r\n\r\nvar Text =\r\n/*#__PURE__*/\r\nfunction (_GuideBase) {\r\n  (0, _inheritsLoose2[\"default\"])(Text, _GuideBase);\r\n\r\n  function Text() {\r\n    return _GuideBase.apply(this, arguments) || this;\r\n  }\r\n\r\n  var _proto = Text.prototype;\r\n\r\n  _proto._initDefaultCfg = function _initDefaultCfg() {\r\n    this.type = 'text';\r\n    /**\r\n     * the position of text\r\n     * @type {Function | Array}\r\n     */\r\n\r\n    this.position = null;\r\n    /**\r\n     * the display content\r\n     * @type {String}\r\n     */\r\n\r\n    this.content = null;\r\n    /**\r\n     * style configuration for text\r\n     * @type {Object}\r\n     */\r\n\r\n    this.style = {\r\n      fill: '#000'\r\n    };\r\n    /**\r\n     * offset of horizontal direction\r\n     * @type {Number}\r\n     */\r\n\r\n    this.offsetX = 0;\r\n    /**\r\n     * offset of vertical direction\r\n     * @type {Number}\r\n     */\r\n\r\n    this.offsetY = 0;\r\n  };\r\n\r\n  _proto.render = function render(coord, container) {\r\n    var position = this.position;\r\n    var point = this.parsePoint(coord, position);\r\n\r\n    if (!point) {\r\n      return;\r\n    }\r\n\r\n    var content = this.content,\r\n        style = this.style,\r\n        offsetX = this.offsetX,\r\n        offsetY = this.offsetY;\r\n\r\n    if (offsetX) {\r\n      point.x += offsetX;\r\n    }\r\n\r\n    if (offsetY) {\r\n      point.y += offsetY;\r\n    }\r\n\r\n    var shape = container.addShape('text', {\r\n      className: 'guide-text',\r\n      attrs: Util.mix({\r\n        x: point.x,\r\n        y: point.y,\r\n        text: content\r\n      }, style)\r\n    });\r\n    this.element = shape;\r\n    return shape;\r\n  };\r\n\r\n  return Text;\r\n}(GuideBase);\r\n\r\nGuideBase.Text = Text;\r\nmodule.exports = Text;","\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\r\n\r\nvar Util = require('../../util/common');\r\n\r\nvar GuideBase = require('./base');\r\n\r\nvar Tag =\r\n/*#__PURE__*/\r\nfunction (_GuideBase) {\r\n  (0, _inheritsLoose2[\"default\"])(Tag, _GuideBase);\r\n\r\n  function Tag() {\r\n    return _GuideBase.apply(this, arguments) || this;\r\n  }\r\n\r\n  var _proto = Tag.prototype;\r\n\r\n  _proto._initDefaultCfg = function _initDefaultCfg() {\r\n    this.type = 'tag';\r\n    this.position = null;\r\n    this.content = null;\r\n    this.direct = 'tl';\r\n    this.autoAdjust = true;\r\n    this.offsetX = 0;\r\n    this.offsetY = 0;\r\n    this.side = 4;\r\n    this.background = {\r\n      padding: 5,\r\n      radius: 2,\r\n      fill: '#1890FF'\r\n    };\r\n    this.textStyle = {\r\n      fontSize: 12,\r\n      fill: '#fff',\r\n      textAlign: 'center',\r\n      textBaseline: 'middle'\r\n    };\r\n    this.withPoint = true;\r\n    this.pointStyle = {\r\n      fill: '#1890FF',\r\n      r: 3,\r\n      lineWidth: 1,\r\n      stroke: '#fff'\r\n    };\r\n  };\r\n\r\n  _proto._getDirect = function _getDirect(container, point, tagWidth, tagHeight) {\r\n    var direct = this.direct;\r\n    var side = this.side;\r\n    var canvas = container.get('canvas');\r\n    var clientWidth = canvas.get('width');\r\n    var clientHeight = canvas.get('height');\r\n    var x = point.x,\r\n        y = point.y;\r\n    var vertical = direct[0];\r\n    var horizontal = direct[1]; // adjust for vertical direction\r\n\r\n    if (vertical === 't' && y - side - tagHeight < 0) {\r\n      vertical = 'b';\r\n    } else if (vertical === 'b' && y + side + tagHeight > clientHeight) {\r\n      vertical = 't';\r\n    } // adjust for horizontal direction\r\n\r\n\r\n    var diff = vertical === 'c' ? side : 0;\r\n\r\n    if (horizontal === 'l' && x - diff - tagWidth < 0) {\r\n      horizontal = 'r';\r\n    } else if (horizontal === 'r' && x + diff + tagWidth > clientWidth) {\r\n      horizontal = 'l';\r\n    } else if (horizontal === 'c') {\r\n      if (tagWidth / 2 + x + diff > clientWidth) {\r\n        horizontal = 'l';\r\n      } else if (x - tagWidth / 2 - diff < 0) {\r\n        horizontal = 'r';\r\n      }\r\n    }\r\n\r\n    direct = vertical + horizontal;\r\n    return direct;\r\n  };\r\n\r\n  _proto.render = function render(coord, container) {\r\n    var position = this.parsePoint(coord, this.position);\r\n\r\n    if (!position) {\r\n      return;\r\n    }\r\n\r\n    var content = this.content,\r\n        background = this.background,\r\n        textStyle = this.textStyle;\r\n    var shapes = [];\r\n    var wrapperContainer = container.addGroup({\r\n      className: 'guide-tag'\r\n    });\r\n\r\n    if (this.withPoint) {\r\n      var pointShape = wrapperContainer.addShape('Circle', {\r\n        className: 'guide-tag-point',\r\n        attrs: Util.mix({\r\n          x: position.x,\r\n          y: position.y\r\n        }, this.pointStyle)\r\n      });\r\n      shapes.push(pointShape);\r\n    }\r\n\r\n    var tagContainer = wrapperContainer.addGroup(); // create a text shape\r\n\r\n    var tagText = tagContainer.addShape('text', {\r\n      className: 'guide-tag-text',\r\n      zIndex: 1,\r\n      attrs: Util.mix({\r\n        x: 0,\r\n        y: 0,\r\n        text: content\r\n      }, textStyle)\r\n    });\r\n    shapes.push(tagText); // create background box\r\n\r\n    var textBBox = tagText.getBBox();\r\n    var padding = Util.parsePadding(background.padding);\r\n    var tagWidth = textBBox.width + padding[1] + padding[3];\r\n    var tagHeight = textBBox.height + padding[0] + padding[2];\r\n    var yMin = textBBox.minY - padding[0];\r\n    var xMin = textBBox.minX - padding[3];\r\n    var tagBg = tagContainer.addShape('rect', {\r\n      className: 'guide-tag-bg',\r\n      zIndex: -1,\r\n      attrs: Util.mix({\r\n        x: xMin,\r\n        y: yMin,\r\n        width: tagWidth,\r\n        height: tagHeight\r\n      }, background)\r\n    });\r\n    shapes.push(tagBg);\r\n    var direct = this.autoAdjust ? this._getDirect(container, position, tagWidth, tagHeight) : this.direct;\r\n    var side = this.side;\r\n    var x = position.x + this.offsetX;\r\n    var y = position.y + this.offsetY;\r\n    var arrowPoints;\r\n    var radius = Util.parsePadding(background.radius);\r\n\r\n    if (direct === 'tl') {\r\n      arrowPoints = [{\r\n        x: tagWidth + xMin - side - 1,\r\n        y: tagHeight + yMin - 1\r\n      }, // 这个 1 是为了防止出现白边\r\n      {\r\n        x: tagWidth + xMin,\r\n        y: tagHeight + yMin - 1\r\n      }, {\r\n        x: tagWidth + xMin,\r\n        y: tagHeight + side + yMin\r\n      }];\r\n      radius[2] = 0;\r\n      x = x - tagWidth;\r\n      y = y - side - tagHeight;\r\n    } else if (direct === 'cl') {\r\n      arrowPoints = [{\r\n        x: tagWidth + xMin - 1,\r\n        y: (tagHeight - side) / 2 + yMin - 1\r\n      }, {\r\n        x: tagWidth + xMin - 1,\r\n        y: (tagHeight + side) / 2 + yMin + 1\r\n      }, {\r\n        x: tagWidth + side + xMin,\r\n        y: tagHeight / 2 + yMin\r\n      }];\r\n      x = x - tagWidth - side;\r\n      y = y - tagHeight / 2;\r\n    } else if (direct === 'bl') {\r\n      arrowPoints = [{\r\n        x: tagWidth + xMin,\r\n        y: -side + yMin\r\n      }, {\r\n        x: tagWidth + xMin - side - 1,\r\n        y: yMin + 1\r\n      }, {\r\n        x: tagWidth + xMin,\r\n        y: yMin + 1\r\n      }];\r\n      radius[1] = 0;\r\n      x = x - tagWidth;\r\n      y = y + side;\r\n    } else if (direct === 'bc') {\r\n      arrowPoints = [{\r\n        x: tagWidth / 2 + xMin,\r\n        y: -side + yMin\r\n      }, {\r\n        x: (tagWidth - side) / 2 + xMin - 1,\r\n        y: yMin + 1\r\n      }, {\r\n        x: (tagWidth + side) / 2 + xMin + 1,\r\n        y: yMin + 1\r\n      }];\r\n      x = x - tagWidth / 2;\r\n      y = y + side;\r\n    } else if (direct === 'br') {\r\n      arrowPoints = [{\r\n        x: xMin,\r\n        y: yMin - side\r\n      }, {\r\n        x: xMin,\r\n        y: yMin + 1\r\n      }, {\r\n        x: xMin + side + 1,\r\n        y: yMin + 1\r\n      }];\r\n      radius[0] = 0;\r\n      y = y + side;\r\n    } else if (direct === 'cr') {\r\n      arrowPoints = [{\r\n        x: xMin - side,\r\n        y: tagHeight / 2 + yMin\r\n      }, {\r\n        x: xMin + 1,\r\n        y: (tagHeight - side) / 2 + yMin - 1\r\n      }, {\r\n        x: xMin + 1,\r\n        y: (tagHeight + side) / 2 + yMin + 1\r\n      }];\r\n      x = x + side;\r\n      y = y - tagHeight / 2;\r\n    } else if (direct === 'tr') {\r\n      arrowPoints = [{\r\n        x: xMin,\r\n        y: tagHeight + side + yMin\r\n      }, {\r\n        x: xMin,\r\n        y: tagHeight + yMin - 1\r\n      }, {\r\n        x: side + xMin + 1,\r\n        y: tagHeight + yMin - 1\r\n      }];\r\n      radius[3] = 0;\r\n      y = y - tagHeight - side;\r\n    } else if (direct === 'tc') {\r\n      arrowPoints = [{\r\n        x: (tagWidth - side) / 2 + xMin - 1,\r\n        y: tagHeight + yMin - 1\r\n      }, {\r\n        x: (tagWidth + side) / 2 + xMin + 1,\r\n        y: tagHeight + yMin - 1\r\n      }, {\r\n        x: tagWidth / 2 + xMin,\r\n        y: tagHeight + side + yMin\r\n      }];\r\n      x = x - tagWidth / 2;\r\n      y = y - tagHeight - side;\r\n    }\r\n\r\n    var sideShape = tagContainer.addShape('Polygon', {\r\n      className: 'guide-tag-side',\r\n      zIndex: 0,\r\n      attrs: {\r\n        points: arrowPoints,\r\n        fill: background.fill\r\n      }\r\n    });\r\n    shapes.push(sideShape);\r\n    tagBg.attr('radius', radius);\r\n    tagContainer.moveTo(x - xMin, y - yMin);\r\n    tagContainer.sort();\r\n    this.element = wrapperContainer;\r\n    return shapes;\r\n  };\r\n\r\n  return Tag;\r\n}(GuideBase);\r\n\r\nGuideBase.Tag = Tag;\r\nmodule.exports = Tag;","\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\r\n\r\nvar Util = require('../../util/common');\r\n\r\nvar GuideBase = require('./base');\r\n\r\nvar Point =\r\n/*#__PURE__*/\r\nfunction (_GuideBase) {\r\n  (0, _inheritsLoose2[\"default\"])(Point, _GuideBase);\r\n\r\n  function Point() {\r\n    return _GuideBase.apply(this, arguments) || this;\r\n  }\r\n\r\n  var _proto = Point.prototype;\r\n\r\n  _proto._initDefaultCfg = function _initDefaultCfg() {\r\n    this.type = 'point';\r\n    this.position = null;\r\n    this.offsetX = 0;\r\n    this.offsetY = 0;\r\n    this.style = {\r\n      fill: '#1890FF',\r\n      r: 3,\r\n      lineWidth: 1,\r\n      stroke: '#fff'\r\n    };\r\n  };\r\n\r\n  _proto.render = function render(coord, container) {\r\n    var position = this.parsePoint(coord, this.position);\r\n    if (!position) return null;\r\n    var shape = container.addShape('Circle', {\r\n      className: 'guide-point',\r\n      attrs: Util.mix({\r\n        x: position.x + this.offsetX,\r\n        y: position.y + this.offsetY\r\n      }, this.style)\r\n    });\r\n    this.element = shape;\r\n    return shape;\r\n  };\r\n\r\n  return Point;\r\n}(GuideBase);\r\n\r\nGuideBase.Point = Point;\r\nmodule.exports = Point;","\r\n\r\nvar Util = require('../util/common');\r\n\r\nvar Global = require('../global');\r\n\r\nvar Tooltip = require('../component/tooltip');\r\n\r\nvar Helper = require('../util/helper'); // Register the default configuration for Tooltip\r\n\r\n\r\nGlobal.tooltip = Util.deepMix({\r\n  triggerOn: ['touchstart', 'touchmove'],\r\n  // triggerOff: 'touchend',\r\n  alwaysShow: false,\r\n  showTitle: false,\r\n  showCrosshairs: false,\r\n  crosshairsStyle: {\r\n    stroke: 'rgba(0, 0, 0, 0.25)',\r\n    lineWidth: 1\r\n  },\r\n  showTooltipMarker: true,\r\n  background: {\r\n    radius: 1,\r\n    fill: 'rgba(0, 0, 0, 0.65)',\r\n    padding: [3, 5]\r\n  },\r\n  titleStyle: {\r\n    fontSize: 12,\r\n    fill: '#fff',\r\n    textAlign: 'start',\r\n    textBaseline: 'top'\r\n  },\r\n  nameStyle: {\r\n    fontSize: 12,\r\n    fill: 'rgba(255, 255, 255, 0.65)',\r\n    textAlign: 'start',\r\n    textBaseline: 'middle'\r\n  },\r\n  valueStyle: {\r\n    fontSize: 12,\r\n    fill: '#fff',\r\n    textAlign: 'start',\r\n    textBaseline: 'middle'\r\n  },\r\n  showItemMarker: true,\r\n  itemMarkerStyle: {\r\n    radius: 3,\r\n    symbol: 'circle',\r\n    lineWidth: 1,\r\n    stroke: '#fff'\r\n  },\r\n  layout: 'horizontal',\r\n  snap: false\r\n}, Global.tooltip || {});\r\n\r\nfunction _getTooltipValueScale(geom) {\r\n  var colorAttr = geom.getAttr('color');\r\n\r\n  if (colorAttr) {\r\n    var colorScale = colorAttr.getScale(colorAttr.type);\r\n\r\n    if (colorScale.isLinear) {\r\n      return colorScale;\r\n    }\r\n  }\r\n\r\n  var xScale = geom.getXScale();\r\n  var yScale = geom.getYScale();\r\n\r\n  if (yScale) {\r\n    return yScale;\r\n  }\r\n\r\n  return xScale;\r\n}\r\n\r\nfunction getTooltipName(geom, origin) {\r\n  var name;\r\n  var nameScale;\r\n\r\n  var groupScales = geom._getGroupScales();\r\n\r\n  if (groupScales.length) {\r\n    Util.each(groupScales, function (scale) {\r\n      nameScale = scale;\r\n      return false;\r\n    });\r\n  }\r\n\r\n  if (nameScale) {\r\n    var field = nameScale.field;\r\n    name = nameScale.getText(origin[field]);\r\n  } else {\r\n    var valueScale = _getTooltipValueScale(geom);\r\n\r\n    name = valueScale.alias || valueScale.field;\r\n  }\r\n\r\n  return name;\r\n}\r\n\r\nfunction getTooltipValue(geom, origin) {\r\n  var scale = _getTooltipValueScale(geom);\r\n\r\n  return scale.getText(origin[scale.field]);\r\n}\r\n\r\nfunction getTooltipTitle(geom, origin) {\r\n  var position = geom.getAttr('position');\r\n  var field = position.getFields()[0];\r\n  var scale = geom.get('scales')[field];\r\n  return scale.getText(origin[scale.field]);\r\n}\r\n\r\nfunction _indexOfArray(items, item) {\r\n  var rst = -1;\r\n  Util.each(items, function (sub, index) {\r\n    if (sub.title === item.title && sub.name === item.name && sub.value === item.value && sub.color === item.color) {\r\n      rst = index;\r\n      return false;\r\n    }\r\n  });\r\n  return rst;\r\n}\r\n\r\nfunction _uniqItems(items) {\r\n  var tmp = [];\r\n  Util.each(items, function (item) {\r\n    var index = _indexOfArray(tmp, item);\r\n\r\n    if (index === -1) {\r\n      tmp.push(item);\r\n    } else {\r\n      tmp[index] = item;\r\n    }\r\n  });\r\n  return tmp;\r\n}\r\n\r\nfunction isEqual(arr1, arr2) {\r\n  return JSON.stringify(arr1) === JSON.stringify(arr2);\r\n}\r\n\r\nvar TooltipController =\r\n/*#__PURE__*/\r\nfunction () {\r\n  function TooltipController(cfg) {\r\n    this.enable = true;\r\n    this.cfg = {};\r\n    this.tooltip = null;\r\n    this.chart = null;\r\n    this.timeStamp = 0;\r\n    Util.mix(this, cfg);\r\n    var chart = this.chart;\r\n    this.canvasDom = chart.get('canvas').get('el');\r\n  }\r\n\r\n  var _proto = TooltipController.prototype;\r\n\r\n  _proto._setCrosshairsCfg = function _setCrosshairsCfg() {\r\n    var self = this;\r\n    var chart = self.chart;\r\n    var defaultCfg = Util.mix({}, Global.tooltip);\r\n    var geoms = chart.get('geoms');\r\n    var shapes = [];\r\n    Util.each(geoms, function (geom) {\r\n      var type = geom.get('type');\r\n\r\n      if (shapes.indexOf(type) === -1) {\r\n        shapes.push(type);\r\n      }\r\n    });\r\n    var coordType = chart.get('coord').type;\r\n\r\n    if (geoms.length && (coordType === 'cartesian' || coordType === 'rect')) {\r\n      if (shapes.length === 1 && ['line', 'area', 'path', 'point'].indexOf(shapes[0]) !== -1) {\r\n        Util.mix(defaultCfg, {\r\n          showCrosshairs: true\r\n        });\r\n      }\r\n    }\r\n\r\n    return defaultCfg;\r\n  };\r\n\r\n  _proto._getMaxLength = function _getMaxLength(cfg) {\r\n    if (cfg === void 0) {\r\n      cfg = {};\r\n    }\r\n\r\n    var _cfg = cfg,\r\n        layout = _cfg.layout,\r\n        plotRange = _cfg.plotRange;\r\n    return layout === 'horizontal' ? plotRange.br.x - plotRange.bl.x : plotRange.bl.y - plotRange.tr.y;\r\n  };\r\n\r\n  _proto.render = function render() {\r\n    var self = this;\r\n\r\n    if (self.tooltip) {\r\n      return;\r\n    }\r\n\r\n    var chart = self.chart;\r\n    var canvas = chart.get('canvas');\r\n    var frontPlot = chart.get('frontPlot').addGroup({\r\n      className: 'tooltipContainer',\r\n      zIndex: 10\r\n    });\r\n    var backPlot = chart.get('backPlot').addGroup({\r\n      className: 'tooltipContainer'\r\n    });\r\n    var plotRange = chart.get('plotRange');\r\n    var coord = chart.get('coord');\r\n\r\n    var defaultCfg = self._setCrosshairsCfg();\r\n\r\n    var cfg = self.cfg; // 通过 chart.tooltip() 接口传入的 tooltip 配置项\r\n\r\n    var tooltipCfg = Util.deepMix({\r\n      plotRange: plotRange,\r\n      frontPlot: frontPlot,\r\n      backPlot: backPlot,\r\n      canvas: canvas,\r\n      fixed: coord.transposed || coord.isPolar\r\n    }, defaultCfg, cfg); // 创建 tooltip 实例需要的配置，不应该修改 this.cfg，即用户传入的配置\r\n\r\n    tooltipCfg.maxLength = self._getMaxLength(tooltipCfg);\r\n    this._tooltipCfg = tooltipCfg;\r\n    var tooltip = new Tooltip(tooltipCfg);\r\n    self.tooltip = tooltip;\r\n    self.bindEvents();\r\n  };\r\n\r\n  _proto.clear = function clear() {\r\n    var tooltip = this.tooltip;\r\n\r\n    if (tooltip) {\r\n      tooltip.destroy();\r\n      this.unBindEvents();\r\n    }\r\n\r\n    this.tooltip = null;\r\n    this.prePoint = null;\r\n    this._lastActive = null;\r\n  };\r\n\r\n  _proto._getTooltipMarkerStyle = function _getTooltipMarkerStyle(cfg) {\r\n    if (cfg === void 0) {\r\n      cfg = {};\r\n    }\r\n\r\n    var _cfg2 = cfg,\r\n        type = _cfg2.type,\r\n        items = _cfg2.items;\r\n    var tooltipCfg = this._tooltipCfg;\r\n\r\n    if (type === 'rect') {\r\n      var x;\r\n      var y;\r\n      var width;\r\n      var height;\r\n      var chart = this.chart;\r\n\r\n      var _chart$get = chart.get('plotRange'),\r\n          tl = _chart$get.tl,\r\n          br = _chart$get.br;\r\n\r\n      var coord = chart.get('coord');\r\n      var firstItem = items[0];\r\n      var lastItem = items[items.length - 1];\r\n      var intervalWidth = firstItem.width;\r\n\r\n      if (coord.transposed) {\r\n        x = tl.x;\r\n        y = lastItem.y - intervalWidth * 0.75;\r\n        width = br.x - tl.x;\r\n        height = firstItem.y - lastItem.y + 1.5 * intervalWidth;\r\n      } else {\r\n        x = firstItem.x - intervalWidth * 0.75;\r\n        y = tl.y;\r\n        width = lastItem.x - firstItem.x + 1.5 * intervalWidth;\r\n        height = br.y - tl.y;\r\n      }\r\n\r\n      cfg.style = Util.mix({\r\n        x: x,\r\n        y: y,\r\n        width: width,\r\n        height: height,\r\n        fill: '#CCD6EC',\r\n        opacity: 0.3\r\n      }, tooltipCfg.tooltipMarkerStyle);\r\n    } else {\r\n      cfg.style = Util.mix({\r\n        radius: 4,\r\n        fill: '#fff',\r\n        lineWidth: 2\r\n      }, tooltipCfg.tooltipMarkerStyle);\r\n    }\r\n\r\n    return cfg;\r\n  };\r\n\r\n  _proto._setTooltip = function _setTooltip(point, items, tooltipMarkerCfg) {\r\n    if (tooltipMarkerCfg === void 0) {\r\n      tooltipMarkerCfg = {};\r\n    }\r\n\r\n    var lastActive = this._lastActive;\r\n    var tooltip = this.tooltip;\r\n    var cfg = this._tooltipCfg;\r\n    items = _uniqItems(items);\r\n    var chart = this.chart;\r\n    var coord = chart.get('coord');\r\n    var yScale = chart.getYScales()[0];\r\n    var snap = cfg.snap;\r\n\r\n    if (snap === false && yScale.isLinear) {\r\n      var invertPoint = coord.invertPoint(point);\r\n      var plot = chart.get('plotRange');\r\n      var tip;\r\n      var pos;\r\n\r\n      if (Helper.isPointInPlot(point, plot)) {\r\n        if (coord.transposed) {\r\n          tip = yScale.invert(invertPoint.x);\r\n          pos = point.x;\r\n          tooltip.setXTipContent(tip);\r\n          tooltip.setXTipPosition(pos);\r\n          tooltip.setYCrosshairPosition(pos);\r\n        } else {\r\n          tip = yScale.invert(invertPoint.y);\r\n          pos = point.y;\r\n          tooltip.setYTipContent(tip);\r\n          tooltip.setYTipPosition(pos);\r\n          tooltip.setXCrosshairPosition(pos);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (cfg.onShow) {\r\n      cfg.onShow({\r\n        x: point.x,\r\n        y: point.y,\r\n        tooltip: tooltip,\r\n        items: items,\r\n        tooltipMarkerCfg: tooltipMarkerCfg\r\n      });\r\n    }\r\n\r\n    if (isEqual(lastActive, items)) {\r\n      if (snap === false && (Util.directionEnabled(cfg.crosshairsType, 'y') || cfg.showYTip)) {\r\n        var canvas = this.chart.get('canvas');\r\n        canvas.draw();\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    this._lastActive = items;\r\n    var onChange = cfg.onChange;\r\n\r\n    if (onChange) {\r\n      onChange({\r\n        x: point.x,\r\n        y: point.y,\r\n        tooltip: tooltip,\r\n        items: items,\r\n        tooltipMarkerCfg: tooltipMarkerCfg\r\n      });\r\n    }\r\n\r\n    var first = items[0];\r\n    var title = first.title || first.name;\r\n    var xTipPosX = first.x;\r\n\r\n    if (items.length > 1) {\r\n      xTipPosX = (items[0].x + items[items.length - 1].x) / 2;\r\n    }\r\n\r\n    tooltip.setContent(title, items, coord.transposed);\r\n    tooltip.setPosition(items, point);\r\n\r\n    if (coord.transposed) {\r\n      var yTipPosY = first.y;\r\n\r\n      if (items.length > 1) {\r\n        yTipPosY = (items[0].y + items[items.length - 1].y) / 2;\r\n      }\r\n\r\n      tooltip.setYTipContent(title);\r\n      tooltip.setYTipPosition(yTipPosY);\r\n      tooltip.setXCrosshairPosition(yTipPosY);\r\n\r\n      if (snap) {\r\n        tooltip.setXTipContent(first.value);\r\n        tooltip.setXTipPosition(xTipPosX);\r\n        tooltip.setYCrosshairPosition(xTipPosX);\r\n      }\r\n    } else {\r\n      tooltip.setXTipContent(title);\r\n      tooltip.setXTipPosition(xTipPosX);\r\n      tooltip.setYCrosshairPosition(xTipPosX);\r\n\r\n      if (snap) {\r\n        tooltip.setYTipContent(first.value);\r\n        tooltip.setYTipPosition(first.y);\r\n        tooltip.setXCrosshairPosition(first.y);\r\n      }\r\n    }\r\n\r\n    var markerItems = tooltipMarkerCfg.items;\r\n\r\n    if (cfg.showTooltipMarker && markerItems.length) {\r\n      tooltipMarkerCfg = this._getTooltipMarkerStyle(tooltipMarkerCfg);\r\n      tooltip.setMarkers(tooltipMarkerCfg);\r\n    } else {\r\n      tooltip.clearMarkers();\r\n    }\r\n\r\n    tooltip.show();\r\n  };\r\n\r\n  _proto.showTooltip = function showTooltip(point) {\r\n    var self = this;\r\n    var chart = self.chart;\r\n    var tooltipMarkerType;\r\n    var tooltipMarkerItems = [];\r\n    var items = [];\r\n    var cfg = self._tooltipCfg;\r\n    var marker;\r\n\r\n    if (cfg.showItemMarker) {\r\n      marker = cfg.itemMarkerStyle;\r\n    }\r\n\r\n    var geoms = chart.get('geoms');\r\n    var coord = chart.get('coord');\r\n    Util.each(geoms, function (geom) {\r\n      if (geom.get('visible')) {\r\n        var type = geom.get('type');\r\n        var records = geom.getSnapRecords(point);\r\n        var adjust = geom.get('adjust'); // 漏斗图和金子塔图tooltip位置有问题，暂时不开放显示\r\n\r\n        if (type === 'interval' && adjust && adjust.type === 'symmetric') {\r\n          return;\r\n        }\r\n\r\n        Util.each(records, function (record) {\r\n          if (record.x && record.y) {\r\n            var x = record.x,\r\n                y = record.y,\r\n                _origin = record._origin,\r\n                color = record.color;\r\n            var tooltipItem = {\r\n              x: x,\r\n              y: Util.isArray(y) ? y[1] : y,\r\n              color: color || Global.defaultColor,\r\n              origin: _origin,\r\n              name: getTooltipName(geom, _origin),\r\n              value: getTooltipValue(geom, _origin),\r\n              title: getTooltipTitle(geom, _origin)\r\n            };\r\n\r\n            if (marker) {\r\n              tooltipItem.marker = Util.mix({\r\n                fill: color || Global.defaultColor\r\n              }, marker);\r\n            }\r\n\r\n            items.push(tooltipItem);\r\n\r\n            if (['line', 'area', 'path'].indexOf(type) !== -1) {\r\n              tooltipMarkerType = 'circle';\r\n              tooltipMarkerItems.push(tooltipItem);\r\n            } else if (type === 'interval' && (coord.type === 'cartesian' || coord.type === 'rect')) {\r\n              tooltipMarkerType = 'rect';\r\n              tooltipItem.width = geom.getSize(record._origin);\r\n              tooltipMarkerItems.push(tooltipItem);\r\n            }\r\n          }\r\n        });\r\n      }\r\n    });\r\n\r\n    if (items.length) {\r\n      var tooltipMarkerCfg = {\r\n        items: tooltipMarkerItems,\r\n        type: tooltipMarkerType\r\n      };\r\n\r\n      self._setTooltip(point, items, tooltipMarkerCfg);\r\n    } else {\r\n      self.hideTooltip();\r\n    }\r\n  };\r\n\r\n  _proto.hideTooltip = function hideTooltip() {\r\n    var cfg = this._tooltipCfg;\r\n    this._lastActive = null;\r\n    var tooltip = this.tooltip;\r\n\r\n    if (tooltip) {\r\n      tooltip.hide();\r\n\r\n      if (cfg.onHide) {\r\n        cfg.onHide({\r\n          tooltip: tooltip\r\n        });\r\n      }\r\n\r\n      var canvas = this.chart.get('canvas');\r\n      canvas.draw();\r\n    }\r\n  };\r\n\r\n  _proto.handleShowEvent = function handleShowEvent(ev) {\r\n    var chart = this.chart;\r\n    if (!this.enable || chart.get('_closeTooltip')) return;\r\n    var plot = chart.get('plotRange');\r\n    var point = Util.createEvent(ev, chart);\r\n\r\n    if (!Helper.isPointInPlot(point, plot) && !this._tooltipCfg.alwaysShow) {\r\n      // not in chart plot\r\n      this.hideTooltip();\r\n      return;\r\n    }\r\n\r\n    var lastTimeStamp = this.timeStamp;\r\n    var timeStamp = +new Date();\r\n\r\n    if (timeStamp - lastTimeStamp > 16) {\r\n      this.showTooltip(point);\r\n      this.timeStamp = timeStamp;\r\n    }\r\n  };\r\n\r\n  _proto.handleHideEvent = function handleHideEvent() {\r\n    var chart = this.chart;\r\n    if (!this.enable || chart.get('_closeTooltip')) return;\r\n    this.hideTooltip();\r\n  };\r\n\r\n  _proto._handleEvent = function _handleEvent(methodName, method, action) {\r\n    var canvasDom = this.canvasDom;\r\n    Util.each([].concat(methodName), function (aMethod) {\r\n      if (action === 'bind') {\r\n        Util.addEventListener(canvasDom, aMethod, method);\r\n      } else {\r\n        Util.removeEventListener(canvasDom, aMethod, method);\r\n      }\r\n    });\r\n  };\r\n\r\n  _proto.bindEvents = function bindEvents() {\r\n    var cfg = this._tooltipCfg;\r\n    var canvasElement = this.canvasDom;\r\n    var triggerOn = cfg.triggerOn,\r\n        triggerOff = cfg.triggerOff,\r\n        alwaysShow = cfg.alwaysShow;\r\n    var showMethod = Util.wrapBehavior(this, 'handleShowEvent');\r\n    var hideMethod = Util.wrapBehavior(this, 'handleHideEvent');\r\n    triggerOn && this._handleEvent(triggerOn, showMethod, 'bind');\r\n    triggerOff && this._handleEvent(triggerOff, hideMethod, 'bind'); // 如果 !alwaysShow, 则在手势离开后就隐藏\r\n\r\n    if (!alwaysShow && !triggerOff) {\r\n      Util.addEventListener(canvasElement, 'touchend', hideMethod);\r\n    }\r\n  };\r\n\r\n  _proto.unBindEvents = function unBindEvents() {\r\n    var cfg = this._tooltipCfg;\r\n    var canvasElement = this.canvasDom;\r\n    var triggerOn = cfg.triggerOn,\r\n        triggerOff = cfg.triggerOff,\r\n        alwaysShow = cfg.alwaysShow;\r\n    var showMethod = Util.getWrapBehavior(this, 'handleShowEvent');\r\n    var hideMethod = Util.getWrapBehavior(this, 'handleHideEvent');\r\n    triggerOn && this._handleEvent(triggerOn, showMethod, 'unBind');\r\n    triggerOff && this._handleEvent(triggerOff, hideMethod, 'unBind');\r\n\r\n    if (!alwaysShow) {\r\n      var docMethod = Util.getWrapBehavior(this, 'handleDocEvent');\r\n      Util.removeEventListener(canvasElement, 'touchend', docMethod);\r\n    }\r\n  };\r\n\r\n  return TooltipController;\r\n}();\r\n\r\nmodule.exports = {\r\n  init: function init(chart) {\r\n    var tooltipController = new TooltipController({\r\n      chart: chart\r\n    });\r\n    chart.set('tooltipController', tooltipController);\r\n\r\n    chart.tooltip = function (enable, cfg) {\r\n      if (Util.isObject(enable)) {\r\n        cfg = enable;\r\n        enable = true;\r\n      }\r\n\r\n      tooltipController.enable = enable;\r\n\r\n      if (cfg) {\r\n        tooltipController.cfg = cfg;\r\n      }\r\n\r\n      return this;\r\n    };\r\n  },\r\n  afterGeomDraw: function afterGeomDraw(chart) {\r\n    var tooltipController = chart.get('tooltipController');\r\n    tooltipController.render();\r\n\r\n    chart.showTooltip = function (point) {\r\n      tooltipController.showTooltip(point);\r\n      return this;\r\n    };\r\n\r\n    chart.hideTooltip = function () {\r\n      tooltipController.hideTooltip();\r\n      return this;\r\n    };\r\n  },\r\n  clearInner: function clearInner(chart) {\r\n    var tooltipController = chart.get('tooltipController');\r\n    tooltipController.clear();\r\n  }\r\n};","\r\n\r\nvar Util = require('../util/common');\r\n\r\nvar Marker = require('./marker');\r\n\r\nvar Container = require('./list');\r\n\r\nvar TextBox = require('./text-box');\r\n\r\nvar GAP = 4;\r\n/**\r\n * TODOList：\r\n * 1. 移除 fixed 参数\r\n */\r\n\r\nvar Tooltip =\r\n/*#__PURE__*/\r\nfunction () {\r\n  var _proto = Tooltip.prototype;\r\n\r\n  _proto.getDefaultCfg = function getDefaultCfg() {\r\n    return {\r\n      /**\r\n       * wether show the crosshairs\r\n       * @type {Object}\r\n       */\r\n      showCrosshairs: false,\r\n\r\n      /**\r\n       * the style for crosshairs\r\n       * @type {Object}\r\n       */\r\n      crosshairsStyle: {\r\n        stroke: 'rgba(0, 0, 0, 0.25)',\r\n        lineWidth: 1\r\n      },\r\n\r\n      /**\r\n       * the type of crosshairs, optional value is 'x', 'y' or 'xy', default is 'y'\r\n       */\r\n      crosshairsType: 'y',\r\n\r\n      /**\r\n       * show or hide the x axis tip\r\n       */\r\n      showXTip: false,\r\n\r\n      /**\r\n       * show or hide the y axis tip\r\n       */\r\n      showYTip: false,\r\n      xTip: null,\r\n      xTipBackground: {\r\n        radius: 1,\r\n        fill: 'rgba(0, 0, 0, 0.65)',\r\n        padding: [3, 5]\r\n      },\r\n      yTip: null,\r\n      yTipBackground: {\r\n        radius: 1,\r\n        fill: 'rgba(0, 0, 0, 0.65)',\r\n        padding: [3, 5]\r\n      },\r\n\r\n      /**\r\n       * the style for tooltip container's background\r\n       * @type {Object}\r\n       */\r\n      background: null,\r\n\r\n      /**\r\n       * layout, can be horizontal or vertical\r\n       * @type {String}\r\n       */\r\n      layout: 'horizontal',\r\n      offsetX: 0,\r\n      offsetY: 0\r\n    };\r\n  };\r\n\r\n  function Tooltip(cfg) {\r\n    Util.deepMix(this, this.getDefaultCfg(), cfg);\r\n    var frontPlot = this.frontPlot,\r\n        custom = this.custom;\r\n\r\n    if (!custom) {\r\n      // custom means user do customize\r\n      var container = new Container(Util.mix({\r\n        parent: frontPlot,\r\n        zIndex: 3\r\n      }, cfg));\r\n      this.container = container;\r\n      var fixed = this.fixed,\r\n          background = this.background;\r\n\r\n      if (!fixed) {\r\n        this.tooltipArrow = frontPlot.addShape('Polygon', {\r\n          className: 'tooltip-arrow',\r\n          visible: false,\r\n          zIndex: 2,\r\n          attrs: Util.mix({\r\n            points: []\r\n          }, background)\r\n        });\r\n      }\r\n    }\r\n\r\n    if (this.showXTip) {\r\n      var xTipBackground = this.xTipBackground;\r\n      var xTipBox = new TextBox({\r\n        className: 'xTip',\r\n        background: xTipBackground,\r\n        visible: false\r\n      });\r\n      frontPlot.add(xTipBox.container);\r\n      this.xTipBox = xTipBox;\r\n    }\r\n\r\n    if (this.showYTip) {\r\n      var yTipBackground = this.yTipBackground;\r\n      var yTipBox = new TextBox({\r\n        className: 'yTip',\r\n        background: yTipBackground,\r\n        visible: false\r\n      });\r\n      frontPlot.add(yTipBox.container);\r\n      this.yTipBox = yTipBox;\r\n    }\r\n\r\n    if (this.showCrosshairs) {\r\n      this._renderCrosshairs();\r\n    }\r\n\r\n    frontPlot.sort();\r\n  }\r\n\r\n  _proto.setContent = function setContent(title, items) {\r\n    this.title = title;\r\n    this.items = items;\r\n\r\n    if (!this.custom) {\r\n      var container = this.container;\r\n      container.setTitle(title);\r\n      container.setItems(items);\r\n    }\r\n  };\r\n\r\n  _proto.setYTipContent = function setYTipContent(val) {\r\n    var yTip = this.yTip;\r\n\r\n    if (Util.isFunction(yTip)) {\r\n      val = yTip(val);\r\n    } else {\r\n      val = Util.mix({\r\n        text: val\r\n      }, yTip);\r\n    }\r\n\r\n    this.yTipBox && this.yTipBox.updateContent(val);\r\n  };\r\n\r\n  _proto.setYTipPosition = function setYTipPosition(pos) {\r\n    var plotRange = this.plotRange;\r\n    var crosshairsShapeX = this.crosshairsShapeX;\r\n\r\n    if (this.showYTip) {\r\n      var yTipBox = this.yTipBox;\r\n      var yTipHeight = yTipBox.getHeight();\r\n      var yTipWidth = yTipBox.getWidth();\r\n      var posX = plotRange.tl.x - yTipWidth;\r\n      var posY = pos - yTipHeight / 2;\r\n\r\n      if (posY <= plotRange.tl.y) {\r\n        posY = plotRange.tl.y;\r\n      }\r\n\r\n      if (posY + yTipHeight >= plotRange.br.y) {\r\n        posY = plotRange.br.y - yTipHeight;\r\n      }\r\n\r\n      if (posX < 0) {\r\n        posX = plotRange.tl.x;\r\n        crosshairsShapeX && crosshairsShapeX.attr('x1', plotRange.tl.x + yTipWidth);\r\n      }\r\n\r\n      yTipBox.updatePosition(posX, posY);\r\n    }\r\n  };\r\n\r\n  _proto.setXTipContent = function setXTipContent(val) {\r\n    var xTip = this.xTip;\r\n\r\n    if (Util.isFunction(xTip)) {\r\n      val = xTip(val);\r\n    } else {\r\n      val = Util.mix({\r\n        text: val\r\n      }, xTip);\r\n    }\r\n\r\n    this.xTipBox && this.xTipBox.updateContent(val);\r\n  };\r\n\r\n  _proto.setXTipPosition = function setXTipPosition(pos) {\r\n    var showXTip = this.showXTip,\r\n        canvas = this.canvas,\r\n        plotRange = this.plotRange,\r\n        xTipBox = this.xTipBox,\r\n        crosshairsShapeY = this.crosshairsShapeY;\r\n\r\n    if (showXTip) {\r\n      // const el = canvas.get('el');\r\n      // const canvasHeight = Util.getHeight(el);\r\n      var canvasHeight = canvas.get('height');\r\n      var xTipWidth = xTipBox.getWidth();\r\n      var xTipHeight = xTipBox.getHeight();\r\n      var posX = pos - xTipWidth / 2;\r\n      var posY = plotRange.br.y;\r\n\r\n      if (posX <= plotRange.tl.x) {\r\n        posX = plotRange.tl.x;\r\n      }\r\n\r\n      if (posX + xTipWidth >= plotRange.tr.x) {\r\n        posX = plotRange.tr.x - xTipWidth;\r\n      }\r\n\r\n      if (canvasHeight - posY < xTipHeight) {\r\n        posY -= xTipHeight;\r\n      }\r\n\r\n      xTipBox.updatePosition(posX, posY);\r\n      crosshairsShapeY && crosshairsShapeY.attr('y1', posY);\r\n    }\r\n  };\r\n\r\n  _proto.setXCrosshairPosition = function setXCrosshairPosition(pos) {\r\n    this.crosshairsShapeX && this.crosshairsShapeX.moveTo(0, pos);\r\n  };\r\n\r\n  _proto.setYCrosshairPosition = function setYCrosshairPosition(pos) {\r\n    this.crosshairsShapeY && this.crosshairsShapeY.moveTo(pos, 0);\r\n  };\r\n\r\n  _proto.setPosition = function setPosition(items) {\r\n    var container = this.container,\r\n        plotRange = this.plotRange,\r\n        offsetX = this.offsetX,\r\n        offsetY = this.offsetY,\r\n        fixed = this.fixed,\r\n        tooltipArrow = this.tooltipArrow;\r\n\r\n    if (!container) {\r\n      return;\r\n    }\r\n\r\n    var containerBBox = container.container.getBBox();\r\n    var minX = containerBBox.minX,\r\n        minY = containerBBox.minY,\r\n        width = containerBBox.width,\r\n        height = containerBBox.height;\r\n    var tl = plotRange.tl,\r\n        tr = plotRange.tr;\r\n    var posX = 0;\r\n    var posY = tl.y - height - GAP + offsetY;\r\n\r\n    if (fixed) {\r\n      var x = (tl.x + tr.x) / 2;\r\n      posX = x - width / 2 + offsetX;\r\n    } else {\r\n      var _x;\r\n\r\n      if (items.length > 1) {\r\n        _x = (items[0].x + items[items.length - 1].x) / 2;\r\n      } else {\r\n        _x = items[0].x;\r\n      }\r\n\r\n      posX = _x - width / 2 + offsetX;\r\n\r\n      if (posX < tl.x) {\r\n        posX = tl.x;\r\n      }\r\n\r\n      if (posX + width > tr.x) {\r\n        posX = tr.x - width;\r\n      }\r\n\r\n      if (tooltipArrow) {\r\n        tooltipArrow.attr('points', [{\r\n          x: _x - 3,\r\n          y: tl.y - GAP + offsetY\r\n        }, {\r\n          x: _x + 3,\r\n          y: tl.y - GAP + offsetY\r\n        }, {\r\n          x: _x,\r\n          y: tl.y + offsetY\r\n        }]);\r\n        var backShape = container.backShape;\r\n        var radius = Util.parsePadding(backShape.attr('radius'));\r\n\r\n        if (_x === tl.x) {\r\n          radius[3] = 0;\r\n          tooltipArrow.attr('points', [{\r\n            x: tl.x,\r\n            y: tl.y + offsetY\r\n          }, {\r\n            x: tl.x,\r\n            y: tl.y - GAP + offsetY\r\n          }, {\r\n            x: tl.x + GAP,\r\n            y: tl.y - GAP + offsetY\r\n          }]);\r\n        } else if (_x === tr.x) {\r\n          radius[2] = 0;\r\n          tooltipArrow.attr('points', [{\r\n            x: tr.x,\r\n            y: tl.y + offsetY\r\n          }, {\r\n            x: tr.x - GAP,\r\n            y: tl.y - GAP + offsetY\r\n          }, {\r\n            x: tr.x,\r\n            y: tl.y - GAP + offsetY\r\n          }]);\r\n        }\r\n\r\n        backShape.attr('radius', radius);\r\n      }\r\n    }\r\n\r\n    container.moveTo(posX - minX, posY - minY);\r\n  };\r\n\r\n  _proto.setMarkers = function setMarkers(cfg) {\r\n    if (cfg === void 0) {\r\n      cfg = {};\r\n    }\r\n\r\n    var self = this;\r\n    var _cfg = cfg,\r\n        items = _cfg.items,\r\n        style = _cfg.style,\r\n        type = _cfg.type;\r\n\r\n    var markerGroup = self._getMarkerGroup(type);\r\n\r\n    if (type === 'circle') {\r\n      for (var i = 0, length = items.length; i < length; i++) {\r\n        var item = items[i];\r\n        var marker = new Marker({\r\n          className: 'tooltip-circle-marker',\r\n          attrs: Util.mix({\r\n            x: item.x,\r\n            y: item.y,\r\n            stroke: item.color\r\n          }, style)\r\n        });\r\n        markerGroup.add(marker);\r\n      }\r\n    } else {\r\n      markerGroup.addShape('rect', {\r\n        className: 'tooltip-rect-marker',\r\n        attrs: style\r\n      });\r\n    }\r\n  };\r\n\r\n  _proto.clearMarkers = function clearMarkers() {\r\n    var markerGroup = this.markerGroup;\r\n    markerGroup && markerGroup.clear();\r\n  };\r\n\r\n  _proto.show = function show() {\r\n    var crosshairsShapeX = this.crosshairsShapeX;\r\n    var crosshairsShapeY = this.crosshairsShapeY;\r\n    var markerGroup = this.markerGroup;\r\n    var container = this.container;\r\n    var tooltipArrow = this.tooltipArrow;\r\n    var xTipBox = this.xTipBox;\r\n    var yTipBox = this.yTipBox;\r\n    var canvas = this.canvas;\r\n    crosshairsShapeX && crosshairsShapeX.show();\r\n    crosshairsShapeY && crosshairsShapeY.show();\r\n    markerGroup && markerGroup.show();\r\n    container && container.show();\r\n    tooltipArrow && tooltipArrow.show();\r\n    xTipBox && xTipBox.show();\r\n    yTipBox && yTipBox.show();\r\n    canvas.draw();\r\n  };\r\n\r\n  _proto.hide = function hide() {\r\n    var crosshairsShapeX = this.crosshairsShapeX;\r\n    var crosshairsShapeY = this.crosshairsShapeY;\r\n    var markerGroup = this.markerGroup;\r\n    var container = this.container;\r\n    var tooltipArrow = this.tooltipArrow;\r\n    var xTipBox = this.xTipBox;\r\n    var yTipBox = this.yTipBox;\r\n    crosshairsShapeX && crosshairsShapeX.hide();\r\n    crosshairsShapeY && crosshairsShapeY.hide();\r\n    markerGroup && markerGroup.hide();\r\n    container && container.hide();\r\n    tooltipArrow && tooltipArrow.hide();\r\n    xTipBox && xTipBox.hide();\r\n    yTipBox && yTipBox.hide();\r\n  };\r\n\r\n  _proto.destroy = function destroy() {\r\n    var crosshairsShapeX = this.crosshairsShapeX;\r\n    var crosshairsShapeY = this.crosshairsShapeY;\r\n    var markerGroup = this.markerGroup;\r\n    var container = this.container;\r\n    var tooltipArrow = this.tooltipArrow;\r\n    var xTipBox = this.xTipBox;\r\n    var yTipBox = this.yTipBox;\r\n    crosshairsShapeX && crosshairsShapeX.remove(true);\r\n    crosshairsShapeY && crosshairsShapeY.remove(true);\r\n    markerGroup && markerGroup.remove(true);\r\n    tooltipArrow && tooltipArrow.remove(true);\r\n    container && container.clear();\r\n    xTipBox && xTipBox.clear();\r\n    yTipBox && yTipBox.clear();\r\n    this.destroyed = true;\r\n  };\r\n\r\n  _proto._getMarkerGroup = function _getMarkerGroup(type) {\r\n    var markerGroup = this.markerGroup;\r\n\r\n    if (!markerGroup) {\r\n      if (type === 'circle') {\r\n        markerGroup = this.frontPlot.addGroup({\r\n          zIndex: 1\r\n        });\r\n        this.frontPlot.sort();\r\n      } else {\r\n        markerGroup = this.backPlot.addGroup();\r\n      }\r\n\r\n      this.markerGroup = markerGroup;\r\n    } else {\r\n      markerGroup.clear();\r\n    }\r\n\r\n    return markerGroup;\r\n  };\r\n\r\n  _proto._renderCrosshairs = function _renderCrosshairs() {\r\n    var crosshairsType = this.crosshairsType,\r\n        crosshairsStyle = this.crosshairsStyle,\r\n        frontPlot = this.frontPlot,\r\n        plotRange = this.plotRange;\r\n    var tl = plotRange.tl,\r\n        br = plotRange.br;\r\n\r\n    if (Util.directionEnabled(crosshairsType, 'x')) {\r\n      this.crosshairsShapeX = frontPlot.addShape('Line', {\r\n        className: 'tooltip-crosshairs-x',\r\n        zIndex: 0,\r\n        visible: false,\r\n        attrs: Util.mix({\r\n          x1: tl.x,\r\n          y1: 0,\r\n          x2: br.x,\r\n          y2: 0\r\n        }, crosshairsStyle)\r\n      });\r\n    }\r\n\r\n    if (Util.directionEnabled(crosshairsType, 'y')) {\r\n      this.crosshairsShapeY = frontPlot.addShape('Line', {\r\n        className: 'tooltip-crosshairs-y',\r\n        zIndex: 0,\r\n        visible: false,\r\n        attrs: Util.mix({\r\n          x1: 0,\r\n          y1: br.y,\r\n          x2: 0,\r\n          y2: tl.y\r\n        }, crosshairsStyle)\r\n      });\r\n    }\r\n  };\r\n\r\n  return Tooltip;\r\n}();\r\n\r\nmodule.exports = Tooltip;","\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\r\n\r\n/**\r\n * marker shapes，used for tooltip and legend\r\n */\r\nvar Util = require('../util/common');\r\n\r\nvar _require = require('../graphic/index'),\r\n    Shape = _require.Shape;\r\n\r\nvar SYMBOLS = {\r\n  circle: function circle(x, y, r, ctx) {\r\n    ctx.arc(x, y, r, 0, Math.PI * 2, false);\r\n  },\r\n  square: function square(x, y, r, ctx) {\r\n    ctx.moveTo(x - r, y - r);\r\n    ctx.lineTo(x + r, y - r);\r\n    ctx.lineTo(x + r, y + r);\r\n    ctx.lineTo(x - r, y + r);\r\n    ctx.closePath();\r\n  }\r\n};\r\n\r\nvar Marker =\r\n/*#__PURE__*/\r\nfunction (_Shape) {\r\n  (0, _inheritsLoose2[\"default\"])(Marker, _Shape);\r\n\r\n  function Marker() {\r\n    return _Shape.apply(this, arguments) || this;\r\n  }\r\n\r\n  var _proto = Marker.prototype;\r\n\r\n  _proto._initProperties = function _initProperties() {\r\n    _Shape.prototype._initProperties.call(this);\r\n\r\n    this._attrs.canFill = true;\r\n    this._attrs.canStroke = true;\r\n    this._attrs.type = 'marker';\r\n  };\r\n\r\n  _proto.getDefaultAttrs = function getDefaultAttrs() {\r\n    return {\r\n      x: 0,\r\n      y: 0,\r\n      lineWidth: 0\r\n    };\r\n  };\r\n\r\n  _proto.createPath = function createPath(context) {\r\n    var attrs = this.get('attrs');\r\n    var x = attrs.x,\r\n        y = attrs.y,\r\n        radius = attrs.radius;\r\n    var symbol = attrs.symbol || 'circle';\r\n    var method;\r\n\r\n    if (Util.isFunction(symbol)) {\r\n      method = symbol;\r\n    } else {\r\n      method = SYMBOLS[symbol];\r\n    }\r\n\r\n    context.beginPath();\r\n    method(x, y, radius, context, this);\r\n  };\r\n\r\n  _proto.calculateBox = function calculateBox() {\r\n    var attrs = this.get('attrs');\r\n    var x = attrs.x,\r\n        y = attrs.y,\r\n        radius = attrs.radius;\r\n    return {\r\n      minX: x - radius,\r\n      minY: y - radius,\r\n      maxX: x + radius,\r\n      maxY: y + radius\r\n    };\r\n  };\r\n\r\n  return Marker;\r\n}(Shape);\r\n\r\nmodule.exports = Marker;","\r\n\r\nvar Util = require('../util/common');\r\n\r\nvar _require = require('../graphic/index'),\r\n    Group = _require.Group;\r\n\r\nvar Marker = require('./marker');\r\n\r\nvar MARKER_RADIUS = 3;\r\n\r\nvar List =\r\n/*#__PURE__*/\r\nfunction () {\r\n  var _proto = List.prototype;\r\n\r\n  _proto.getDefaultCfg = function getDefaultCfg() {\r\n    return {\r\n      showTitle: false,\r\n\r\n      /**\r\n       * title string\r\n       * @type {?String}\r\n       */\r\n      title: null,\r\n\r\n      /**\r\n       * items array\r\n       * @type {?Array}\r\n       */\r\n      items: null,\r\n\r\n      /**\r\n       * offset between title and items\r\n       * @type {Number}\r\n       */\r\n      titleGap: 12,\r\n\r\n      /**\r\n       * offset between each item\r\n       * @type {Number}\r\n       */\r\n      itemGap: 10,\r\n\r\n      /**\r\n       * the offset between each item in vertical direaction\r\n       * @type {Number}\r\n       */\r\n      itemMarginBottom: 12,\r\n\r\n      /**\r\n       * the formatter for item text\r\n       * @type {[type]}\r\n       */\r\n      itemFormatter: null,\r\n      itemWidth: null,\r\n\r\n      /**\r\n       * offset between marker and text\r\n       * @type {Number}\r\n       */\r\n      wordSpace: 6,\r\n      x: 0,\r\n      y: 0,\r\n      layout: 'horizontal',\r\n\r\n      /**\r\n       * the join string of `name` and `value`\r\n       * @type {String}\r\n       */\r\n      joinString: ': '\r\n    };\r\n  };\r\n\r\n  function List(cfg) {\r\n    Util.deepMix(this, this.getDefaultCfg(), cfg);\r\n\r\n    this._init();\r\n\r\n    this._renderTitle();\r\n\r\n    this._renderItems();\r\n  }\r\n\r\n  _proto._init = function _init() {\r\n    var container = new Group({\r\n      zIndex: this.zIndex || 0\r\n    });\r\n    this.container = container;\r\n    var wrapper = container.addGroup();\r\n    this.wrapper = wrapper;\r\n    var itemsGroup = wrapper.addGroup({\r\n      className: 'itemsGroup'\r\n    });\r\n    this.itemsGroup = itemsGroup;\r\n\r\n    if (this.parent) {\r\n      this.parent.add(container);\r\n    }\r\n  };\r\n\r\n  _proto._renderTitle = function _renderTitle(title) {\r\n    title = title || this.title;\r\n    var titleShape = this.titleShape;\r\n    var titleHeight = 0;\r\n\r\n    if (this.showTitle && title) {\r\n      if (titleShape && !titleShape.get('destroyed')) {\r\n        titleShape.attr('text', title);\r\n      } else {\r\n        var wrapper = this.wrapper,\r\n            titleStyle = this.titleStyle;\r\n        titleShape = wrapper.addShape('text', {\r\n          className: 'title',\r\n          attrs: Util.mix({\r\n            x: 0,\r\n            y: 0,\r\n            text: title\r\n          }, titleStyle)\r\n        });\r\n        this.titleShape = titleShape;\r\n      }\r\n\r\n      titleHeight = titleShape.getBBox().height + this.titleGap;\r\n    }\r\n\r\n    this._titleHeight = titleHeight;\r\n  };\r\n\r\n  _proto._renderItems = function _renderItems(items) {\r\n    var self = this;\r\n    items = items || self.items;\r\n\r\n    if (!items) {\r\n      return;\r\n    }\r\n\r\n    if (self.reversed) {\r\n      items.reverse();\r\n    }\r\n\r\n    Util.each(items, function (item, index) {\r\n      self._addItem(item, index);\r\n    });\r\n\r\n    if (items.length > 1) {\r\n      this._adjustItems();\r\n    }\r\n\r\n    this._renderBackground();\r\n  };\r\n\r\n  _proto._renderBackground = function _renderBackground() {\r\n    var background = this.background;\r\n\r\n    if (background) {\r\n      var container = this.container;\r\n      var wrapper = this.wrapper;\r\n\r\n      var _wrapper$getBBox = wrapper.getBBox(),\r\n          minX = _wrapper$getBBox.minX,\r\n          minY = _wrapper$getBBox.minY,\r\n          width = _wrapper$getBBox.width,\r\n          height = _wrapper$getBBox.height;\r\n\r\n      var padding = background.padding || [0, 0, 0, 0];\r\n      padding = Util.parsePadding(padding);\r\n      var attrs = Util.mix({\r\n        x: minX - padding[3],\r\n        y: minY - padding[0],\r\n        width: width + padding[1] + padding[3],\r\n        height: height + padding[0] + padding[2]\r\n      }, background);\r\n      var backShape = this.backShape;\r\n\r\n      if (backShape) {\r\n        backShape.attr(attrs);\r\n      } else {\r\n        backShape = container.addShape('Rect', {\r\n          zIndex: -1,\r\n          attrs: attrs\r\n        });\r\n      }\r\n\r\n      this.backShape = backShape;\r\n      container.sort();\r\n    }\r\n  };\r\n\r\n  _proto._addItem = function _addItem(item) {\r\n    var itemsGroup = this.itemsGroup;\r\n    var itemGroup = itemsGroup.addGroup({\r\n      name: item.name,\r\n      value: item.value,\r\n      dataValue: item.dataValue,\r\n      checked: item.checked\r\n    });\r\n    var unCheckStyle = this.unCheckStyle,\r\n        unCheckColor = this.unCheckColor,\r\n        nameStyle = this.nameStyle,\r\n        valueStyle = this.valueStyle,\r\n        wordSpace = this.wordSpace;\r\n    var marker = item.marker,\r\n        value = item.value;\r\n    var startX = 0;\r\n\r\n    if (unCheckColor) {\r\n      unCheckStyle.fill = unCheckColor;\r\n    }\r\n\r\n    if (marker) {\r\n      var radius = marker.radius || MARKER_RADIUS;\r\n      var markerAttrs = Util.mix({\r\n        x: radius,\r\n        y: this._titleHeight\r\n      }, marker);\r\n\r\n      if (item.checked === false) {\r\n        Util.mix(markerAttrs, unCheckStyle);\r\n      }\r\n\r\n      var markerShape = new Marker({\r\n        className: 'item-marker',\r\n        attrs: markerAttrs\r\n      });\r\n      itemGroup.add(markerShape);\r\n      startX += markerShape.getBBox().width + wordSpace;\r\n    }\r\n\r\n    var nameText;\r\n    var name = item.name;\r\n\r\n    if (name) {\r\n      var joinString = this.joinString || '';\r\n      name = value ? name + joinString : name;\r\n      nameText = itemGroup.addShape('text', {\r\n        className: 'name',\r\n        attrs: Util.mix({\r\n          x: startX,\r\n          y: this._titleHeight,\r\n          text: this._formatItemValue(name)\r\n        }, nameStyle, item.checked === false ? unCheckStyle : null)\r\n      });\r\n    }\r\n\r\n    if (value) {\r\n      var valueX = startX;\r\n\r\n      if (nameText) {\r\n        valueX += nameText.getBBox().width;\r\n      }\r\n\r\n      itemGroup.addShape('text', {\r\n        className: 'value',\r\n        attrs: Util.mix({\r\n          x: valueX,\r\n          y: this._titleHeight,\r\n          text: value\r\n        }, valueStyle, item.checked === false ? unCheckStyle : null)\r\n      });\r\n    }\r\n\r\n    return itemGroup;\r\n  };\r\n\r\n  _proto._formatItemValue = function _formatItemValue(value) {\r\n    var formatter = this.itemFormatter;\r\n\r\n    if (formatter) {\r\n      value = formatter.call(this, value);\r\n    }\r\n\r\n    return value;\r\n  };\r\n\r\n  _proto._getMaxItemWidth = function _getMaxItemWidth() {\r\n    var width;\r\n    var itemWidth = this.itemWidth;\r\n\r\n    if (Util.isNumber(itemWidth) || Util.isNil(itemWidth)) {\r\n      return itemWidth;\r\n    }\r\n\r\n    if (itemWidth === 'auto') {\r\n      var itemsGroup = this.itemsGroup;\r\n      var children = itemsGroup.get('children');\r\n      var count = children.length;\r\n      var maxItemWidth = 0;\r\n\r\n      for (var i = 0; i < count; i++) {\r\n        var _children$i$getBBox = children[i].getBBox(),\r\n            _width = _children$i$getBBox.width;\r\n\r\n        maxItemWidth = Math.max(maxItemWidth, _width);\r\n      }\r\n\r\n      var maxLength = this.maxLength;\r\n      var itemGap = this.itemGap;\r\n      var twoAvgWidth = (maxLength - itemGap) / 2;\r\n      var threeAvgWidth = (maxLength - itemGap * 2) / 3;\r\n\r\n      if (count === 2) {\r\n        width = Math.max(maxItemWidth, twoAvgWidth);\r\n      } else {\r\n        // 1. max <= 3Avg, 3Avg\r\n        // 2. 3Avg < max && max < 2avg, 2avg\r\n        // 3. max > 2avg, max, one column\r\n        if (maxItemWidth <= threeAvgWidth) {\r\n          width = threeAvgWidth;\r\n        } else if (maxItemWidth <= twoAvgWidth) {\r\n          width = twoAvgWidth;\r\n        } else {\r\n          width = maxItemWidth;\r\n        }\r\n      }\r\n\r\n      return width;\r\n    }\r\n  };\r\n\r\n  _proto._adjustHorizontal = function _adjustHorizontal() {\r\n    var maxLength = this.maxLength,\r\n        itemsGroup = this.itemsGroup;\r\n    var children = itemsGroup.get('children');\r\n    var itemGap = this.itemGap,\r\n        itemMarginBottom = this.itemMarginBottom;\r\n    var titleHeight = this._titleHeight;\r\n    var row = 0;\r\n    var rowWidth = 0;\r\n    var width;\r\n    var height;\r\n\r\n    var itemWidth = this._getMaxItemWidth();\r\n\r\n    var legendHitBoxes = [];\r\n\r\n    for (var i = 0, len = children.length; i < len; i++) {\r\n      var child = children[i];\r\n      var box = child.getBBox();\r\n      var childHeight = box.height;\r\n      var childWidth = box.width;\r\n      width = itemWidth || childWidth;\r\n      height = childHeight + itemMarginBottom;\r\n\r\n      if (width - (maxLength - rowWidth) > 0.0001) {\r\n        row++;\r\n        rowWidth = 0;\r\n      }\r\n\r\n      child.moveTo(rowWidth, row * height);\r\n      legendHitBoxes.push({\r\n        x: rowWidth,\r\n        y: row * height + titleHeight - childHeight / 2,\r\n        width: childWidth * 1.375,\r\n        height: childHeight * 1.375\r\n      });\r\n      rowWidth += width + itemGap;\r\n    }\r\n\r\n    this.legendHitBoxes = legendHitBoxes;\r\n    return;\r\n  };\r\n\r\n  _proto._adjustVertical = function _adjustVertical() {\r\n    var maxLength = this.maxLength,\r\n        itemsGroup = this.itemsGroup;\r\n    var itemGap = this.itemGap,\r\n        itemMarginBottom = this.itemMarginBottom,\r\n        itemWidth = this.itemWidth;\r\n    var titleHeight = this._titleHeight;\r\n    var children = itemsGroup.get('children');\r\n    var colHeight = 0;\r\n    var width;\r\n    var height;\r\n    var maxItemWidth = 0;\r\n    var totalWidth = 0;\r\n    var legendHitBoxes = [];\r\n\r\n    for (var i = 0, length = children.length; i < length; i++) {\r\n      var child = children[i];\r\n      var bbox = child.getBBox();\r\n      width = bbox.width;\r\n      height = bbox.height;\r\n\r\n      if (Util.isNumber(itemWidth)) {\r\n        maxItemWidth = itemWidth + itemGap;\r\n      } else if (width > maxItemWidth) {\r\n        maxItemWidth = width + itemGap;\r\n      }\r\n\r\n      if (maxLength - colHeight < height) {\r\n        colHeight = 0;\r\n        totalWidth += maxItemWidth;\r\n        child.moveTo(totalWidth, 0);\r\n        legendHitBoxes.push({\r\n          x: totalWidth,\r\n          y: titleHeight - height / 2,\r\n          width: width * 1.375,\r\n          height: height * 1.375\r\n        });\r\n      } else {\r\n        child.moveTo(totalWidth, colHeight);\r\n        legendHitBoxes.push({\r\n          x: totalWidth,\r\n          y: colHeight - height / 2 + titleHeight,\r\n          width: width * 1.375,\r\n          height: height * 1.375\r\n        });\r\n      }\r\n\r\n      colHeight += height + itemMarginBottom;\r\n    }\r\n\r\n    this.legendHitBoxes = legendHitBoxes;\r\n    return;\r\n  };\r\n\r\n  _proto._adjustItems = function _adjustItems() {\r\n    var layout = this.layout;\r\n\r\n    if (layout === 'horizontal') {\r\n      this._adjustHorizontal();\r\n    } else {\r\n      this._adjustVertical();\r\n    }\r\n  };\r\n\r\n  _proto.moveTo = function moveTo(x, y) {\r\n    this.x = x;\r\n    this.y = y;\r\n    var container = this.container;\r\n    container && container.moveTo(x, y);\r\n    return this;\r\n  };\r\n\r\n  _proto.setItems = function setItems(items) {\r\n    this.clearItems();\r\n\r\n    this._renderItems(items);\r\n  };\r\n\r\n  _proto.setTitle = function setTitle(title) {\r\n    this._renderTitle(title);\r\n  };\r\n\r\n  _proto.clearItems = function clearItems() {\r\n    var itemsGroup = this.itemsGroup;\r\n    itemsGroup.clear();\r\n  };\r\n\r\n  _proto.getWidth = function getWidth() {\r\n    var container = this.container;\r\n    var bbox = container.getBBox();\r\n    return bbox.width;\r\n  };\r\n\r\n  _proto.getHeight = function getHeight() {\r\n    var container = this.container;\r\n    var bbox = container.getBBox();\r\n    return bbox.height;\r\n  };\r\n\r\n  _proto.show = function show() {\r\n    var container = this.container;\r\n    container.show();\r\n  };\r\n\r\n  _proto.hide = function hide() {\r\n    var container = this.container;\r\n    container.hide();\r\n  };\r\n\r\n  _proto.clear = function clear() {\r\n    var container = this.container;\r\n    container.clear();\r\n    container.remove(true);\r\n  };\r\n\r\n  return List;\r\n}();\r\n\r\nmodule.exports = List;","\r\n\r\nvar Util = require('../util/common');\r\n\r\nvar _require = require('../graphic/index'),\r\n    Group = _require.Group;\r\n\r\nvar TextBox =\r\n/*#__PURE__*/\r\nfunction () {\r\n  var _proto = TextBox.prototype;\r\n\r\n  _proto.getDefaultCfg = function getDefaultCfg() {\r\n    return {\r\n      x: 0,\r\n      y: 0,\r\n      content: '',\r\n      textStyle: {\r\n        fontSize: 12,\r\n        fill: '#fff',\r\n        textAlign: 'center',\r\n        textBaseline: 'middle'\r\n      },\r\n      background: {\r\n        radius: 1,\r\n        fill: 'rgba(0, 0, 0, 0.65)',\r\n        padding: [3, 5]\r\n      },\r\n      width: 0,\r\n      height: 0,\r\n      className: ''\r\n    };\r\n  };\r\n\r\n  function TextBox(cfg) {\r\n    Util.deepMix(this, this.getDefaultCfg(), cfg);\r\n\r\n    this._init();\r\n\r\n    var content = this.content,\r\n        x = this.x,\r\n        y = this.y;\r\n\r\n    if (!Util.isNil(content)) {\r\n      this.updateContent(content);\r\n    }\r\n\r\n    this.updatePosition(x, y);\r\n  }\r\n\r\n  _proto._init = function _init() {\r\n    var content = this.content,\r\n        textStyle = this.textStyle,\r\n        background = this.background,\r\n        className = this.className,\r\n        visible = this.visible;\r\n    var container = new Group({\r\n      className: className,\r\n      zIndex: 0,\r\n      visible: visible\r\n    });\r\n    var text = container.addShape('Text', {\r\n      className: className + '-text',\r\n      zIndex: 1,\r\n      attrs: Util.mix({\r\n        text: content,\r\n        x: 0,\r\n        y: 0\r\n      }, textStyle)\r\n    });\r\n    var backgroundShape = container.addShape('Rect', {\r\n      className: className + '-bg',\r\n      zIndex: -1,\r\n      attrs: Util.mix({\r\n        x: 0,\r\n        y: 0,\r\n        width: 0,\r\n        height: 0\r\n      }, background)\r\n    });\r\n    container.sort();\r\n    this.container = container;\r\n    this.textShape = text;\r\n    this.backgroundShape = backgroundShape;\r\n  };\r\n\r\n  _proto._getBBox = function _getBBox() {\r\n    var textShape = this.textShape;\r\n    var background = this.background;\r\n    var textBBox = textShape.getBBox();\r\n    var padding = Util.parsePadding(background.padding);\r\n    var width = textBBox.width + padding[1] + padding[3];\r\n    var height = textBBox.height + padding[0] + padding[2];\r\n    var x = textBBox.minX - padding[3];\r\n    var y = textBBox.minY - padding[0];\r\n    return {\r\n      x: x,\r\n      y: y,\r\n      width: width,\r\n      height: height\r\n    };\r\n  };\r\n\r\n  _proto.updateContent = function updateContent(text) {\r\n    var textShape = this.textShape,\r\n        backgroundShape = this.backgroundShape;\r\n\r\n    if (!Util.isNil(text)) {\r\n      if (!Util.isObject(text)) {\r\n        text = {\r\n          text: text\r\n        };\r\n      }\r\n\r\n      textShape.attr(text); // update box shape\r\n\r\n      var _this$_getBBox = this._getBBox(),\r\n          x = _this$_getBBox.x,\r\n          y = _this$_getBBox.y,\r\n          tipWidth = _this$_getBBox.width,\r\n          tipHeight = _this$_getBBox.height;\r\n\r\n      var width = this.width || tipWidth;\r\n      var height = this.height || tipHeight;\r\n      backgroundShape.attr({\r\n        x: x,\r\n        y: y,\r\n        width: width,\r\n        height: height\r\n      });\r\n      this._width = width;\r\n      this._height = height;\r\n      this.content = text.text;\r\n    }\r\n  };\r\n\r\n  _proto.updatePosition = function updatePosition(x, y) {\r\n    var container = this.container;\r\n\r\n    var _this$_getBBox2 = this._getBBox(),\r\n        xMin = _this$_getBBox2.x,\r\n        yMin = _this$_getBBox2.y;\r\n\r\n    container.moveTo(x - xMin, y - yMin);\r\n    this.x = x - xMin;\r\n    this.y = y - yMin;\r\n  };\r\n\r\n  _proto.getWidth = function getWidth() {\r\n    return this._width;\r\n  };\r\n\r\n  _proto.getHeight = function getHeight() {\r\n    return this._height;\r\n  };\r\n\r\n  _proto.show = function show() {\r\n    this.container.show();\r\n  };\r\n\r\n  _proto.hide = function hide() {\r\n    this.container.hide();\r\n  };\r\n\r\n  _proto.clear = function clear() {\r\n    var container = this.container;\r\n    container.clear();\r\n    container.remove(true);\r\n    this.container = null;\r\n    this.textShape = null;\r\n    this.backgroundShape = null;\r\n  };\r\n\r\n  return TextBox;\r\n}();\r\n\r\nmodule.exports = TextBox;","\r\n\r\nvar Util = require('../util/common');\r\n\r\nvar Guide = require('../component/guide/base');\r\n\r\nvar Global = require('../global'); // register the default configuration for Guide\r\n\r\n\r\nGlobal.guide = Util.deepMix({\r\n  line: {\r\n    style: {\r\n      stroke: '#a3a3a3',\r\n      lineWidth: 1\r\n    },\r\n    top: true\r\n  },\r\n  text: {\r\n    style: {\r\n      fill: '#787878',\r\n      textAlign: 'center',\r\n      textBaseline: 'middle'\r\n    },\r\n    offsetX: 0,\r\n    offsetY: 0,\r\n    top: true\r\n  },\r\n  rect: {\r\n    style: {\r\n      fill: '#fafafa'\r\n    },\r\n    top: false\r\n  },\r\n  arc: {\r\n    style: {\r\n      stroke: '#a3a3a3'\r\n    },\r\n    top: true\r\n  },\r\n  html: {\r\n    offsetX: 0,\r\n    offsetY: 0,\r\n    alignX: 'center',\r\n    alignY: 'middle'\r\n  },\r\n  tag: {\r\n    top: true,\r\n    offsetX: 0,\r\n    offsetY: 0,\r\n    side: 4,\r\n    background: {\r\n      padding: 5,\r\n      radius: 2,\r\n      fill: '#1890FF'\r\n    },\r\n    textStyle: {\r\n      fontSize: 12,\r\n      fill: '#fff',\r\n      textAlign: 'center',\r\n      textBaseline: 'middle'\r\n    }\r\n  },\r\n  point: {\r\n    top: true,\r\n    offsetX: 0,\r\n    offsetY: 0,\r\n    style: {\r\n      fill: '#fff',\r\n      r: 3,\r\n      lineWidth: 2,\r\n      stroke: '#1890ff'\r\n    }\r\n  }\r\n}, Global.guide || {});\r\n\r\nvar GuideController =\r\n/*#__PURE__*/\r\nfunction () {\r\n  function GuideController(cfg) {\r\n    this.guides = [];\r\n    this.xScale = null;\r\n    this.yScales = null;\r\n    this.guideShapes = [];\r\n    Util.mix(this, cfg);\r\n  }\r\n\r\n  var _proto = GuideController.prototype;\r\n\r\n  _proto._toString = function _toString(position) {\r\n    if (Util.isFunction(position)) {\r\n      position = position(this.xScale, this.yScales);\r\n    }\r\n\r\n    position = position.toString();\r\n    return position;\r\n  };\r\n\r\n  _proto._getId = function _getId(shape, guide) {\r\n    var id = guide.id;\r\n\r\n    if (!id) {\r\n      var type = guide.type;\r\n\r\n      if (type === 'arc' || type === 'line' || type === 'rect') {\r\n        id = this._toString(guide.start) + '-' + this._toString(guide.end);\r\n      } else {\r\n        id = this._toString(guide.position);\r\n      }\r\n    }\r\n\r\n    return id;\r\n  };\r\n\r\n  _proto.paint = function paint(coord) {\r\n    var self = this;\r\n    var chart = self.chart,\r\n        guides = self.guides,\r\n        xScale = self.xScale,\r\n        yScales = self.yScales;\r\n    var guideShapes = [];\r\n    Util.each(guides, function (guide, idx) {\r\n      guide.xScale = xScale;\r\n      guide.yScales = yScales;\r\n      var container;\r\n\r\n      if (guide.type === 'regionFilter') {\r\n        // TODO: RegionFilter support animation\r\n        guide.chart = chart;\r\n      } else {\r\n        container = guide.top ? self.frontPlot : self.backPlot;\r\n      }\r\n\r\n      guide.coord = coord;\r\n      guide.container = container;\r\n      guide.canvas = chart.get('canvas');\r\n      var shape = guide.render(coord, container);\r\n\r\n      if (shape) {\r\n        var id = self._getId(shape, guide);\r\n\r\n        [].concat(shape).forEach(function (s) {\r\n          s._id = s.get('className') + '-' + id;\r\n          s.set('index', idx);\r\n          guideShapes.push(s);\r\n        });\r\n      }\r\n    });\r\n    self.guideShapes = guideShapes;\r\n  };\r\n\r\n  _proto.clear = function clear() {\r\n    this.reset();\r\n    this.guides = [];\r\n    return this;\r\n  };\r\n\r\n  _proto.reset = function reset() {\r\n    var guides = this.guides;\r\n    Util.each(guides, function (guide) {\r\n      guide.remove();\r\n    });\r\n  };\r\n\r\n  _proto._createGuide = function _createGuide(type, cfg) {\r\n    var ClassName = Util.upperFirst(type);\r\n    var guide = new Guide[ClassName](Util.deepMix({}, Global.guide[type], cfg));\r\n    this.guides.push(guide);\r\n    return guide;\r\n  };\r\n\r\n  _proto.line = function line(cfg) {\r\n    if (cfg === void 0) {\r\n      cfg = {};\r\n    }\r\n\r\n    return this._createGuide('line', cfg);\r\n  };\r\n\r\n  _proto.text = function text(cfg) {\r\n    if (cfg === void 0) {\r\n      cfg = {};\r\n    }\r\n\r\n    return this._createGuide('text', cfg);\r\n  };\r\n\r\n  _proto.arc = function arc(cfg) {\r\n    if (cfg === void 0) {\r\n      cfg = {};\r\n    }\r\n\r\n    return this._createGuide('arc', cfg);\r\n  };\r\n\r\n  _proto.html = function html(cfg) {\r\n    if (cfg === void 0) {\r\n      cfg = {};\r\n    }\r\n\r\n    return this._createGuide('html', cfg);\r\n  };\r\n\r\n  _proto.rect = function rect(cfg) {\r\n    if (cfg === void 0) {\r\n      cfg = {};\r\n    }\r\n\r\n    return this._createGuide('rect', cfg);\r\n  };\r\n\r\n  _proto.tag = function tag(cfg) {\r\n    if (cfg === void 0) {\r\n      cfg = {};\r\n    }\r\n\r\n    return this._createGuide('tag', cfg);\r\n  };\r\n\r\n  _proto.point = function point(cfg) {\r\n    if (cfg === void 0) {\r\n      cfg = {};\r\n    }\r\n\r\n    return this._createGuide('point', cfg);\r\n  };\r\n\r\n  _proto.regionFilter = function regionFilter(cfg) {\r\n    if (cfg === void 0) {\r\n      cfg = {};\r\n    }\r\n\r\n    return this._createGuide('regionFilter', cfg);\r\n  };\r\n\r\n  return GuideController;\r\n}();\r\n\r\nmodule.exports = {\r\n  init: function init(chart) {\r\n    var guideController = new GuideController({\r\n      frontPlot: chart.get('frontPlot').addGroup({\r\n        zIndex: 20,\r\n        className: 'guideContainer'\r\n      }),\r\n      backPlot: chart.get('backPlot').addGroup({\r\n        className: 'guideContainer'\r\n      })\r\n    });\r\n    chart.set('guideController', guideController);\r\n    /**\r\n     * 为图表添加 guide\r\n     * @return {GuideController} 返回 guide 控制器\r\n     */\r\n\r\n    chart.guide = function () {\r\n      return guideController;\r\n    };\r\n  },\r\n  afterGeomDraw: function afterGeomDraw(chart) {\r\n    var guideController = chart.get('guideController');\r\n\r\n    if (!guideController.guides.length) {\r\n      return;\r\n    }\r\n\r\n    var xScale = chart.getXScale();\r\n    var yScales = chart.getYScales();\r\n    var coord = chart.get('coord');\r\n    guideController.xScale = xScale;\r\n    guideController.yScales = yScales;\r\n    guideController.chart = chart; // for regionFilter\r\n\r\n    guideController.paint(coord);\r\n  },\r\n  clear: function clear(chart) {\r\n    chart.get('guideController').clear();\r\n  },\r\n  repaint: function repaint(chart) {\r\n    chart.get('guideController').reset();\r\n  }\r\n};","\r\n\r\nvar Util = require('../util/common');\r\n\r\nvar List = require('../component/list');\r\n\r\nvar Global = require('../global');\r\n\r\nvar LEGEND_GAP = 12;\r\nvar MARKER_SIZE = 3;\r\nvar DEFAULT_CFG = {\r\n  itemMarginBottom: 12,\r\n  itemGap: 10,\r\n  showTitle: false,\r\n  titleStyle: {\r\n    fontSize: 12,\r\n    fill: '#808080',\r\n    textAlign: 'start',\r\n    textBaseline: 'top'\r\n  },\r\n  nameStyle: {\r\n    fill: '#808080',\r\n    fontSize: 12,\r\n    textAlign: 'start',\r\n    textBaseline: 'middle'\r\n  },\r\n  valueStyle: {\r\n    fill: '#000000',\r\n    fontSize: 12,\r\n    textAlign: 'start',\r\n    textBaseline: 'middle'\r\n  },\r\n  unCheckStyle: {\r\n    fill: '#bfbfbf'\r\n  },\r\n  itemWidth: 'auto',\r\n  wordSpace: 6,\r\n  selectedMode: 'multiple' // 'multiple' or 'single'\r\n\r\n}; // Register the default configuration for Legend\r\n\r\nGlobal.legend = Util.deepMix({\r\n  common: DEFAULT_CFG,\r\n  // common legend configuration\r\n  right: Util.mix({\r\n    position: 'right',\r\n    layout: 'vertical'\r\n  }, DEFAULT_CFG),\r\n  left: Util.mix({\r\n    position: 'left',\r\n    layout: 'vertical'\r\n  }, DEFAULT_CFG),\r\n  top: Util.mix({\r\n    position: 'top',\r\n    layout: 'horizontal'\r\n  }, DEFAULT_CFG),\r\n  bottom: Util.mix({\r\n    position: 'bottom',\r\n    layout: 'horizontal'\r\n  }, DEFAULT_CFG)\r\n}, Global.legend || {});\r\n\r\nfunction getPaddingByPos(pos, appendPadding) {\r\n  var padding = 0;\r\n  appendPadding = Util.parsePadding(appendPadding);\r\n\r\n  switch (pos) {\r\n    case 'top':\r\n      padding = appendPadding[0];\r\n      break;\r\n\r\n    case 'right':\r\n      padding = appendPadding[1];\r\n      break;\r\n\r\n    case 'bottom':\r\n      padding = appendPadding[2];\r\n      break;\r\n\r\n    case 'left':\r\n      padding = appendPadding[3];\r\n      break;\r\n\r\n    default:\r\n      break;\r\n  }\r\n\r\n  return padding;\r\n}\r\n\r\nvar LegendController =\r\n/*#__PURE__*/\r\nfunction () {\r\n  function LegendController(cfg) {\r\n    this.legendCfg = {};\r\n    this.enable = true;\r\n    this.position = 'top';\r\n    Util.mix(this, cfg);\r\n    var chart = this.chart;\r\n    this.canvasDom = chart.get('canvas').get('el');\r\n    this.clear();\r\n  }\r\n\r\n  var _proto = LegendController.prototype;\r\n\r\n  _proto.addLegend = function addLegend(scale, items, filteredVals) {\r\n    var self = this;\r\n    var legendCfg = self.legendCfg;\r\n    var field = scale.field;\r\n    var fieldCfg = legendCfg[field];\r\n\r\n    if (fieldCfg === false) {\r\n      return null;\r\n    }\r\n\r\n    if (fieldCfg && fieldCfg.custom) {\r\n      self.addCustomLegend(field);\r\n    } else {\r\n      var position = legendCfg.position || self.position;\r\n\r\n      if (fieldCfg && fieldCfg.position) {\r\n        position = fieldCfg.position;\r\n      }\r\n\r\n      if (scale.isCategory) {\r\n        self._addCategoryLegend(scale, items, position, filteredVals);\r\n      }\r\n    }\r\n  };\r\n\r\n  _proto.addCustomLegend = function addCustomLegend(field) {\r\n    var self = this;\r\n    var legendCfg = self.legendCfg;\r\n\r\n    if (field && legendCfg[field]) {\r\n      legendCfg = legendCfg[field];\r\n    }\r\n\r\n    var position = legendCfg.position || self.position;\r\n    var legends = self.legends;\r\n    legends[position] = legends[position] || [];\r\n    var items = legendCfg.items;\r\n\r\n    if (!items) {\r\n      return null;\r\n    }\r\n\r\n    var container = self.container;\r\n    Util.each(items, function (item) {\r\n      if (!Util.isPlainObject(item.marker)) {\r\n        item.marker = {\r\n          symbol: item.marker || 'circle',\r\n          fill: item.fill,\r\n          radius: MARKER_SIZE\r\n        };\r\n      } else {\r\n        item.marker.radius = item.marker.radius || MARKER_SIZE;\r\n      }\r\n\r\n      item.checked = Util.isNil(item.checked) ? true : item.checked;\r\n      item.name = item.name || item.value;\r\n    });\r\n    var legend = new List(Util.deepMix({}, Global.legend[position], legendCfg, {\r\n      maxLength: self._getMaxLength(position),\r\n      items: items,\r\n      parent: container\r\n    }));\r\n    legends[position].push(legend);\r\n  };\r\n\r\n  _proto.clear = function clear() {\r\n    var legends = this.legends;\r\n    Util.each(legends, function (legendItems) {\r\n      Util.each(legendItems, function (legend) {\r\n        legend.clear();\r\n      });\r\n    });\r\n    this.legends = {};\r\n    this.unBindEvents();\r\n  };\r\n\r\n  _proto._isFiltered = function _isFiltered(scale, values, value) {\r\n    var rst = false;\r\n    Util.each(values, function (val) {\r\n      rst = rst || scale.getText(val) === scale.getText(value);\r\n\r\n      if (rst) {\r\n        return false;\r\n      }\r\n    });\r\n    return rst;\r\n  };\r\n\r\n  _proto._getMaxLength = function _getMaxLength(position) {\r\n    var chart = this.chart;\r\n    var appendPadding = Util.parsePadding(chart.get('appendPadding'));\r\n    return position === 'right' || position === 'left' ? chart.get('height') - (appendPadding[0] + appendPadding[2]) : chart.get('width') - (appendPadding[1] + appendPadding[3]);\r\n  };\r\n\r\n  _proto._addCategoryLegend = function _addCategoryLegend(scale, items, position, filteredVals) {\r\n    var self = this;\r\n    var legendCfg = self.legendCfg,\r\n        legends = self.legends,\r\n        container = self.container,\r\n        chart = self.chart;\r\n    var field = scale.field;\r\n    legends[position] = legends[position] || [];\r\n    var symbol = 'circle';\r\n\r\n    if (legendCfg[field] && legendCfg[field].marker) {\r\n      symbol = legendCfg[field].marker;\r\n    } else if (legendCfg.marker) {\r\n      symbol = legendCfg.marker;\r\n    }\r\n\r\n    Util.each(items, function (item) {\r\n      if (Util.isPlainObject(symbol)) {\r\n        Util.mix(item.marker, symbol);\r\n      } else {\r\n        item.marker.symbol = symbol;\r\n      }\r\n\r\n      if (filteredVals) {\r\n        item.checked = !self._isFiltered(scale, filteredVals, item.dataValue);\r\n      }\r\n    });\r\n    var legendItems = chart.get('legendItems');\r\n    legendItems[field] = items;\r\n    var lastCfg = Util.deepMix({}, Global.legend[position], legendCfg[field] || legendCfg, {\r\n      maxLength: self._getMaxLength(position),\r\n      items: items,\r\n      field: field,\r\n      filteredVals: filteredVals,\r\n      parent: container\r\n    });\r\n\r\n    if (lastCfg.showTitle) {\r\n      Util.deepMix(lastCfg, {\r\n        title: scale.alias || scale.field\r\n      });\r\n    }\r\n\r\n    var legend = new List(lastCfg);\r\n    legends[position].push(legend);\r\n    return legend;\r\n  };\r\n\r\n  _proto._alignLegend = function _alignLegend(legend, pre, position) {\r\n    var self = this;\r\n    var _self$plotRange = self.plotRange,\r\n        tl = _self$plotRange.tl,\r\n        bl = _self$plotRange.bl;\r\n    var chart = self.chart;\r\n    var offsetX = legend.offsetX || 0;\r\n    var offsetY = legend.offsetY || 0;\r\n    var chartWidth = chart.get('width');\r\n    var chartHeight = chart.get('height');\r\n    var appendPadding = Util.parsePadding(chart.get('appendPadding'));\r\n    var legendHeight = legend.getHeight();\r\n    var legendWidth = legend.getWidth();\r\n    var x = 0;\r\n    var y = 0;\r\n\r\n    if (position === 'left' || position === 'right') {\r\n      var verticalAlign = legend.verticalAlign || 'middle';\r\n      var height = Math.abs(tl.y - bl.y);\r\n      x = position === 'left' ? appendPadding[3] : chartWidth - legendWidth - appendPadding[1];\r\n      y = (height - legendHeight) / 2 + tl.y;\r\n\r\n      if (verticalAlign === 'top') {\r\n        y = tl.y;\r\n      } else if (verticalAlign === 'bottom') {\r\n        y = bl.y - legendHeight;\r\n      }\r\n\r\n      if (pre) {\r\n        y = pre.get('y') - legendHeight - LEGEND_GAP;\r\n      }\r\n    } else {\r\n      var align = legend.align || 'left';\r\n      x = appendPadding[3];\r\n\r\n      if (align === 'center') {\r\n        x = chartWidth / 2 - legendWidth / 2;\r\n      } else if (align === 'right') {\r\n        x = chartWidth - (legendWidth + appendPadding[1]);\r\n      }\r\n\r\n      y = position === 'top' ? appendPadding[0] + Math.abs(legend.container.getBBox().minY) : chartHeight - legendHeight;\r\n\r\n      if (pre) {\r\n        var preWidth = pre.getWidth();\r\n        x = pre.x + preWidth + LEGEND_GAP;\r\n      }\r\n    }\r\n\r\n    if (position === 'bottom' && offsetY > 0) {\r\n      offsetY = 0;\r\n    }\r\n\r\n    if (position === 'right' && offsetX > 0) {\r\n      offsetX = 0;\r\n    }\r\n\r\n    legend.moveTo(x + offsetX, y + offsetY);\r\n  };\r\n\r\n  _proto.alignLegends = function alignLegends() {\r\n    var self = this;\r\n    var legends = self.legends;\r\n    Util.each(legends, function (legendItems, position) {\r\n      Util.each(legendItems, function (legend, index) {\r\n        var pre = legendItems[index - 1];\r\n\r\n        self._alignLegend(legend, pre, position);\r\n      });\r\n    });\r\n    return self;\r\n  };\r\n\r\n  _proto.handleEvent = function handleEvent(ev) {\r\n    var self = this;\r\n\r\n    function findItem(x, y) {\r\n      var result = null;\r\n      var legends = self.legends;\r\n      Util.each(legends, function (legendItems) {\r\n        Util.each(legendItems, function (legend) {\r\n          var itemsGroup = legend.itemsGroup,\r\n              legendHitBoxes = legend.legendHitBoxes;\r\n          var children = itemsGroup.get('children');\r\n\r\n          if (children.length) {\r\n            var legendPosX = legend.x;\r\n            var legendPosY = legend.y;\r\n            Util.each(legendHitBoxes, function (box, index) {\r\n              if (x >= box.x + legendPosX && x <= box.x + box.width + legendPosX && y >= box.y + legendPosY && y <= box.height + box.y + legendPosY) {\r\n                // inbox\r\n                result = {\r\n                  clickedItem: children[index],\r\n                  clickedLegend: legend\r\n                };\r\n                return false;\r\n              }\r\n            });\r\n          }\r\n        });\r\n      });\r\n      return result;\r\n    }\r\n\r\n    var chart = self.chart;\r\n\r\n    var _Util$createEvent = Util.createEvent(ev, chart),\r\n        x = _Util$createEvent.x,\r\n        y = _Util$createEvent.y;\r\n\r\n    var clicked = findItem(x, y);\r\n\r\n    if (clicked && clicked.clickedLegend.clickable !== false) {\r\n      var clickedItem = clicked.clickedItem,\r\n          clickedLegend = clicked.clickedLegend;\r\n\r\n      if (clickedLegend.onClick) {\r\n        ev.clickedItem = clickedItem;\r\n        clickedLegend.onClick(ev);\r\n      } else if (!clickedLegend.custom) {\r\n        var checked = clickedItem.get('checked');\r\n        var value = clickedItem.get('dataValue');\r\n        var filteredVals = clickedLegend.filteredVals,\r\n            field = clickedLegend.field,\r\n            selectedMode = clickedLegend.selectedMode;\r\n        var isSingeSelected = selectedMode === 'single';\r\n\r\n        if (isSingeSelected) {\r\n          chart.filter(field, function (val) {\r\n            return val === value;\r\n          });\r\n        } else {\r\n          if (checked) {\r\n            filteredVals.push(value);\r\n          } else {\r\n            Util.Array.remove(filteredVals, value);\r\n          }\r\n\r\n          chart.filter(field, function (val) {\r\n            return filteredVals.indexOf(val) === -1;\r\n          });\r\n        }\r\n\r\n        chart.repaint();\r\n      }\r\n    }\r\n  };\r\n\r\n  _proto.bindEvents = function bindEvents() {\r\n    var legendCfg = this.legendCfg;\r\n    var triggerOn = legendCfg.triggerOn || 'touchstart';\r\n    var method = Util.wrapBehavior(this, 'handleEvent');\r\n    Util.addEventListener(this.canvasDom, triggerOn, method);\r\n  };\r\n\r\n  _proto.unBindEvents = function unBindEvents() {\r\n    var legendCfg = this.legendCfg;\r\n    var triggerOn = legendCfg.triggerOn || 'touchstart';\r\n    var method = Util.getWrapBehavior(this, 'handleEvent');\r\n    Util.removeEventListener(this.canvasDom, triggerOn, method);\r\n  };\r\n\r\n  return LegendController;\r\n}();\r\n\r\nmodule.exports = {\r\n  init: function init(chart) {\r\n    var legendController = new LegendController({\r\n      container: chart.get('backPlot'),\r\n      plotRange: chart.get('plotRange'),\r\n      chart: chart\r\n    });\r\n    chart.set('legendController', legendController);\r\n\r\n    chart.legend = function (field, cfg) {\r\n      var legendCfg = legendController.legendCfg;\r\n      legendController.enable = true;\r\n\r\n      if (Util.isBoolean(field)) {\r\n        legendController.enable = field;\r\n        legendCfg = cfg || {};\r\n      } else if (Util.isObject(field)) {\r\n        legendCfg = field;\r\n      } else {\r\n        legendCfg[field] = cfg;\r\n      }\r\n\r\n      legendController.legendCfg = legendCfg;\r\n      return this;\r\n    };\r\n  },\r\n  beforeGeomDraw: function beforeGeomDraw(chart) {\r\n    var legendController = chart.get('legendController');\r\n    if (!legendController.enable) return null; // legend is not displayed\r\n\r\n    var legendCfg = legendController.legendCfg;\r\n\r\n    if (legendCfg && legendCfg.custom) {\r\n      legendController.addCustomLegend();\r\n    } else {\r\n      var legendItems = chart.getLegendItems();\r\n      var scales = chart.get('scales');\r\n      var filters = chart.get('filters');\r\n      Util.each(legendItems, function (items, field) {\r\n        var scale = scales[field];\r\n        var values = scale.values;\r\n        var filteredVals;\r\n\r\n        if (filters && filters[field]) {\r\n          filteredVals = values.filter(function (v) {\r\n            return !filters[field](v);\r\n          });\r\n        } else {\r\n          filteredVals = [];\r\n        }\r\n\r\n        legendController.addLegend(scale, items, filteredVals);\r\n      });\r\n    }\r\n\r\n    if (legendCfg && legendCfg.clickable !== false) {\r\n      legendController.bindEvents();\r\n    }\r\n\r\n    var legends = legendController.legends;\r\n    var legendRange = {\r\n      top: 0,\r\n      right: 0,\r\n      bottom: 0,\r\n      left: 0\r\n    };\r\n    Util.each(legends, function (legendItems, position) {\r\n      var padding = 0;\r\n      Util.each(legendItems, function (legend) {\r\n        var width = legend.getWidth();\r\n        var height = legend.getHeight();\r\n\r\n        if (position === 'top' || position === 'bottom') {\r\n          padding = Math.max(padding, height);\r\n\r\n          if (legend.offsetY > 0) {\r\n            padding += legend.offsetY;\r\n          }\r\n        } else {\r\n          padding = Math.max(padding, width);\r\n\r\n          if (legend.offsetX > 0) {\r\n            padding += legend.offsetX;\r\n          }\r\n        }\r\n      });\r\n      legendRange[position] = padding + getPaddingByPos(position, chart.get('appendPadding'));\r\n    });\r\n    chart.set('legendRange', legendRange);\r\n  },\r\n  afterGeomDraw: function afterGeomDraw(chart) {\r\n    var legendController = chart.get('legendController');\r\n    legendController.alignLegends();\r\n  },\r\n  clearInner: function clearInner(chart) {\r\n    var legendController = chart.get('legendController');\r\n    legendController.clear();\r\n    chart.set('legendRange', null);\r\n  }\r\n};","\r\n\r\n/**\r\n * Handle the detail animations\r\n * @author sima.zhang1990@gmail.com\r\n */\r\nvar Util = require('../util/common');\r\n\r\nvar Element = require('../graphic/element');\r\n\r\nvar Timeline = require('../graphic/animate/timeline');\r\n\r\nvar Animator = require('../graphic/animate/animator');\r\n\r\nvar Animate = require('./animate');\r\n\r\nvar ShapeAction = require('./shape-action');\r\n\r\nvar GroupAction = require('./group-action');\r\n\r\nvar Chart = require('../chart/chart');\r\n\r\nvar timeline;\r\n\r\nElement.prototype.animate = function () {\r\n  var attrs = Util.mix({}, this.get('attrs'));\r\n  return new Animator(this, attrs, timeline);\r\n};\r\n\r\nChart.prototype.animate = function (cfg) {\r\n  this.set('animate', cfg);\r\n  return this;\r\n};\r\n\r\nAnimate.Action = ShapeAction;\r\nAnimate.defaultCfg = {\r\n  interval: {\r\n    enter: function enter(coord) {\r\n      if (coord.isPolar && coord.transposed) {\r\n        // for pie chart\r\n        return function (shape) {\r\n          shape.set('zIndex', -1);\r\n          var container = shape.get('parent');\r\n          container.sort();\r\n        };\r\n      }\r\n\r\n      return ShapeAction.fadeIn;\r\n    }\r\n  },\r\n  area: {\r\n    enter: function enter(coord) {\r\n      if (coord.isPolar) return null;\r\n      return ShapeAction.fadeIn;\r\n    }\r\n  },\r\n  line: {\r\n    enter: function enter(coord) {\r\n      if (coord.isPolar) return null;\r\n      return ShapeAction.fadeIn;\r\n    }\r\n  },\r\n  path: {\r\n    enter: function enter(coord) {\r\n      if (coord.isPolar) return null;\r\n      return ShapeAction.fadeIn;\r\n    }\r\n  }\r\n};\r\nvar GROUP_ANIMATION = {\r\n  line: function line(coord) {\r\n    if (coord.isPolar) {\r\n      return GroupAction.groupScaleInXY;\r\n    }\r\n\r\n    return GroupAction.groupWaveIn;\r\n  },\r\n  area: function area(coord) {\r\n    if (coord.isPolar) {\r\n      return GroupAction.groupScaleInXY;\r\n    }\r\n\r\n    return GroupAction.groupWaveIn;\r\n  },\r\n  path: function path(coord) {\r\n    if (coord.isPolar) {\r\n      return GroupAction.groupScaleInXY;\r\n    }\r\n\r\n    return GroupAction.groupWaveIn;\r\n  },\r\n  point: function point() {\r\n    return GroupAction.shapesScaleInXY;\r\n  },\r\n  interval: function interval(coord) {\r\n    var result;\r\n\r\n    if (coord.isPolar) {\r\n      // polar coodinate\r\n      result = GroupAction.groupScaleInXY;\r\n\r\n      if (coord.transposed) {\r\n        // pie chart\r\n        result = GroupAction.groupWaveIn;\r\n      }\r\n    } else {\r\n      result = coord.transposed ? GroupAction.groupScaleInX : GroupAction.groupScaleInY;\r\n    }\r\n\r\n    return result;\r\n  },\r\n  schema: function schema() {\r\n    return GroupAction.groupWaveIn;\r\n  }\r\n};\r\n\r\nfunction diff(fromAttrs, toAttrs) {\r\n  var endState = {};\r\n\r\n  for (var k in toAttrs) {\r\n    if (Util.isNumber(fromAttrs[k]) && fromAttrs[k] !== toAttrs[k]) {\r\n      endState[k] = toAttrs[k];\r\n    } else if (Util.isArray(fromAttrs[k]) && JSON.stringify(fromAttrs[k]) !== JSON.stringify(toAttrs[k])) {\r\n      endState[k] = toAttrs[k];\r\n    }\r\n  }\r\n\r\n  return endState;\r\n} // Add a unique id identifier to each shape\r\n\r\n\r\nfunction _getShapeId(geom, dataObj, geomIdx) {\r\n  var type = geom.get('type');\r\n  var id = 'geom' + geomIdx + '-' + type;\r\n  var xScale = geom.getXScale();\r\n  var yScale = geom.getYScale();\r\n  var xField = xScale.field || 'x';\r\n  var yField = yScale.field || 'y';\r\n  var yVal = dataObj[yField];\r\n  var xVal;\r\n\r\n  if (xScale.isIdentity) {\r\n    xVal = xScale.value;\r\n  } else {\r\n    xVal = dataObj[xField];\r\n  }\r\n\r\n  if (type === 'interval' || type === 'schema') {\r\n    id += '-' + xVal;\r\n  } else if (type === 'line' || type === 'area' || type === 'path') {\r\n    id += '-' + type;\r\n  } else {\r\n    id += xScale.isCategory ? '-' + xVal : '-' + xVal + '-' + yVal;\r\n  }\r\n\r\n  var groupScales = geom._getGroupScales();\r\n\r\n  Util.each(groupScales, function (groupScale) {\r\n    var field = groupScale.field;\r\n\r\n    if (groupScale.type !== 'identity') {\r\n      id += '-' + dataObj[field];\r\n    }\r\n  });\r\n  return id;\r\n} // get geometry's shapes\r\n\r\n\r\nfunction getShapes(geoms, chart, coord) {\r\n  var shapes = [];\r\n  Util.each(geoms, function (geom, geomIdx) {\r\n    var geomContainer = geom.get('container');\r\n    var geomShapes = geomContainer.get('children');\r\n    var type = geom.get('type');\r\n    var animateCfg = Util.isNil(geom.get('animateCfg')) ? _getAnimateCfgByShapeType(type, chart) : geom.get('animateCfg');\r\n\r\n    if (animateCfg !== false) {\r\n      Util.each(geomShapes, function (shape, index) {\r\n        if (shape.get('className') === type) {\r\n          shape._id = _getShapeId(geom, shape.get('origin')._origin, geomIdx);\r\n          shape.set('coord', coord);\r\n          shape.set('animateCfg', animateCfg);\r\n          shape.set('index', index);\r\n          shapes.push(shape);\r\n        }\r\n      });\r\n    }\r\n\r\n    geom.set('shapes', geomShapes);\r\n  });\r\n  return shapes;\r\n}\r\n\r\nfunction cache(shapes) {\r\n  var rst = {};\r\n\r\n  for (var i = 0, len = shapes.length; i < len; i++) {\r\n    var shape = shapes[i];\r\n    if (!shape._id || shape.isClip) continue;\r\n    var id = shape._id;\r\n    rst[id] = {\r\n      _id: id,\r\n      type: shape.get('type'),\r\n      // the type of shape\r\n      attrs: Util.mix({}, shape._attrs.attrs),\r\n      // the graphics attributes of shape\r\n      className: shape.get('className'),\r\n      geomType: shape.get('className'),\r\n      index: shape.get('index'),\r\n      coord: shape.get('coord'),\r\n      animateCfg: shape.get('animateCfg')\r\n    };\r\n  }\r\n\r\n  return rst;\r\n}\r\n\r\nfunction getAnimate(geomType, coord, animationType, animationName) {\r\n  var result;\r\n\r\n  if (Util.isFunction(animationName)) {\r\n    result = animationName;\r\n  } else if (Util.isString(animationName)) {\r\n    result = Animate.Action[animationName];\r\n  } else {\r\n    result = Animate.getAnimation(geomType, coord, animationType);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction getAnimateCfg(geomType, animationType, animateCfg) {\r\n  if (animateCfg === false || Util.isObject(animateCfg) && animateCfg[animationType] === false) {\r\n    return false;\r\n  }\r\n\r\n  var defaultCfg = Animate.getAnimateCfg(geomType, animationType);\r\n\r\n  if (animateCfg && animateCfg[animationType]) {\r\n    return Util.deepMix({}, defaultCfg, animateCfg[animationType]);\r\n  }\r\n\r\n  return defaultCfg;\r\n}\r\n\r\nfunction addAnimate(cache, shapes, canvas) {\r\n  var animate;\r\n  var animateCfg; // the order of animation: leave -> update -> enter\r\n\r\n  var updateShapes = [];\r\n  var newShapes = [];\r\n  Util.each(shapes, function (shape) {\r\n    var result = cache[shape._id];\r\n\r\n    if (!result) {\r\n      newShapes.push(shape);\r\n    } else {\r\n      shape.set('cacheShape', result);\r\n      updateShapes.push(shape);\r\n      delete cache[shape._id];\r\n    }\r\n  }); // first do the leave animation\r\n\r\n  Util.each(cache, function (deletedShape) {\r\n    var className = deletedShape.className,\r\n        coord = deletedShape.coord,\r\n        _id = deletedShape._id,\r\n        attrs = deletedShape.attrs,\r\n        index = deletedShape.index,\r\n        type = deletedShape.type;\r\n    animateCfg = getAnimateCfg(className, 'leave', deletedShape.animateCfg);\r\n    if (animateCfg === false) return true;\r\n    animate = getAnimate(className, coord, 'leave', animateCfg.animation);\r\n\r\n    if (Util.isFunction(animate)) {\r\n      var tempShape = canvas.addShape(type, {\r\n        attrs: attrs,\r\n        index: index,\r\n        canvas: canvas,\r\n        className: className\r\n      });\r\n      tempShape._id = _id;\r\n      animate(tempShape, animateCfg, coord);\r\n    }\r\n  }); // then do the update animation\r\n\r\n  Util.each(updateShapes, function (updateShape) {\r\n    var className = updateShape.get('className');\r\n    animateCfg = getAnimateCfg(className, 'update', updateShape.get('animateCfg'));\r\n    if (animateCfg === false) return true;\r\n    var coord = updateShape.get('coord');\r\n    var cacheAttrs = updateShape.get('cacheShape').attrs;\r\n    var endState = diff(cacheAttrs, updateShape._attrs.attrs); // 判断如果属性相同的话就不进行变换\r\n\r\n    if (Object.keys(endState).length) {\r\n      animate = getAnimate(className, coord, 'update', animateCfg.animation);\r\n\r\n      if (Util.isFunction(animate)) {\r\n        animate(updateShape, animateCfg, coord);\r\n      } else {\r\n        updateShape.attr(cacheAttrs);\r\n        updateShape.animate().to({\r\n          attrs: endState,\r\n          duration: animateCfg.duration,\r\n          easing: animateCfg.easing,\r\n          delay: animateCfg.delay\r\n        }).onEnd(function () {\r\n          updateShape.set('cacheShape', null);\r\n        });\r\n      }\r\n    }\r\n  }); // last, enter animation\r\n\r\n  Util.each(newShapes, function (newShape) {\r\n    // 新图形元素的进场元素\r\n    var className = newShape.get('className');\r\n    var coord = newShape.get('coord');\r\n    animateCfg = getAnimateCfg(className, 'enter', newShape.get('animateCfg'));\r\n    if (animateCfg === false) return true;\r\n    animate = getAnimate(className, coord, 'enter', animateCfg.animation);\r\n\r\n    if (Util.isFunction(animate)) {\r\n      if (className === 'interval' && coord.isPolar && coord.transposed) {\r\n        var index = newShape.get('index');\r\n        var lastShape = updateShapes[index - 1];\r\n        animate(newShape, animateCfg, lastShape);\r\n      } else {\r\n        animate(newShape, animateCfg, coord);\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\nfunction _getAnimateCfgByShapeType(type, chart) {\r\n  if (!type) {\r\n    return null;\r\n  }\r\n\r\n  var animateCfg = chart.get('animate');\r\n\r\n  if (type.indexOf('guide-tag') > -1) {\r\n    type = 'guide-tag';\r\n  }\r\n\r\n  if (Util.isObject(animateCfg)) {\r\n    return animateCfg[type];\r\n  }\r\n\r\n  if (animateCfg === false) {\r\n    return false;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nmodule.exports = {\r\n  afterCanvasInit: function afterCanvasInit()\r\n  /* chart */\r\n  {\r\n    timeline = new Timeline();\r\n    timeline.play();\r\n  },\r\n  beforeCanvasDraw: function beforeCanvasDraw(chart) {\r\n    if (chart.get('animate') === false) {\r\n      return;\r\n    }\r\n\r\n    var isUpdate = chart.get('isUpdate');\r\n    var canvas = chart.get('canvas');\r\n    var coord = chart.get('coord');\r\n    var geoms = chart.get('geoms');\r\n    var caches = canvas.get('caches') || [];\r\n\r\n    if (caches.length === 0) {\r\n      isUpdate = false;\r\n    }\r\n\r\n    var cacheShapes = getShapes(geoms, chart, coord);\r\n\r\n    var _chart$get = chart.get('axisController'),\r\n        frontPlot = _chart$get.frontPlot,\r\n        backPlot = _chart$get.backPlot;\r\n\r\n    var axisShapes = frontPlot.get('children').concat(backPlot.get('children'));\r\n    var guideShapes = [];\r\n\r\n    if (chart.get('guideController')) {\r\n      guideShapes = chart.get('guideController').guideShapes;\r\n    }\r\n\r\n    var componentShapes = [];\r\n    axisShapes.concat(guideShapes).forEach(function (s) {\r\n      var className = s.get('className');\r\n\r\n      var animateCfg = _getAnimateCfgByShapeType(className, chart);\r\n\r\n      s.set('coord', coord);\r\n      s.set('animateCfg', animateCfg);\r\n      componentShapes.push(s);\r\n      cacheShapes.push(s);\r\n    });\r\n    canvas.set('caches', cache(cacheShapes));\r\n\r\n    if (isUpdate) {\r\n      addAnimate(caches, cacheShapes, canvas);\r\n    } else {\r\n      // do the appear animation\r\n      var animateCfg;\r\n      var animate;\r\n      Util.each(geoms, function (geom) {\r\n        var type = geom.get('type');\r\n        var geomCfg = Util.isNil(geom.get('animateCfg')) ? _getAnimateCfgByShapeType(type, chart) : geom.get('animateCfg');\r\n\r\n        if (geomCfg !== false) {\r\n          animateCfg = getAnimateCfg(type, 'appear', geomCfg);\r\n          animate = getAnimate(type, coord, 'appear', animateCfg.animation);\r\n\r\n          if (Util.isFunction(animate)) {\r\n            var shapes = geom.get('shapes');\r\n            Util.each(shapes, function (shape) {\r\n              animate(shape, animateCfg, coord);\r\n            });\r\n          } else if (GROUP_ANIMATION[type]) {\r\n            // do the default animation\r\n            animate = GroupAction[animateCfg.animation] || GROUP_ANIMATION[type](coord);\r\n            var yScale = geom.getYScale();\r\n            var zeroY = coord.convertPoint({\r\n              x: 0,\r\n              y: yScale.scale(geom.getYMinValue())\r\n            });\r\n            var container = geom.get('container');\r\n            animate && animate(container, animateCfg, coord, zeroY);\r\n          }\r\n        }\r\n      }); // do the animation of components\r\n\r\n      Util.each(componentShapes, function (shape) {\r\n        var animateCfg = shape.get('animateCfg');\r\n        var className = shape.get('className');\r\n\r\n        if (animateCfg && animateCfg.appear) {\r\n          // if user configure\r\n          var defaultCfg = Animate.getAnimateCfg(className, 'appear');\r\n          var appearCfg = Util.deepMix({}, defaultCfg, animateCfg.appear);\r\n\r\n          var _animate = getAnimate(className, coord, 'appear', appearCfg.animation);\r\n\r\n          if (Util.isFunction(_animate)) {\r\n            _animate(shape, appearCfg, coord);\r\n          }\r\n        }\r\n      });\r\n    }\r\n  },\r\n  afterCanvasDestroyed: function afterCanvasDestroyed()\r\n  /* chart */\r\n  {\r\n    timeline.stop();\r\n  }\r\n};","\r\n\r\nvar _require = require('../util/requestAnimationFrame'),\r\n    requestAnimationFrame = _require.requestAnimationFrame;\r\n\r\nvar clock = typeof performance === 'object' && performance.now ? performance : Date;\r\n\r\nvar Timeline =\r\n/*#__PURE__*/\r\nfunction () {\r\n  function Timeline() {\r\n    this.anims = [];\r\n    this.time = null;\r\n    this.playing = false;\r\n    this.canvas = [];\r\n  }\r\n\r\n  var _proto = Timeline.prototype;\r\n\r\n  _proto.play = function play() {\r\n    var self = this;\r\n    self.time = clock.now();\r\n    self.playing = true;\r\n\r\n    function step() {\r\n      if (self.playing) {\r\n        requestAnimationFrame(step);\r\n        self.update();\r\n      }\r\n    }\r\n\r\n    requestAnimationFrame(step);\r\n  };\r\n\r\n  _proto.stop = function stop() {\r\n    this.playing = false;\r\n    this.time = null;\r\n    this.canvas = [];\r\n  };\r\n\r\n  _proto.update = function update() {\r\n    var currentTime = clock.now();\r\n    this.canvas = [];\r\n\r\n    for (var i = 0; i < this.anims.length; i++) {\r\n      var propertyAnim = this.anims[i];\r\n\r\n      if (currentTime < propertyAnim.startTime || propertyAnim.hasEnded) {\r\n        continue;\r\n      }\r\n\r\n      var shape = propertyAnim.shape; // shape\r\n\r\n      if (shape.get('destroyed')) {\r\n        this.anims.splice(i, 1);\r\n        i--;\r\n        continue;\r\n      }\r\n\r\n      var startState = propertyAnim.startState,\r\n          endState = propertyAnim.endState,\r\n          interpolate = propertyAnim.interpolate,\r\n          duration = propertyAnim.duration;\r\n\r\n      if (currentTime >= propertyAnim.startTime && !propertyAnim.hasStarted) {\r\n        propertyAnim.hasStarted = true;\r\n\r\n        if (propertyAnim.onStart) {\r\n          propertyAnim.onStart();\r\n        }\r\n      }\r\n\r\n      var t = (currentTime - propertyAnim.startTime) / duration;\r\n      t = Math.max(0, Math.min(t, 1));\r\n      t = propertyAnim.easing(t);\r\n\r\n      if (propertyAnim.onFrame) {\r\n        propertyAnim.onFrame(t);\r\n      } else {\r\n        for (var key in interpolate) {\r\n          var diff = interpolate[key];\r\n          var value = diff(t);\r\n          var newValue = void 0;\r\n\r\n          if (key === 'points') {\r\n            newValue = [];\r\n            var aLen = Math.max(startState.points.length, endState.points.length);\r\n\r\n            for (var j = 0; j < aLen; j += 2) {\r\n              newValue.push({\r\n                x: value[j],\r\n                y: value[j + 1]\r\n              });\r\n            }\r\n          } else {\r\n            newValue = value;\r\n          }\r\n\r\n          shape._attrs.attrs[key] = newValue;\r\n          shape._attrs.bbox = null; // should clear calculated bbox\r\n        }\r\n      }\r\n\r\n      var canvas = shape.get('canvas');\r\n\r\n      if (this.canvas.indexOf(canvas) === -1) {\r\n        this.canvas.push(canvas);\r\n      }\r\n\r\n      if (propertyAnim.onUpdate) {\r\n        propertyAnim.onUpdate(t);\r\n      }\r\n\r\n      if (currentTime >= propertyAnim.endTime && !propertyAnim.hasEnded) {\r\n        propertyAnim.hasEnded = true;\r\n\r\n        if (propertyAnim.onEnd) {\r\n          propertyAnim.onEnd();\r\n        }\r\n      }\r\n\r\n      if (t === 1) {\r\n        // end\r\n        this.anims.splice(i, 1);\r\n        i--;\r\n      }\r\n    }\r\n\r\n    this.canvas.map(function (c) {\r\n      c.draw();\r\n      return c;\r\n    });\r\n    this.time = clock.now();\r\n  };\r\n\r\n  return Timeline;\r\n}();\r\n\r\nmodule.exports = Timeline;","\r\n\r\nvar Easing = require('./easing');\r\n\r\nfunction plainArray(arr) {\r\n  var result = [];\r\n\r\n  for (var i = 0, len = arr.length; i < len; i++) {\r\n    if (arr[i]) {\r\n      result.push(arr[i].x);\r\n      result.push(arr[i].y);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction interpolateNumber(a, b) {\r\n  a = +a;\r\n  b -= a;\r\n  return function (t) {\r\n    return a + b * t;\r\n  };\r\n}\r\n\r\nfunction interpolateArray(a, b) {\r\n  var nb = b ? b.length : 0;\r\n  var na = a ? Math.min(nb, a.length) : 0;\r\n  var x = new Array(na);\r\n  var c = new Array(nb);\r\n  var i;\r\n\r\n  for (i = 0; i < na; ++i) {\r\n    x[i] = interpolateNumber(a[i], b[i]);\r\n  }\r\n\r\n  for (; i < nb; ++i) {\r\n    c[i] = b[i];\r\n  }\r\n\r\n  return function (t) {\r\n    for (i = 0; i < na; ++i) {\r\n      c[i] = x[i](t);\r\n    }\r\n\r\n    return c;\r\n  };\r\n}\r\n\r\nvar Animator =\r\n/*#__PURE__*/\r\nfunction () {\r\n  function Animator(shape, source, timeline) {\r\n    this.hasStarted = false;\r\n    this.hasEnded = false;\r\n    this.shape = shape;\r\n    this.source = source;\r\n    this.timeline = timeline;\r\n    this.animate = null;\r\n  } // delay, attrs, duration, easing\r\n\r\n\r\n  var _proto = Animator.prototype;\r\n\r\n  _proto.to = function to(cfg) {\r\n    if (cfg === void 0) {\r\n      cfg = {};\r\n    }\r\n\r\n    var delay = cfg.delay || 0;\r\n    var attrs = cfg.attrs || {};\r\n    var duration = cfg.duration || 1000;\r\n    var easing; // 缓动函数\r\n\r\n    if (typeof cfg.easing === 'function') {\r\n      easing = cfg.easing;\r\n    } else {\r\n      easing = Easing[cfg.easing] || Easing.linear;\r\n    }\r\n\r\n    var animInfo = {\r\n      shape: this.shape,\r\n      startTime: this.timeline.time + delay,\r\n      duration: duration,\r\n      easing: easing\r\n    };\r\n    var interpolate = {}; // 差值函数\r\n\r\n    for (var attrName in attrs) {\r\n      var startValue = this.source[attrName];\r\n      var endValue = attrs[attrName];\r\n\r\n      if (attrName === 'points') {\r\n        startValue = plainArray(startValue);\r\n        endValue = plainArray(endValue);\r\n        interpolate.points = interpolateArray(startValue, endValue);\r\n        this.source.points = startValue;\r\n        attrs.points = endValue;\r\n      } else if (attrName === 'matrix') {\r\n        interpolate.matrix = interpolateArray(startValue, endValue);\r\n      } else {\r\n        interpolate[attrName] = interpolateNumber(startValue, endValue);\r\n      }\r\n    }\r\n\r\n    animInfo.interpolate = interpolate;\r\n    animInfo.startState = this.source;\r\n    animInfo.endState = attrs;\r\n    animInfo.endTime = animInfo.startTime + duration;\r\n    this.timeline.anims.push(animInfo);\r\n    this.animate = animInfo;\r\n    return this;\r\n  };\r\n\r\n  _proto.onFrame = function onFrame(callback) {\r\n    // 自定义每一帧动画的动作\r\n    if (this.animate) {\r\n      this.animate.onFrame = function (frame) {\r\n        callback(frame);\r\n      };\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  _proto.onStart = function onStart(callback) {\r\n    if (this.animate) {\r\n      this.animate.onStart = function () {\r\n        callback();\r\n      };\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  _proto.onUpdate = function onUpdate(callback) {\r\n    if (this.animate) {\r\n      this.animate.onUpdate = function (frame) {\r\n        callback(frame);\r\n      };\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  _proto.onEnd = function onEnd(callback) {\r\n    if (this.animate) {\r\n      this.animate.onEnd = function () {\r\n        callback();\r\n      };\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  return Animator;\r\n}();\r\n\r\nmodule.exports = Animator;","\r\n\r\nvar Easing = {\r\n  linear: function linear(k) {\r\n    return k;\r\n  },\r\n  quadraticIn: function quadraticIn(k) {\r\n    return k * k;\r\n  },\r\n  quadraticOut: function quadraticOut(k) {\r\n    return k * (2 - k);\r\n  },\r\n  quadraticInOut: function quadraticInOut(k) {\r\n    if ((k *= 2) < 1) {\r\n      return 0.5 * k * k;\r\n    }\r\n\r\n    return -0.5 * (--k * (k - 2) - 1);\r\n  },\r\n  cubicIn: function cubicIn(k) {\r\n    return k * k * k;\r\n  },\r\n  cubicOut: function cubicOut(k) {\r\n    return --k * k * k + 1;\r\n  },\r\n  cubicInOut: function cubicInOut(k) {\r\n    if ((k *= 2) < 1) {\r\n      return 0.5 * k * k * k;\r\n    }\r\n\r\n    return 0.5 * ((k -= 2) * k * k + 2);\r\n  },\r\n  elasticIn: function elasticIn(k) {\r\n    var s;\r\n    var a = 0.1;\r\n    var p = 0.4;\r\n    if (k === 0) return 0;\r\n    if (k === 1) return 1;\r\n\r\n    if (!p) {\r\n      p = 0.3;\r\n    }\r\n\r\n    if (!a || a < 1) {\r\n      a = 1;\r\n      s = p / 4;\r\n    } else {\r\n      s = p / (2 * Math.PI) * Math.asin(1 / a);\r\n    }\r\n\r\n    return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\r\n  },\r\n  elasticOut: function elasticOut(k) {\r\n    var s;\r\n    var a = 0.1;\r\n    var p = 0.4;\r\n    if (k === 0) return 0;\r\n    if (k === 1) return 1;\r\n\r\n    if (!p) {\r\n      p = 0.3;\r\n    }\r\n\r\n    if (!a || a < 1) {\r\n      a = 1;\r\n      s = p / 4;\r\n    } else {\r\n      s = p / (2 * Math.PI) * Math.asin(1 / a);\r\n    }\r\n\r\n    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;\r\n  },\r\n  elasticInOut: function elasticInOut(k) {\r\n    var s;\r\n    var a = 0.1;\r\n    var p = 0.4;\r\n    if (k === 0) return 0;\r\n    if (k === 1) return 1;\r\n\r\n    if (!p) {\r\n      p = 0.3;\r\n    }\r\n\r\n    if (!a || a < 1) {\r\n      a = 1;\r\n      s = p / 4;\r\n    } else {\r\n      s = p / (2 * Math.PI) * Math.asin(1 / a);\r\n    }\r\n\r\n    if ((k *= 2) < 1) {\r\n      return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\r\n    }\r\n\r\n    return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\r\n  },\r\n  backIn: function backIn(k) {\r\n    var s = 1.70158;\r\n    return k * k * ((s + 1) * k - s);\r\n  },\r\n  backOut: function backOut(k) {\r\n    var s = 1.70158;\r\n    return (k = k - 1) * k * ((s + 1) * k + s) + 1;\r\n  },\r\n  backInOut: function backInOut(k) {\r\n    var s = 1.70158 * 1.525;\r\n\r\n    if ((k *= 2) < 1) {\r\n      return 0.5 * (k * k * ((s + 1) * k - s));\r\n    }\r\n\r\n    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\r\n  },\r\n  bounceIn: function bounceIn(k) {\r\n    return 1 - Easing.bounceOut(1 - k);\r\n  },\r\n  bounceOut: function bounceOut(k) {\r\n    if ((k /= 1) < 1 / 2.75) {\r\n      return 7.5625 * k * k;\r\n    } else if (k < 2 / 2.75) {\r\n      return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;\r\n    } else if (k < 2.5 / 2.75) {\r\n      return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;\r\n    }\r\n\r\n    return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;\r\n  },\r\n  bounceInOut: function bounceInOut(k) {\r\n    if (k < 0.5) {\r\n      return Easing.bounceIn(k * 2) * 0.5;\r\n    }\r\n\r\n    return Easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\r\n  }\r\n};\r\nmodule.exports = Easing;","\r\n\r\n/**\r\n * Animate configuration and register\r\n * @author sima.zhang1990@gmail.com\r\n */\r\nvar Util = require('../util/common');\r\n\r\nvar defaultAnimationCfg = {\r\n  appear: {\r\n    duration: 450,\r\n    easing: 'quadraticOut'\r\n  },\r\n  // 'appear' animation options\r\n  update: {\r\n    duration: 300,\r\n    easing: 'quadraticOut'\r\n  },\r\n  // 'update' animation options\r\n  enter: {\r\n    duration: 300,\r\n    easing: 'quadraticOut'\r\n  },\r\n  // 'enter' animation options\r\n  leave: {\r\n    duration: 350,\r\n    easing: 'quadraticIn'\r\n  } // 'leave' animation options\r\n\r\n};\r\nvar Animate = {\r\n  defaultCfg: {},\r\n  Action: {},\r\n  getAnimation: function getAnimation(geomType, coord, animationType) {\r\n    var geomAnimateCfg = this.defaultCfg[geomType];\r\n\r\n    if (geomAnimateCfg) {\r\n      var animation = geomAnimateCfg[animationType];\r\n\r\n      if (Util.isFunction(animation)) {\r\n        return animation(coord);\r\n      }\r\n    }\r\n\r\n    return false;\r\n  },\r\n  getAnimateCfg: function getAnimateCfg(geomType, animationType) {\r\n    var defaultCfg = defaultAnimationCfg[animationType];\r\n    var geomConfig = this.defaultCfg[geomType];\r\n\r\n    if (geomConfig && geomConfig.cfg && geomConfig.cfg[animationType]) {\r\n      return Util.deepMix({}, defaultCfg, geomConfig.cfg[animationType]);\r\n    }\r\n\r\n    return defaultCfg;\r\n  },\r\n  registerAnimation: function registerAnimation(animationName, animationFun) {\r\n    if (!this.Action) {\r\n      this.Action = {};\r\n    }\r\n\r\n    this.Action[animationName] = animationFun;\r\n  }\r\n};\r\nmodule.exports = Animate;","\r\n\r\n/**\r\n * Animation functions for shape\r\n * @author sima.zhang1990@gmail.com\r\n */\r\nvar Util = require('../util/common');\r\n\r\nvar Helpers = require('./util');\r\n/*\r\nfunction waveIn(shape, animateCfg, coord) {\r\n  const clip = Helpers.getClip(coord);\r\n  clip.set('canvas', shape.get('canvas'));\r\n  shape.attr('clip', clip);\r\n  const onEnd = function() {\r\n    shape.attr('clip', null);\r\n    clip.remove(true);\r\n  };\r\n  Helpers.doAnimation(clip, clip.endState, animateCfg, onEnd);\r\n}\r\n\r\nfunction scaleInX(shape, animateCfg) {\r\n  const box = shape.getBBox();\r\n  const points = shape.get('origin').points;\r\n  let x;\r\n  const y = (box.minY + box.maxY) / 2;\r\n\r\n  if (points[0].y - points[1].y > 0) { // 当顶点在零点之下\r\n    x = box.maxX;\r\n  } else {\r\n    x = box.minX;\r\n  }\r\n  const scaledMatrix = Helpers.getScaledMatrix(shape, [ x, y ], 'x');\r\n  Helpers.doAnimation(shape, { matrix: scaledMatrix }, animateCfg);\r\n}\r\n\r\nfunction scaleInY(shape, animateCfg) {\r\n  const box = shape.getBBox();\r\n  const points = shape.get('origin').points;\r\n  const x = (box.minX + box.maxX) / 2;\r\n  let y;\r\n\r\n  if (points[0].y - points[1].y <= 0) { // 当顶点在零点之下\r\n    y = box.maxY;\r\n  } else {\r\n    y = box.minY;\r\n  }\r\n  const scaledMatrix = Helpers.getScaledMatrix(shape, [ x, y ], 'x');\r\n  Helpers.doAnimation(shape, { matrix: scaledMatrix }, animateCfg);\r\n}\r\n*/\r\n\r\n\r\nfunction fadeIn(shape, animateCfg) {\r\n  var fillOpacity = Util.isNil(shape.attr('fillOpacity')) ? 1 : shape.attr('fillOpacity');\r\n  var strokeOpacity = Util.isNil(shape.attr('strokeOpacity')) ? 1 : shape.attr('strokeOpacity');\r\n  shape.attr('fillOpacity', 0);\r\n  shape.attr('strokeOpacity', 0);\r\n  var endState = {\r\n    fillOpacity: fillOpacity,\r\n    strokeOpacity: strokeOpacity\r\n  };\r\n  Helpers.doAnimation(shape, endState, animateCfg);\r\n}\r\n\r\nmodule.exports = {\r\n  // waveIn,\r\n  // scaleInX,\r\n  // scaleInY,\r\n  fadeIn: fadeIn\r\n};","\r\n\r\n/**\r\n * Utility\r\n * @author sima.zhang1990@gmail.com\r\n */\r\nvar _require = require('../graphic/index'),\r\n    Matrix = _require.Matrix;\r\n\r\nvar Util = require('../util/common');\r\n\r\nvar Helpers = {\r\n  getCoordInfo: function getCoordInfo(coord) {\r\n    var start = coord.start;\r\n    var end = coord.end;\r\n    return {\r\n      start: start,\r\n      end: end,\r\n      width: end.x - start.x,\r\n      height: Math.abs(end.y - start.y)\r\n    };\r\n  },\r\n  getScaledMatrix: function getScaledMatrix(shape, v, direct) {\r\n    var scaledMatrix;\r\n    shape.apply(v);\r\n    var x = v[0];\r\n    var y = v[1];\r\n\r\n    if (direct === 'x') {\r\n      shape.transform([['t', x, y], ['s', 0.01, 1], ['t', -x, -y]]);\r\n      var matrix = shape.getMatrix();\r\n      scaledMatrix = Matrix.transform(matrix, [['t', x, y], ['s', 100, 1], ['t', -x, -y]]);\r\n    } else if (direct === 'y') {\r\n      shape.transform([['t', x, y], ['s', 1, 0.01], ['t', -x, -y]]);\r\n\r\n      var _matrix = shape.getMatrix();\r\n\r\n      scaledMatrix = Matrix.transform(_matrix, [['t', x, y], ['s', 1, 100], ['t', -x, -y]]);\r\n    } else if (direct === 'xy') {\r\n      shape.transform([['t', x, y], ['s', 0.01, 0.01], ['t', -x, -y]]);\r\n\r\n      var _matrix2 = shape.getMatrix();\r\n\r\n      scaledMatrix = Matrix.transform(_matrix2, [['t', x, y], ['s', 100, 100], ['t', -x, -y]]);\r\n    }\r\n\r\n    return scaledMatrix;\r\n  },\r\n  getAnimateParam: function getAnimateParam(animateCfg, index, id) {\r\n    var result = {};\r\n\r\n    if (animateCfg.delay) {\r\n      result.delay = Util.isFunction(animateCfg.delay) ? animateCfg.delay(index, id) : animateCfg.delay;\r\n    }\r\n\r\n    result.easing = animateCfg.easing;\r\n    result.duration = animateCfg.duration;\r\n    result.delay = animateCfg.delay;\r\n    return result;\r\n  },\r\n  doAnimation: function doAnimation(shape, endState, animateCfg, callback) {\r\n    var id = shape._id;\r\n    var index = shape.get('index');\r\n\r\n    var _Helpers$getAnimatePa = Helpers.getAnimateParam(animateCfg, index, id),\r\n        easing = _Helpers$getAnimatePa.easing,\r\n        delay = _Helpers$getAnimatePa.delay,\r\n        duration = _Helpers$getAnimatePa.duration;\r\n\r\n    var anim = shape.animate().to({\r\n      attrs: endState,\r\n      duration: duration,\r\n      delay: delay,\r\n      easing: easing\r\n    });\r\n\r\n    if (callback) {\r\n      anim.onEnd(function () {\r\n        callback();\r\n      });\r\n    }\r\n  }\r\n};\r\nmodule.exports = Helpers;","\r\n\r\n/**\r\n * Group animate functions\r\n * @author sima.zhang1990@gmail.com\r\n */\r\nvar Util = require('./util');\r\n\r\nvar Helper = require('../util/helper');\r\n\r\nvar _require = require('../graphic/index'),\r\n    Shape = _require.Shape;\r\n\r\nfunction _groupScaleIn(container, animateCfg, coord, zeroY, type) {\r\n  var _Util$getCoordInfo = Util.getCoordInfo(coord),\r\n      start = _Util$getCoordInfo.start,\r\n      end = _Util$getCoordInfo.end,\r\n      width = _Util$getCoordInfo.width,\r\n      height = _Util$getCoordInfo.height;\r\n\r\n  var x;\r\n  var y;\r\n  var clip = new Shape.Rect({\r\n    attrs: {\r\n      x: start.x,\r\n      y: end.y,\r\n      width: width,\r\n      height: height\r\n    }\r\n  });\r\n\r\n  if (type === 'y') {\r\n    x = start.x + width / 2;\r\n    y = zeroY.y < start.y ? zeroY.y : start.y;\r\n  } else if (type === 'x') {\r\n    x = zeroY.x > start.x ? zeroY.x : start.x;\r\n    y = start.y + height / 2;\r\n  } else if (type === 'xy') {\r\n    if (coord.isPolar) {\r\n      x = coord.center.x;\r\n      y = coord.center.y;\r\n    } else {\r\n      x = (start.x + end.x) / 2;\r\n      y = (start.y + end.y) / 2;\r\n    }\r\n  }\r\n\r\n  var endMatrix = Util.getScaledMatrix(clip, [x, y], type);\r\n  clip.isClip = true;\r\n  clip.endState = {\r\n    matrix: endMatrix\r\n  };\r\n  clip.set('canvas', container.get('canvas'));\r\n  container.attr('clip', clip);\r\n\r\n  var onEnd = function onEnd() {\r\n    container.attr('clip', null);\r\n    clip.remove(true);\r\n  };\r\n\r\n  Util.doAnimation(clip, clip.endState, animateCfg, onEnd);\r\n}\r\n\r\nfunction _shapeScale(container, animateCfg, type) {\r\n  var shapes = container.get('children');\r\n  var x;\r\n  var y;\r\n  var endMatrix;\r\n\r\n  for (var i = 0, len = shapes.length; i < len; i++) {\r\n    var shape = shapes[i];\r\n    var box = shape.getBBox();\r\n    x = (box.minX + box.maxX) / 2;\r\n    y = (box.minY + box.maxY) / 2;\r\n    endMatrix = Util.getScaledMatrix(shape, [x, y], type);\r\n    Util.doAnimation(shape, {\r\n      matrix: endMatrix\r\n    }, animateCfg);\r\n  }\r\n}\r\n\r\nfunction groupScaleInX(container, animateCfg, coord, zeroY) {\r\n  _groupScaleIn(container, animateCfg, coord, zeroY, 'x');\r\n}\r\n\r\nfunction groupScaleInY(container, animateCfg, coord, zeroY) {\r\n  _groupScaleIn(container, animateCfg, coord, zeroY, 'y');\r\n}\r\n\r\nfunction groupScaleInXY(container, animateCfg, coord, zeroY) {\r\n  _groupScaleIn(container, animateCfg, coord, zeroY, 'xy');\r\n}\r\n\r\nfunction shapesScaleInX(container, animateCfg) {\r\n  _shapeScale(container, animateCfg, 'x');\r\n}\r\n\r\nfunction shapesScaleInY(container, animateCfg) {\r\n  _shapeScale(container, animateCfg, 'y');\r\n}\r\n\r\nfunction shapesScaleInXY(container, animateCfg) {\r\n  _shapeScale(container, animateCfg, 'xy');\r\n}\r\n\r\nfunction groupWaveIn(container, animateCfg, coord) {\r\n  var clip = Helper.getClip(coord);\r\n  clip.set('canvas', container.get('canvas'));\r\n  container.attr('clip', clip);\r\n\r\n  var onEnd = function onEnd() {\r\n    container.attr('clip', null);\r\n    clip.remove(true);\r\n  };\r\n\r\n  var endState = {};\r\n\r\n  if (coord.isPolar) {\r\n    var startAngle = coord.startAngle,\r\n        endAngle = coord.endAngle;\r\n    endState.endAngle = endAngle;\r\n    clip.attr('endAngle', startAngle);\r\n  } else {\r\n    var start = coord.start,\r\n        end = coord.end;\r\n    var width = Math.abs(start.x - end.x);\r\n    var height = Math.abs(start.y - end.y);\r\n\r\n    if (coord.isTransposed) {\r\n      clip.attr('height', 0);\r\n      endState.height = height;\r\n    } else {\r\n      clip.attr('width', 0);\r\n      endState.width = width;\r\n    }\r\n  }\r\n\r\n  Util.doAnimation(clip, endState, animateCfg, onEnd);\r\n}\r\n\r\nmodule.exports = {\r\n  groupWaveIn: groupWaveIn,\r\n  groupScaleInX: groupScaleInX,\r\n  groupScaleInY: groupScaleInY,\r\n  groupScaleInXY: groupScaleInXY,\r\n  shapesScaleInX: shapesScaleInX,\r\n  shapesScaleInY: shapesScaleInY,\r\n  shapesScaleInXY: shapesScaleInXY\r\n};"]}